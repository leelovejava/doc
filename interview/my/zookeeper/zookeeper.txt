1. 问了Zookeeper的工作原理。过半机制，还有节点为什么是单数台？
2N+1 半数

2. Zookeeper熟悉不？
zookeeper=文件系统+通知机制

通知机制:
    客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端

    实现原理:
        创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）

选举机制: 集群中半数以上机器存活，集群可用,比较myid。zookeeper适合装在奇数台机器上(myid)


3. Zookeeper有哪些组件？

Leader：
        同一时间只会有一个实际工作的Leader
        会发起并维护与各Follower及Observer间的心跳；
        所有的写操作必须要通过Leader完成，再由Leader将写操作广播给其他服务器

Follower：
        会响应Leader的心跳
        处理并返回客户端的请求,将写请求转发给Leader处理
        参与选举

Observer： 不参加选举也不响应提议,提高读取的吞吐量

4. Zookeeper的机制等，各组件的原理？

5. Zookeeper到底是干嘛的?

集群管理：监控节点存活状态、运行请求等。HA->高可用
主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。hbase
分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。
命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。->dubbo
分布式服务与注册: (dubbo的provider和consumer)

6. Zookeeper的二次开发？

7. 节点类型:
临时
临时顺序
永久
永久有序

8. Zookeeper实现分布式锁用哪个jar包，以及写mr、spark作业程序具体应该用哪些包？

9. 集群中为什么要有主节点？
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点

10. Zookeeper分布式锁实现原理?
curator框架

InterProcessMutex（可重入锁）,在zookeeper中创建临时有序节点实现

1)、在你指定的节点下创建一个锁目录lock

2)、线程X进来获取锁在lock目录下，并创建临时有序节点

3)、线程X获取lock目录下所有子节点，并获取比自己小的兄弟节点，如果不存在比自己小的节点，说明当前线程序号最小，顺利获取锁

4)、此时线程Y进来创建临时节点并获取兄弟节点 ，判断自己是否为最小序号节点，发现不是，于是设置监听（watch）比自己小的节点（这里是为了发生上面说的羊群效应）

5)、线程X执行完逻辑，删除自己的节点，线程Y监听到节点有变化，进一步判断自己是已经是最小节点，顺利获取锁

羊群效应优化:
如果几十个客户端同时争抢一个锁，此时会导致任何一个客户端释放锁的时候，zk反向通知几十个客户端，几十个客户端又要发送请求到zk去尝试创建锁，
几十个人要加锁，大家乱糟糟的，无序的
造成很多没必要的请求和网络开销，会加重网络的负载

解决: curator框架,创建临时顺序节点,不监听lock目录,监听比自己大的兄弟节点(前面节点)

分布式锁:
理解难易度(低->高):
    数据库 > 缓存 > Zookeeper
实现复杂性(低->高):
    Zookeeper >= 缓存 > 数据库
性能角度(高->低):
    缓存 > Zookeeper >=数据库
可靠性(高->低):
    Zookeeper-> 缓存 < 数据库

9. 如果遇到ZooKeeper脑裂问题，分布式锁应该如何保证健壮性？
分布式系统，主控节点有一个Master，此时因为网络故障，导致其他人以为这个Master不可用了，其他节点出现了别的Master，导致集群里有2个Master同时在运行

解决:修改curator框架源码，加一些协调机制

无法保证100%的健壮性,只能保证99.99%

* `Quorums`（[ˈkwɔːrəm]  法定人数） ：比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的
* `Redundant communications`：冗余通信的方式，集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。
* `Fencing`, 共享资源的方式：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中

[面试题：Zookeeper是如何解决脑裂问题](https://blog.csdn.net/u013374645/article/details/93140148)

[hadoop HA ZooKeeper的脑裂的出现和解决方案](https://blog.csdn.net/kenan2012/article/details/80781594)

10. [Zookeeper PK Eureka](https://www.cnblogs.com/jieqing/p/8394001.html)
CAP定理（C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性)

Zookeeper(CP): 选举时不可用
Eureka(AP): 高可用 -> `Peer to Peer`对等通信,去中心化的架构，无master/slave区分;全部不可用,本地缓存
            数据同步: 尝试从邻近节点获取所有实例注册表信息，完成初始化;Eureka Server通过`getEurekaServiceUrls()`方法获取所有的节点，并且会通过心跳续约的方式定期更新

总结
ZooKeeper基于CP，不保证高可用，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。
Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。
作为注册中心，其实配置是不经常变动的，只有发版和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。

所以理论上Eureka是更适合作注册中心。而现实环境中大部分项目可能会使用ZooKeeper，那是因为集群不够大，并且基本不会遇到用做注册中心的机器一半以上都挂了的情况。
所以实际上也没什么大问题

11. Zookeeper存储数据信息?
dubbo: [Zookeeper 保存的Dubbo信息详解](https://blog.csdn.net/HUXU981598436/article/details/88952032)
kafka:
hbase:
