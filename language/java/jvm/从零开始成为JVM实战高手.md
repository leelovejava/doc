# 从零开始成为JVM实战高手

https://pc-shop.xiaoe-tech.com/apppuKyPtrl1086/columnist_detail?id=p_5d0ef9900e896_MyDfcJi8

# 001、开篇词：JVM优化实战，广大Java工程师心中永远的痛！

2019-06-23 12:15:22

**开篇词：**

**JVM优化实战，广大Java工程师心中永远的痛！**



平时很多朋友跑来找我问以下一些类似的问题：

1. 线上用Dubbo开发的一个系统突然卡死了，JVM FullGC太频繁，求救！

   

   

2. 生产环境部署的一个系统隔几天就莫名其妙的进程崩溃，看了眼异常信息，说是OOM内存溢出，如何解决？在线等，急！

3. 出去面试，光是说一些JVM的内存模型、垃圾回收算法，不够啊！

   面试官怎么老是盯着我问生产环境遇到的JVM问题，各种参数的优化之类的，完全没经历过



类似的问题听的多了，我发现目前国内大多数Java工程师都面临一个共同的问题。



即对JVM的了解仅停留于书本和理论知识，而对JVM生产环境中的实战优化几乎一无所知。



有的朋友是一直开发那种几十个人使用的内部系统，所以没机会接触和经历。有的朋友是突然遇到线上JVM生产事故，毫无头绪。



为什么会造成这类现状呢？



答案其实也很简单，目前国内JVM相关的学习资料主要是两类：

- 一种是一些JVM大牛作者写的书籍
- 一种是网上大量凌乱繁杂的JVM实践博客。



对于JVM大牛写的一些书籍，其实都是很好的一些资料。但是书的本意并不是提供给你实战经验。



书的作用是站在理论知识总结和梳理的角度，把一个完整的理论知识体系呈现给你。



因此，从书上学到的也主要是体系化的理论知识。



而且虽然很多书籍的作者技术功底极为深厚，但是书里的内容非常的深奥晦涩，难以理解。



导致很多人即使是这种JVM的理论知识，也仅仅是吸收了里面可能就10%的精华，其他的也没法消化理解。



更重要的，从书本中，也更不可能获得JVM生产故障的实践经验和解决方案。



然后就是网上大量凌乱繁杂的JVM相关博客，很多作者其实确实是在记录自己遇到的一些JVM的生产故障的解决过程。



但是问题在于，博客往往是作者自己记录的r经历，面向的是自己，一切站在自己的角度出发。



而对于这个项目的背景、线上多大用户量、多少数据量、多大并发量、核心业务流程，在什么生产场景下发生的问题？**啥都没有！**



此外，对解决问题过程中涉及到的一些JVM底层原理，很多作者也不会说明白。



这就导致很多读者看博客，根本看不懂，搞不明白为什么会发生这个问题，搞不明白解决这个JVM生产故障背后的原理是什么！



**一句话总结**：放眼望去，目前国内并没有一个真正系统化讲解**JVM生产实战**的技术资料！



正是这个原因，导致了大量的Java工程师内心中对“**JVM实战**”这块内容有很大的痛点。



造成的直接后果就是遇到JVM生产事故不知道怎么处理和解决，出去面试被人问JVM生产实践毫无头绪！



因此我针对这些痛点，推出了**《**从零开始带你成为JVM实战高手**》**专栏。



这个专栏将作为一座桥梁，我将通过它，将我十余年线上处理JVM生产事故的经验，浓缩精华，传授给你。



考虑到目前国内大部分java程序员的JVM学习现状，这个专栏从设计时，就完全从两个角度出发：

- JVM理论知识从0起步，基于大量手绘图，保证让小白都能看懂

  

- 全程专注于JVM生产实践，主要解决JVM生产环境的参数优化，JVM GC问题和JVM OOM问题的处理



下面详细说一下上述两点：

1. 对于JVM必不可少的内存模型、类加载、垃圾回收等核心理论知识，我会采用几乎一步一图的方式进行讲解。

   另外配合上通俗易懂的大白话描述，带着大家彻底搞明白JVM底层的一些原理性知识

   JVM理论知识**讲解标准**：哪怕是对JVM完全不了解的小白同学，也一定能看得懂、学得会！

2. 然后重点，则完全放在“**实战**”二字。整个专栏一共有30多个真实的生产案例，都是我多年带团队负责的各种系统中出现和遇到的JVM生产问题，比如：

3. - 每日百万交易的支付系统的JVM生产参数优化
   - 每日上亿请求量的电商系统的GC参数优化
   - 百万级用户的在线教育平台的G1垃圾回收优化
   - 更不用说每秒10万并发的BI系统、每日百亿数据量的处理系统、视频系统、大促系统等各类系统中的JVM GC问题和JVM OOM问题的生产优化



更重要的一点，每个案例绝对**站在一个读者的角度**出发，也就是从业务背景出发。



案例中会包含这个系统的用户量、并发量、数据量以及核心业务流程，进而给出发生生产故障的真实场景



然后是一步一步如何分析、排查和定位每个问题的，包括解决问题的过程中涉及到的底层JVM原理的剖析。



我的思路，就是用大量的生产案例贯穿整个专栏，进而教给大家遇到JVM生产事故时一个常规性的定位排查、分析解决问题的思路和方法



同时通过大量真实案例的演练，让大家直接积累起丰富的生产故障排查经验



此外，在专栏中还有大量的动手实验的环节，会设计很多的实验，大家只要照着做，就可以体验到各种JVM生产问题的现场。



然后再自己一步步去进行监控、分析日志，这样可以很好的锻炼大家的动手实践能力。



而且在每周我都会留下很多作业，作业会引导你去思考你手头负责的系统。



假设你的并发量、数据量扩大100倍，你会不会遇到JVM问题？如果在你的系统中遇到问题，你该怎么来处理和解决？



通过这类作业，目的就是引导大家思考如何将学习到的各种实战技能进行落地，让自己真正掌握。



通过这样的一个JVM实战专栏的学习，我相信每个认真跟着学习下来的Java工程师，都能够拥有如下的能力：

- 对自己负责的线上系统，可以进行生产环境的JVM参数优化
- 线上遇到生产故障，自己绝对有思路去进行分析、排查和定位
- 你会清楚怎么去动手实践，明白背后的JVM的底层原理
- 此外，你通过课程积累好的几十个案例的经验，也将支撑你去对各种不同的生产故障进行解决和处理



另外专栏还会贯穿大量的**大厂JVM面试题剖析**，因此在学习完专栏过后，大家出去面试，无论是JVM的原理，还是JVM的生产实践，国内没有公司面得倒你。



最后，从这篇文章开始，咱们即将一起走过15周的学习旅程。希望15周之后，这里的每个同学都能从0开始，成为一个JVM实战高手！



**End**



# 002、一探究竟：我们写的Java代码到底是如何运行起来的？

2019-06-23 14:08:45

**一探究竟：**

**我们的Java代码到底是如何运行起来的？**

本文是我们正式开始讲解JVM的第一篇文章。

第一周我们不会讲解太多过于深奥的原理知识，那样会让很多原本对JVM不太了解的同学难以平滑的入门。

第一周的内容主要是高屋建瓴的把JVM运行机制的整体脉络梳理清楚，而很多原本对JVM就有一定了解的同学，可以耐下心来，就当做是复习梳理一下。

要研究JVM技术，先得搞明白一个问题：

- **我们平时写的Java代码，到底是怎么运行起来的？**

针对这个问题，我们来一步一步的分析。

首先假设咱们写好了一份Java代码，那这份Java代码中，是不是会包含很多的“.java”为后缀的代码文件？

比如User.java，OrderService.java，CustomerManager.java

其实咱们Java程序员平时在Eclipse、Intellij IDEA等开发工具中，就有很多类似这样的Java源代码文件。

那么大家现在思考一下，当我们写好这些“.java”后缀的代码文件之后，接下来你要部署到线上的机器上去运行，你会怎么做？

一般来说，都是把代码给打成“.jar”后缀的jar包，或者是“.war”后缀的war包，是不是？

然后呢，就是把你打包好的jar包或者是war包给放到线上机器去部署。

这个部署就有很多种途径了，但是最基本的一种方式，就是通过Tomcat这类容器来部署代码，也可以是你自己手动通过“java”命令来运行一个jar包中的代码。

咱们先用下面这张图，回忆一下这个顺序。

![01_打包.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60992200_1561998556.png)



但是实际上这里有一个非常关键的步骤，那就是“**编译**”

也就是说，在我们写好的“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件，比如“User.class”，“Hello.class”，”Customer.class“。

然后这个“.class”后缀的字节码文件，他才是可以被运行起来的！

所以首先，无论大家对JVM机制是否熟悉，咱们都先来回顾一下这个编译的过程，以及“.class”字节码文件的概念。

来看看下图，一起来感受一下：

![02_编译.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85310300_1561998556.png)

接着我们可能就要思考下一个问题：

对于编译好的这些“.class”字节码，是怎么让他们运行起来的呢？

这个时候就需要使用诸如“java -jar”之类的命令来运行我们写好的代码了。

此时一旦你采用“java”命令，实际上此时就会启动一个JVM进程。

这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

所以平时我们写好的某个系统在一台机器上部署的时候，你一旦启动这个系统，其实就是启动了一个JVM，由它来负责运行这台机器上运行的这个系统。

对这个概念，大家一定要先搞清楚。

我们还是用一张图来展示一下，相信大家图文结合，会理解的更好。

![03_jvm.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3266600_1561998557.png)



接着下一步，JVM要运行这些“.class”字节码文件中的代码，那是不是首先得把这些“.class”文件中包含的各种类给加载进来？

这些“.class”文件不就是我们写好的一个一个的类吗？对不对？

此时就会有一个“**类加载器**”的概念。

此时会采用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

我们再看下图。

![04_类加载.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13473300_1561998557.png)



接着，最后一步，JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了

比如你的代码中有一个“main()”方法，那么JVM就会从这个“main()”方法开始执行里面的代码。

他需要哪个类的时候，就会使用类加载器来加载对应的类，反正对应的类就在“.class”文件中。

大家最后看看下面的图。

![05_执行代码.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24399300_1561998557.png)

好，最后我们来对本文小结一下：

无论是对JVM了解或者是不了解的同学，我们都希望通过第一周的基本原理知识讲解，降低学习后面JVM优化实战技术的门槛。

对于了解JVM的同学权当复习梳理，而且鼓励大家在底部评论发言，说说自己的理解和看法。

对于不太了解JVM的小白同学，也可以抄底门槛迅速入门，无缝衔接后续的知识学习。

所以本文从我们平时写“.java”后缀的源代码开始，一步一步梳理了以下的流程：

- 写好的代码编译成“.class”后缀的字节码文件
- JVM是个什么东西
- JVM跟我们平时运行在机器上的系统之间是什么关系
- 类加载器的概念
- 针对加载进内存的类进行代码的执行

这就是本文讲解的内容总结，希望大家对这部分内容高屋建瓴的先有一个认识。

另外，最后我给大家留一个思考题：既然“.java”文件可以编译成“.class”文件再运行，那么也肯定可以将“.class”文件反编译成“.java”文件。

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

大家可以思考思考，踊跃提问和发言，明天的文章里，在末尾我会跟大家探讨一下这个问题。

**End**



# 003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？

2019-06-23 14:31:28

**面试官对于JVM类加载机制的猛烈炮火，****你能顶住吗？**



**目录：**

1. 前文回顾
2. JVM在什么情况下会加载一个类？
3. 从实用角度出发，来看看验证、准备和初始化的过程
4. 核心阶段：初始化
5. 类加载器和双亲委派机制
6. 昨日思考题的解答





**1、前文回顾**

咱们今天先来回顾一下昨天讲到的JVM整体的一个运行原理。

我们首先从“.java”代码文件，编译成“.class”字节码文件

然后类加载器把“.class”字节码文件中的类给加载到JVM中

接着是JVM来执行我们写好的那些类中的代码，整体是这么个顺序。

再看看下图，感受一下这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67189100_1562062006.cn/txdocpic/0/85881164faa1fa93a71120127057d4c3/0)

那么今天，我们就来仔细看看上图中的“**类加载**”这个过程，看看JVM的类加载机制到底是怎么样的？

搞清楚这个过程了，那么以后在面试时，对面试官常问的JVM类加载机制，就能把一些核心概念说清楚了。



**2、JVM在什么情况下会加载一个类？**

其实类加载过程非常的琐碎复杂，但是对于我们平时从工作中实用的角度来说，主要是把握他的核心工作原理就可以。

一个类从加载到使用，一般会经历下面的这个过程：

**加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载**

所以首先要搞明白的第一个问题，就是JVM在执行我们写好的代码的过程中，一般在什么情况下会去加载一个类呢？

也就是说，啥时候会从“.class”字节码文件中加载这个类到JVM内存里来。

其实答案非常简单，就是在**你的代码中用到这个类的时候**。

举个简单的例子，比如下面你有一个类（Kafka.class），里面有一个“main()”方法作为主入口。

那么一旦你的JVM进程启动之后，它一定会先把你的这个类（Kafka.cass）加载到内存里，然后从“main()”方法的入口代码开始执行。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/81370700_1562062006.png)



我们还是坚持一步一图，大家先看看下图，感受一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99941000_1562062006.cn/txdocpic/0/20b99ce2902c58d0a246861f046cc402/0)

接着假设上面的代码中，出现了如下的这么一行代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/16673900_1562062007.png)



这时可能大家就想了，你的代码中明显需要使用“ReplicaManager”这个类去实例化一个对象，此时必须得把“ReplicaManager.class”字节码文件中的这个类加载到内存里来啊！是不是？

所以这个时候就会触发JVM通过类加载器，从“ReplicaManager.class”字节码文件中加载对应的类到内存里来使用，这样代码才能跑起来。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/34835300_1562062007.cn/txdocpic/0/8a2acdae659f69979687cafb5470e80a/0)

上面就是给大家举的一个例子，相信非常的通俗易懂。

简单概括一下：首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。



**3、从实用角度出发，来看看验证、准备和初始化的过程**

其实上面的类加载时机的问题，对于很多有经验的同学来说不是什么问题。

但是对于很多初学者来说，是一个非常重要的需要捋清的概念。

接下来就来简单带着大家，从实用的角度出发，过一下另外三个概念：

**验证、准备、初始化**

其实对于这三个概念，没太大的必要去深究里面的细节，这里的细节很多很繁琐，对于大部分同学而言，只要脑子里有下面的几个概念就可以了：

**（1）验证阶段**

简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。

这个相信很好理解，假如说，你的“.class”文件被人篡改了，里面的字节码压根儿不符合规范，那么JVM是没法去执行这个字节码的！

所以把“.class”加载到内存里之后，必须先验证一下，校验他必须完全符合JVM规范，后续才能交给JVM来运行。

下面用一张图，展示了这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47365600_1562062007.cn/txdocpic/0/9b5b706b0486cce3c20e53cc2d13cd07/0)

**（2）准备阶段**

这个阶段其实也很好理解，咱们都知道，我们写好的那些类，其实都有一些类变量

比如下面的这个“ReplicaManager”类：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/71602900_1562062007.png)

假设你有这么一个“ReplicaManager”类，他的“ReplicaManager.class”文件内容刚刚被加载到内存之后，会进行验证，确认这个字节码文件的内容是规范的

接着就会进行准备工作。

这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间

然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值

比如上面的示例里，就会给“flushInterval”这个类变量分配内容空间，给一个“0”这个初始值。

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83060200_1562062007.cn/txdocpic/0/c9f43e3b1451aa91cfbfb8a7b6abad30/0)



**（3）解析阶段**

这个阶段干的事儿，实际上是把**符号引用替换为直接引用**的过程，其实这个部分的内容很复杂，涉及到JVM的底层

但是注意，同学们，就我本意而言，希望第一周的文章，绝对是浅显易懂的，循序渐进，要保证每个同学都能绝对看懂。

所以针对这个阶段，现在不打算做过深的解读，因为从实用角度而言，对很多同学在工作中实践JVM技术其实也用不到，所以这里大家就暂时知道有这么一个阶段就可以了。

同样，我还是给大家画图展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96343600_1562062007.cn/txdocpic/0/34ebc43cda680141456638ca4963e770/0)

**（4）三个阶段的小结**

其实这三个阶段里，最核心的大家务必关注的，就是**“准备阶段”**

因为这个阶段是给加载进来的类分配好了内存空间，类变量也分配好了内存空间，并且给了默认的初始值，这个概念，大家心里一定要有。



**4、核心阶段：初始化**

之前说过，在准备阶段时，就会把我们的“ReplicaManager”类给分配好内存空间

另外他的一个类变量“flushInterval”也会给一个默认的初始值“0”，那么接下来，在初始化阶段，就会正式执行我们的类初始化的代码了。

那么什么是类初始化的代码呢？我们来看看下面这段代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8399800_1562062008.png)

大家可以看到，对于“flushInterval”这个类变量，我们是打算通过Configuration.getInt("replica.flush.interval")这段代码来获取一个值，并且赋值给他的

但是在准备阶段会执行这个赋值逻辑吗？

**NO！**在准备阶段，仅仅是给“flushInterval”类变量开辟一个内存空间，然后给个初始值“0”罢了。

那么这段赋值的代码什么时候执行呢？答案是在**“初始化”**阶段来执行。

在这个阶段，就会执行类的初始化代码，比如上面的  Configuration.getInt("replica.flush.interval")  代码就会在这里执行，完成一个配置项的读取，然后赋值给这个类变量“flushInterval”。

另外比如下图的static静态代码块，也会在这个阶段来执行。

类似下面的代码语义，可以理解为类初始化的时候，调用“loadReplicaFromDish()”方法从磁盘中加载数据副本，并且放在静态变量“replicas”中：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24615100_1562062008.png)

那么搞明白了类的初始化是什么，就得来看看类的初始化的规则了。

**什么时候会初始化一个类？**

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41037200_1562062008.png)

如果你要“new ReplicaManager()”初始化这个类的实例，那么会加载这个类，然后初始化这个类

但是初始化这个类之前，发现AbstractDataManager作为父类还没加载和初始化，那么必须先加载这个父类，并且初始化这个父类。

这个规则，大家必须得牢记，再来一张图，借助图片来进行理解：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53805800_1562062008.cn/txdocpic/0/605fa929375991cb7645c28f8f815b0f/0)



**5、类加载器和双亲委派机制**

现在相信大家都搞明白了整个类加载从触发时机到初始化的过程了，接着给大家说一下类加载器的概念

因为实现上述过程，那必须是依靠类加载器来实现的

那么Java里有哪些类加载器呢？简单来说有下面几种：

**（1）启动类加载器**

**Bootstrap ClassLoader**，他主要是负责加载我们在机器上安装的Java目录下的核心类的

相信大家都知道，如果你要在一个机器上运行自己写好的Java系统，无论是windows笔记本，还是linux服务器，是不是都得装一下JDK？

那么在你的Java安装目录下，就有一个“**lib**”目录，大家可以自己去找找看，这里就有Java最核心的一些类库，支撑你的Java系统的运行。

所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

**（2）扩展类加载器**

**Extension ClassLoader**，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

那么你的JVM一旦启动，是不是也得从Java安装目录下，加载这个“lib\ext”目录中的类？

**（3）应用程序类加载器**

**Application ClassLoader**，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类

其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

**（4）自定义类加载器**

除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

**（5）双亲委派机制**

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65579400_1562062008.cn/txdocpic/0/932fe13b12b449c8a97fc42e6029b613/0)

然后，基于这个亲子层级结构，就有一个**双亲委派的机制**

什么意思呢？

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

听完了上面一大堆绕口令，是不是很迷茫？别着急，咱们用一个例子来说明一下。

比如你的JVM现在需要加载“ReplicaManager”类，此时应用程序类加载器会问问自己的爸爸，也就是扩展类加载器，你能加载到这个类吗？

然后扩展类加载器直接问自己的爸爸，启动类加载器，你能加载到这个类吗？

启动类加载器心想，我在Java安装目录下，没找到这个类啊，**自己找去**！

然后，就下推加载权利给扩展类加载器这个儿子，结果扩展类加载器找了半天，也没找到自己负责的目录中有这个类。

这时他很生气，说：明明就是你应用程序加载器自己负责的，你自己找去。

然后应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。

这就是所谓的**双亲委派模型：**先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。

最后，给大家来一张图图，感受一下类加载器的双亲委派模型。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79558100_1562062008.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**6、昨日思考题的解答**

好！今天的文章看完了，相信大家就能大致推测出昨日的思考题的答案了。

我昨天的问题是：如何对“.class”文件处理保证不被人拿到以后反编译获取公司源代码？

其实认真看完今天的文章，就很简单了。

首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理

现在有很多第三方公司，都是专门做商业级的字节码文件加密的，所以可以付费购买他们的产品。

然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人窃取。

**7、今日思考题**

今天再给大家留一个思考题，相信每个做Java的同学，都知道现在一般用Java开发的Web系统，除非是基于Java写中间件，一般都是采用Tomcat之类的Web容器来部署的。

那么大家想想，Tomcat本身就是用Java写的，他自己就是一个JVM。

我们写好的那些系统程序，说白了，就是一堆编译好的.class文件放入一个war包，然后在Tomcat中来运行的。

那么，Tomcat的类加载机制应该怎么设计，才能把我们动态部署进去的war包中的类，加载到Tomcat自身运行的JVM中，然后去执行那些我们写好的代码呢？

大家先思考，明天文末会给大家进行梳理并给出答案。

**End**



# 004、大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的？

2019-06-23 14:34:05

**大厂面试题**

**JVM中有哪些内存区域，分别是用来干嘛的？**



目录：

1. 前文回顾
2. 大厂面试背景引入
3. 到底什么是JVM的内存区域划分？
4. 存放类的方法区
5. 执行代码指令用的程序计数器
6. Java虚拟机栈
7. Java堆内存
8. 核心内存区域的全流程串讲
9. 其他内存区域
10. 本文小结
11. 昨日思考题解答
12. 今日思考题



**1、前文回顾**

上一篇文章我们聊了一下JVM类加载这块的机制，先简单回顾一下。

大家需要搞明白的是，在什么情况下会触发类的加载？加载之后的验证、准备和解析分别是干什么的？

尤为重要的是准备阶段和初始化阶段，是如何为类分配内存空间的？然后类加载器的规则是什么？

来看一下上篇文章的图，简单回顾一下。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51671600_1562174045.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**2、大厂面试背景引入**

很多人想要到阿里、美团、京东等互联网大公司去面试，但是现在互联网大厂面试一般都必定会考核JVM相关的知识积累

所以在了解完了JVM的类加载机制之后，先一起来看看JVM的内存区域划分，这个基本上是互联网公司面试必问。



**3、到底什么是JVM的内存区域划分？**

其实这个问题非常简单，JVM在运行我们写好的代码时，他是必须使用多块内存空间的，不同的内存空间用来放不同的数据，然后配合我们写的代码流程，才能让我们的系统运行起来。

举个最简单的例子，比如咱们现在知道了JVM会加载类到内存里来供后续运行，那么我问问大家，这些类加载到内存以后，放到哪儿去了呢？想过这个问题吗？

所以JVM里就必须有一块内存区域，用来存放我们写的那些类。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68335300_1562174045.cn/txdocpic/0/a36d967a636bd6cba968132fe7d5a2fe/0)

继续来看，我们的代码运行起来时，是不是需要执行我们写的一个一个的方法？

那么运行方法的时候，方法里面有很多变量之类的东西，是不是需要放在某个内存区域里？

接着如果我们写的代码里创建一些对象，这些对象是不是也需要内存空间来存放？

同样的，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87758600_1562174045.cn/txdocpic/0/40ce28b870bb122aedb3d3c9183c9d94/0)

这就是为什么JVM中必须划分出来不同的内存区域，它是为了我们写好的代码在运行过程中根据需要来使用的。

接下来，我们就依次看看JVM中有哪些内存区域。



**4、存放类的方法区**

这个方法区是在JDK 1.8以前的版本里，代表JVM中的一块区域。

主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。

但是在JDK 1.8以后，这块区域的名字改了，叫做“Metaspace”，可以认为是“元数据空间”这样的意思。当然这里主要还是存放我们自己写的各种类相关的信息。

举个例子，还是跟我们之前说的那样，假设我们有一个“Kafka.class”类和“ReplicaManager.class”类，类似下面的代码。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/7691900_1562174046.png)



这两个类加载到JVM后，就会放在这个方法区中，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/30635300_1562174046.cn/txdocpic/0/5ed39984ec95cdb3f63edcf9ff174d6f/0)





**5、执行代码指令用的程序计数器**

继续假设我们的代码是如下所示：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51858600_1562174046.png)



之前给大家讲过，实际上上面那段代码首先会存在于“.java”后缀的文件里，这个文件就是java源代码文件。

但是这个文件是面向我们程序员的，计算机他是看不懂你写的这段代码的。

所以此时就得通过编译器，把“.java”后缀的源代码文件编译为“.class”后缀的字节码文件。

这个“.class”后缀的字节码文件里，存放的就是对你写出来的代码编译好的字节码了。

字节码才是计算器可以理解的一种语言，而不是我们写出来的那一堆代码。

字节码看起来大概是下面这样的，跟上面的代码无关，就是一个示例而已，给大家感受一下。



```
public java.lang.String getName();     descriptor: ()Ljava/lang/String;     flags: ACC_PUBLIC     Code:         stack=1, locals=1, args_size=1             0: aload_0             1: get_field    #2             4: areturn
```



这段字节码就是让大家知道“.java”翻译成的“.class”是大概什么样子的。

比如“0: aload_0”这样的，就是“字节码指令”，他对应了一条一条的机器指令，计算机只有读到这种机器码指令，才知道具体应该要干什么。

比如字节码指令可能会让计算机从内存里读取某个数据，或者把某个数据写入到内存里去，都有可能，各种各样的指令就会指示计算机去干各种各样的事情。

所以现在大家首先明白一点：**我们写好的Java代码会被翻译成字节码，对应各种字节码指令**

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。

所以当JVM加载类信息到内存之后，实际就会使用自己的**字节码执行引擎**，去执行我们写的代码编译出来的代码指令，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70899500_1562174046.cn/txdocpic/0/82f3b71cabd27c3abf8e58509ca117f6/0)

那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”

这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。

我们通过一张图来说明：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95852000_1562174046.cn/txdocpic/0/e735b486fa6a29c189af7d947558e70b/0)

大家都知道JVM是支持多个线程的，所以其实你写好的代码可能会开启多个线程并发执行不同的代码，所以就会有多个线程来并发的执行不同的代码指令

因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了

下图更加清晰的展示出了他们之间的关系。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24349900_1562174047.cn/txdocpic/0/ee845415897bb5b7b8cf888a2a1464d0/0)

**6、Java虚拟机栈**

Java代码在执行的时候，一定是线程来执行某个方法中的代码

哪怕就是下面的代码，也会有一个main线程来执行main()方法里的代码

在main线程执行main()方法的代码指令的时候，就会通过main线程对应的程序计数器记录自己执行的指令位置。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49375500_1562174047.png)

但是在方法里，我们经常会定义一些方法内的局部变量

比如在上面的main()方法里，其实就有一个“replicaManager”局部变量，他是引用一个ReplicaManager实例对象的，关于这个对象我们先别去管他，先来看方法和局部变量。

因此，JVM必须有一块区域是来保存每个方法内的**局部变量**等数据的，这个区域就是Java虚拟机栈

每个线程都有自己的Java虚拟机栈，比如这里的main线程就会有自己的一个Java虚拟机栈，用来存放自己执行的那些方法的局部变量。

如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧

栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西，这里大家先不用全都理解，我们先关注局部变量。

比如main线程执行了main()方法，那么就会给这个main()方法创建一个栈帧，压入main线程的Java虚拟机栈

同时在main()方法的栈帧里，会存放对应的“replicaManager”局部变量

上述过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67197800_1562174047.cn/txdocpic/0/4197da8f1fcfa8b97b97638b6247e5c3/0)

然后假设main线程继续执行ReplicaManager对象里的方法，比如下面这样，就在“loadReplicasFromDisk”方法里定义了一个局部变量：“hasFinishedLoad”

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92921500_1562174047.png)



那么main线程在执行上面的“loadReplicasFromDisk”方法时，就会为“loadReplicasFromDisk”方法创建一个栈帧压入线程自己的Java虚拟机栈里面去。

然后在栈帧的局部变量表里就会有“hasFinishedLoad”这个局部变量。

整个过程如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10232200_1562174048.cn/txdocpic/0/7192f064bdb42017288b83dafa584709/0)

接着如果“loadReplicasFromDisk”方法调用了另外一个“isLocalDataCorrupt()”方法 ，这个方法里也有自己的局部变量

比如下面这样的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20448000_1562174116.png)



那么这个时候会给“isLocalDataCorrupt”方法又创建一个栈帧，压入线程的Java虚拟机栈里。

而且“isLocalDataCorrupt”方法的栈帧的局部变量表里会有一个“isCorrupt”变量，这是“isLocalDataCorrupt”方法的局部变量

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33506800_1562174048.cn/txdocpic/0/457d1c2f6d89903e8e36916dda9ea744/0)

接着如果“isLocalDataCorrupt”方法执行完毕了，就会把“isLocalDataCorrupt”方法对应的栈帧从Java虚拟机栈里给出栈

然后如果“loadReplicasFromDisk”方法也执行完毕了，就会把“loadReplicasFromDisk”方法也从Java虚拟机栈里出栈。

上述就是JVM中的“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈

在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。

咱们再来看一个图，了解一下每个线程在执行代码时，除了程序计数器以外，还搭配了一个Java虚拟机栈内存区域来存放每个方法中的局部变量表。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/58381900_1562174048.cn/txdocpic/0/02705de5b5a6d20bf41b2e37e41c2a1d/0)



**7、Java堆内存**

现在大家都知道了，main线程执行main()方法的时候，会有自己的程序计数器。

此外，还会依次把main()方法，loadReplicasFromDisk()方法，isLocalDataCorrupt()方法的栈帧压入Java虚拟机栈，存放每个方法的局部变量。

那么接着我们就得来看JVM中的另外一个非常关键的区域，就是Java堆内存，这里就是存放我们在代码中创建的各种对象的

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12867100_1562174155.png)



上面的“new ReplicaManager()”这个代码就是创建了一个ReplicaManager类的对象实例，这个对象实例里面会包含一些数据，如下面的代码所示。

这个“ReplicaManager”类里的“replicaCount”就是属于这个对象实例的一个数据。

类似ReplicaManager这样的对象实例，就会存放在Java堆内存里。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40763600_1562174255.png)



Java堆内存区域里会放入类似ReplicaManager的对象，然后我们因为在main方法里创建了ReplicaManager对象的，那么在线程执行main方法代码的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址

相当于你可以认为局部变量表里的“replicaManager”指向了Java堆内存里的ReplicaManager对象

还是给大家来一张图，更加清晰一些：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/84661900_1562174048.cn/txdocpic/0/17d3ff214c6a93034ed5829639dbca23/0)



**8、核心内存区域的全流程串讲**

其实我们把上面的那个图和下面的这个总的大图一起串起来看看，还有配合整体的代码，我们来捋一下整体的流程，大家就会觉得很清晰。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3659300_1562174049.cn/txdocpic/0/a574bfb97766cfa0c041624c117c79ca/0)



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20435800_1562174255.png)



首先，你的JVM进程会启动，就会先加载你的Kafka类到内存里。然后有一个main线程，开始执行你的Kafka中的main()方法。

main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

大家结合上图中的程序计数器来理解一下。

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

看到这里，大家结合上面的两个图理解一下。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

其实大家理解了这个过程，那么JVM中的各个核心内存区域的功能和对应的我们的Java代码之间的关系，就彻底理解了



**9、其他内存区域**

其实在JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的

如果大家去看他内部的源码，会发现很多地方都不是Java代码了，而是走的native方法去调用本地操作系统里面的一些方法，可能调用的都是c语言写的方法，或者一些底层类库

比如下面这样的：public native int hashCode();

在调用这种native方法的时候，就会有线程对应的本地方法栈，这个里面也是跟Java虚拟机栈类似的，也是存放各种native方法的局部变量表之类的信息。

还有一个区域，是不属于JVM的，通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。

其实很多技术都会用这种方式，因为有一些场景下，堆外内存分配可以提升性能。



**10、本文小结**

本文到这里就结束了，基本上把JVM里的核心内存区域的功能解释清楚了

大家需要重点去关注方法区、程序计数器、Java虚拟机栈和Java堆这些内存区域的作用，和我们配套的图以及代码结合起来去理解。



**11、昨日思考题解答**

昨天让大家去思考一下：Tomcat这种Web容器中的类加载器应该如何设计实现？

这里给大家一个简单的思路给回复。

首先Tomcat的 类加载器体系如下图所示，他是自定义了很多类加载器的。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/23933200_1562174049.cn/txdocpic/0/9c56ad956e2c39a693c88472309c961a/0)

Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。

然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类

至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。

而且大家一定要记得，Tomcat是打破了双亲委派机制的

每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。

如果大家感兴趣，可以自己找资料去学习研究Tomcat的类加载机制。



**12、今日思考题**

今天我们学习了JVM中的各个内存区域，那么先留给大家一个思考题：

我们在Java堆内存中分配的那些对象，到底会占用多少内存？一般怎么来计算和估算我们的系统创建的对象对内存占用的一个压力呢？

# 005、JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？

2019-06-23 14:35:28

**JVM的垃圾回收机制是用来干嘛的？**

**为什么要垃圾回收？**



**目录：**

1. 前文回顾
2. 对象的分配与引用
3. 一个方法执行完毕后会怎样？
4. 我们创建的Java对象其实都是占用内存资源的
5. 不再需要的那些对象应该怎么处理？
6. 本文小结





**1、前文回顾**

上一篇文章给大家分析了JVM中的几块内存区域分别都是干什么的，今天的文章就给大家初步介绍一下垃圾回收的概念。

但是今天的文章对垃圾回收不会切入过深，因为很多学习专栏的朋友都是一些初学者。

因此，咱们还是那句话，尽量用最通俗的语言配合大量手绘图，让大家初步了解垃圾回收到底是什么。

先来看一下昨天的一张图，回顾一下JVM中几块内存区域的作用。

![01_总大图.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27918700_1562230843.jpg)

大家脑子里一定要有一个会动的图，你的代码在运行的时候，起码有一个main线程会去执行所有的代码，当然也可能是你启动的别的线程。

然后线程执行时必须通过自己的程序计数器来记录执行到哪一个代码指令了

另外线程在执行方法时，为每个方法都得创建一个栈帧放入自己的Java虚拟机栈里去，里面有方法的局部变量。

最后就是代码运行过程中创建的各种对象，都是放在Java堆内存里的。

结合上面的大图看一看，相信大家一定就明白是怎么回事了，大家对JVM的运行原理也应该都有了一个初步的理解和把握。



**2、对象的分配与引用**

现在我们假设有下面一段代码，大概意思你可以理解为通过“loadReplicasFromDisk”方法的执行，去磁盘上加载需要的副本数据

然后通过“ReplicaManager”对象实例完成了这个操作。

代码如下所示：

![代码1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42627800_1562230843.png)

结合我们之前理解过的JVM运行原理，一起通过动态的图来拆解一下上述代码的运行流程。

首先一个main线程肯定会来执行main()方法里的代码

main线程自己是有一个Java虚拟机栈的，他会把main()方法的栈帧压入Java虚拟机栈

如下图所示：

![02_压入栈帧.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54079800_1562230843.jpg)

接着main()方法里调用了loadReplicasFromDisk()方法

那么就会创建loadReplicasFromDisk()方法的栈帧，压入main线程的Java虚拟机栈里去

这个过程如下图：

![03_继续压入栈帧.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67192600_1562230843.jpg)

此时发现在loadReplicasFromDisk()方法里，有一个“repliaManager”变量，那么就会在loadReplicasFromDisk()方法对应的栈帧里，放入一个“repliaManager”变量。

继续看下图：

![04_局部变量.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92889300_1562230843.jpg)

接着发现在代码里创建了一个“ReplicaManager”类的实例对象，此时就会在Java堆内存中分配这个实例对象的内存空间。

同时，让loadReplicasFromDisk()方法的栈帧内的“replicaManager”局部变量去指向那个Java堆内存里的ReplicaManager实例对象，大家看下图：

![05_分配对象.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4461000_1562230844.jpg)

接下来，就会执行通过“replicaManager”局部变量引用的“ReplicaManager”实例对象去执行他的load()方法，去完成我们实现的业务逻辑。

好，到这里为止，其实都是上篇文章讲解过的知识，我们就是重新串联了一遍，相信大家都很好理解。



**3、一个方法执行完毕之后会怎么样？**

接着大家来回顾一下上面的代码。

![代码2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15050100_1562230844.png)

其实目前的图我们已经表述到了“replicaManager.load()”这行代码这里

那么现在有个问题，如果这行代码执行结束了，此时会怎么样？

大家还记得之前文章说过，一旦方法里的代码执行完毕，那么方法就执行完毕了，也就是说loadReplicasFromDisk()方法就执行完毕了。

一旦你的loadReplicasFromDisk()方法执行完毕，此时就会把loadReplicasFromDisk()方法对应的栈帧从main线程的Java虚拟机栈里出栈

如下图所示：

![06_出栈.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29818700_1562230844.jpg)

此时一旦loadReplicasFromDisk()方法的栈帧出栈，那么大家会发现那个栈帧里的局部变量，“replicaManager”，也就没有了。

也就是说，没有任何一个变量指向Java堆内存里的“ReplicaManager”实例对象了。



**4、我们创建的Java对象其实都是占用内存资源的**

核心点来了，此时大家发现了，Java堆内存里的那个“ReplicaManager”实例对象已经没有人引用他了

这个对象实际上已经没用了，该干的事儿都干完了，现在你还让他留在内存里干啥呢？

大家要知道，内存资源是有限的。

一般来说，我们会在一台机器上启动一个Java系统，机器的内存资源是有限的，比如就4个G的内存

然后我们启动的Java系统本质就是一个JVM进程，他负责运行我们的系统的代码，这个之前都解释过了。

那么这个JVM进程本身也是会占用机器上的部分内存资源，比如占用2G的内存资源。

那么我们在JVM的Java堆内存中创建的对象，其实本质也是会占用JVM的内存资源的，比如“ReplicaManager”实例对象，会占用500字节的内存。

所以大家看到这里，心中应该无比明白的一个核心点：我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

大家看下面的图，感受会深一点。

![07_内存占用.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/43162800_1562230844.jpg)



**5、不再需要的那些对象应该怎么处理？**

继续思考上面的图，既然“ReplicaManager”对象实例是不需要使用的，已经没有任何方法的局部变量在引用这个实例对象了，而且他还空占着内存资源，那么我们应该怎么处理呢？

答案呼之欲出：**JVM的垃圾回收机制**

JVM本身是有垃圾回收机制的，他是一个后台自动运行的线程

你只要启动一个JVM进程，他就会自带这么一个垃圾回收的后台线程。

这个线程会在后台不断检查JVM堆内存中的各个实例对象

还是给大家画一张图，来看看这个过程：

![08_垃圾回收线程.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54743400_1562230844.jpg)

如果某个实例对象没有任何一个方法的局部变量指向他，也没有任何一个类的静态变量，包括常量等地方在指向他。

那么这个垃圾回收线程，就会把这个没人指向的“ReplicaManager”实例对象给回收掉，从内存里清除掉，让他不再占用任何内存资源。

这样的话，这些不再被人指向的对象实例，即JVM中的“**垃圾**”，就会定期的被后台垃圾回收线程清理掉，不断释放内存资源

大家看下图：

![09_垃圾回收.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74706600_1562230844.jpg)

到此为止，相信大家跟上文章思路一路看下来，就很清晰明了。到底什么是JVM中的“垃圾”？什么又是JVM的“垃圾回收”！



**6、本文小结**

不知不觉，第一周的文章都更新完毕了，希望大家温故而知新。

既然是付费来学习知识的，一定要对自己负责，坚持把每篇文章多看几遍，把知识吃透。

这周，我们为了照顾很多JVM的小白同学，从0起步，用最通俗易懂的语言和一步一图的方式，把你写好的Java代码如何通过JVM运行起来的核心原理都讲清楚了。

目前为止，大家应该对JVM的核心运行流程、JVM的类加载机制、JVM的内存区域以及垃圾回收机制都有一个初步的了解。

很多对JVM有一定了解的朋友一定会说：这些内容都很简单，有没有深入点的干货？

**有！**但是请不要着急，我们的专栏是兼顾各种基础的朋友，所以需要循序渐进，从浅入深。

比如JVM垃圾回收机制，就会在第三周详细讲解JVM的各种垃圾回收的细节

所以请大家稍安勿躁，一步一步来，如果有一定基础的同学，就当做复习一遍。

马上周末就是第一周的作业和答疑集锦了，大家周末记得完成作业，同时看一下每周最新的精华答疑集锦，从答疑中也能学习到一些知识。

**7、希望大家多帮忙宣传和推广**

专栏刚上线的时候，是拜托我的好朋友在公众号里宣传的，现在他还在一直坚持帮我们宣传，非常的感谢他。

不过当时刚上线，我们一篇文章都没更新，很多朋友对我们的文章质量是没有了解的，所以可能会犹豫不决要不要购买

不过经过一周文章下来，相信很多一路跟下来的朋友，都对这个专栏质量有了自己的了解和认可。

我和即将发布专栏的几位朋友都长年工作于一线大厂，比如阿里、百度、美团，等等，负责过多个大型系统的架构设计。

之所以聚在狸猫技术窝这个平台开设专栏，初衷就是为了帮助国内广大的java工程师，解决大家在面试中、工作中的一些痛点问题。

现在网上很多技术资料，但是鱼龙混杂，底子薄弱的朋友很难辨别其内容优劣，很容易被带跑偏。

所以我们几个朋友才希望通过自己的思路，来做一些高质量的专栏，将我们多年一线工作经验浓缩精华，传授给大家，也是为国内IT界尽一点绵薄之力。

但是由于刚开始做，很多人不了解我们，所以还是希望购买我们专栏的朋友，如果觉得我们的内容不错，帮忙多宣传一下。

大家可以根据下面步骤生成自己的海报，推荐给朋友，分享技术的同时还能获得一点收益。

最后，感谢大家为我们坚持长期推出更多好的专栏做出的支持！



**8、昨日思考题解答**

我们回到文章中，昨天给了一个思考题：我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？

这个其实很简单，一个对象对内存空间的占用，大致分为两块：

- 一个是对象自己本身的一些信息
- 一个是对象的实例变量作为数据占用的空间

比如对象头，如果在64位的linux操作系统上，会占用16字节，然后如果你的实例对象内部有个int类型的实例变量，他会占用4个字节，如果是long类型的实例变量，会占用8个字节。如果是数组、Map之类的，那么就会占用更多的内存了。

另外JVM对这块有很多优化的地方，比如补齐机制、指针压缩机制，这块东西我们不会单独拿出来讲，因为比较复杂，而且暂时对大家还不是很需要。

其实我信奉的一个道理，就是用案例实战来说话，引出很多技术和知识点的讲解，所以很多类似的知识，我会在后期大量的案例中去分析，需要的时候再学，效果最好。

这里就是先科普一下，让大家有一个基本的概念，如果有兴趣可以百度资料自己查阅。



**8、今日思考题**

既然今天提到了Java堆内存里的对象会被回收掉，那么加载到方法区的类会被垃圾回收吗？什么时候被回收？为什么呢？

大家可以思考一下这个问题，下周一的文章里会给出解答。

**End**

# 006、第1周作业：不借助任何资料，画出JVM整体运行原理图！

**作业内容：**

这是我们的专栏第一周的作业，首先我们来简单回顾一下。

这一周，我们从JVM的整体运行原理开始学习，分析了JVM的类加载机制，JVM的内存区域划分以及对应的工作原理，JVM的垃圾回收到底是什么。

所以第一周的定位，就是从最通俗的语言以及一步一图的方式，兼顾到很多JVM小白初学者，绝对跟着看下来可以快速入门JVM的基本工作原理，整体把握他的脉络。

对于已经对JVM有一定了解的朋友来说，就是快速简单梳理和回顾一下。

那么第一周的作业是什么呢？

很简单，希望大家把第一周的文章反复看几遍，完全做到心里有数

接着在不看任何资料的前提下，自己仿照文章那样，写出来一段代码，然后找一个画图工具，动手画图，把那段代码运行的时候，JVM的整个工作原理画出来。比如：

- 执行多个方法的调用时，如何把方法的栈帧压入线程的Java虚拟机栈？
- 栈帧里如何放局部变量？
- 如何在Java堆里创建实例对象？
- 如何让局部变量引用那个实例对象？
- 方法运行完之后如何出栈？
- 垃圾回收是如何运行的？

希望大家不借助资料，直接根据自己心里对JVM原理的理解，把这个图画出来。

再强调一下，我设计这个专栏的思路，就是每周必须有作业，因为光看不复习，光看不练，看了等于白看。

大家必须跟着完成作业，才能真正把学到的东西吸收成自己的东西，一个专栏跟下来，才能真正积累很多硬核技术。

希望大家周末都抽一点时间，完成本周作业。

# 007、第1周答疑：本周问题统一答疑

2019-06-23 14:39:29

**第一周问题统一答疑**



下面是本周大家的问题汇总，所有同学都可以看看，边看边思考！



**问题一：**

方法走完，引用消失，堆内存还未必消失。好多人在做报表导出的时候，就会在for循环里不断的创建对象，很容易造成堆溢出，请问这种大文件导出怎么破？

**答：**建议不要在for里创建对象，可以在外面搞一个对象，for循环里对一个对象修改数据即可

**问题二**

1.Java支持多线程，每个线程有自己的Java虚拟机栈和本地方法栈，是这样吗？ 

2.新建的实例在堆内存，实例变量也是在堆内存? 是这样吗？

**答：**1、2两点均理解正确

**问题三**

您好，我不太看懂入栈和出栈有什么意义，可以给我解释一下吗？谢谢！

**答：**入栈的时候，就是你执行一个方法的时候，为这个方法创建一个栈帧入栈

出栈，就是你的方法执行完毕了，就会出栈，其实这个不用急，明天的文章会有详细的图解，你会看明白的。

**问题四**

如果是父类子类的情况是下面哪种呢? 加载父类->加载子类->初始化父类->初始化子类, 加载父类->初始化父类->加载子类->初始化子类

**答：**不是的，加载父类就是父类，除非用到子类才会加载子类；但是加载子类要初始化之前，必须先加载父类，初始化父类

**问题五**

类加载器有三层，如果在第二层的类加载器可以加载这些类的话，就没有必要往上去找他的父类加载吗？

既然说类只有用到的时候才加载到内存中，那么new对象的时候肯定用到，但是是不是先经历过类的所有过程才将类实例化？

**答：**没错，必须先加载类，再实例化对象

**问题六**

第一课内容比较详细的讲解了java程序的执行过程，但是感觉提出的问题并不能在文章中找到答案，也许是一个课后需要自己找寻答案的提问？还是希望可以有一个比较全面的回答的

**答：**提出的问题是给大家的思考题，第二天会给出简单的解释，但是其实理解了文章的内容，完全可以自己找资料去理解，这是一个小作业，是一个思考的过程

**问题七**

Object Header（4字节） + Class Pointer（4字节）+ Fields（看存放类型），但是jvm内存占用是8的倍数，所以结果要向上取整到8的倍数

**答：**很好，就是这样

**问题八**

如果我有一个静态的成员变量int,那我多线程更改是否会有线程安全问题，为什么？

**答：**静态成员变量，他在内存里，只有一份，就是属于类的。你多个线程并发修改，一定会有并发问题，可能导致数据出错。

**问题九**

类加载是按需加载，可以一次性加载全部的类吗？

**答：**如果是默认的类加载机制，那么是你的代码运行过程中，遇到什么类加载什么类。如果你要自己加载类，那么需要写自己的类加载器

**问题十**

为什么必须要一级一级类加载器的往上找，直接从顶层类加载器开始找不就行了吗？

**答：**其实关于这个问题，不用过于纠结，每一层类加载器对某个类的加载，上推给父类加载器，到顶层类加载器，如果发现自己加载不到，再下推回子类加载器来加载，这样可以保证绝对不会重复加载某个类。

至于为什么不直接从顶层类加载器开始找，那是因为类加载器本身就是做的父子关系模型

你想一下Java代码实现，他最底下的子类加载器，只能通过自己引用的父类加载器去找。如果直接找顶层类加载器，不合适的，那么顶层类加载器不就必须硬编码规定了吗？

这就是一个代码设计思想，保证代码的可扩展性。

**问题十一**

是在执行new replicamanager()这行代码的时候加载replicamanger类吗？还是说加载cafka的时候就同时加载了呢？

**答：**执行new ReplicaManager的时候加载类

**问题十二**

还是没有明白 jvm和平时运行在机器上的系统之间是什么关系呢

**答：**其实很简单，你运行在机器上的系统，其实就是一个JVM进程，JVM进程会执行你系统里写好的那些代码

**问题十三**

1. class文件分配内存是在准备阶段，那类的class对象是在准备阶段创建的吗？ 
2. 如果实例变量有初始值，那实例变量是和类变量一同在初始化阶段赋值的吗？
3. 初始化之后是不是就有实例了

**答：**

1. 类是在准备阶段分配内存空间的
2. 实例变量得在你创建类的实例对象时才会初始化
3. 类的初始化阶段，仅仅是初始化类而已，跟对象无关，用new关键字才会构造一个对象出来



**问题十四**

双亲委派可以解决类重复加载的问题。按照文章中介绍每个类加载器有不同的类加载路径，这些类加载路径是否可能重叠？

**答：**不同类加载器的路径，一般是不会重叠的

**问题十五**

自定义的类加载器本身是由系统加载器加载的，也就是说其本身是没有加密的，那么我拿到该类反编译就可以看到如果解密class文件了，请问老师是这样么？

**答：**是的，所以说对class文件需要做特殊混淆处理，有商用的产品可以用

**问题十六**

作为一个web容器，既要解决跨应用公共共享问题也要解决独立应用独立问题。tomcat必须支持多层级的自定义类加载器

**答：**很好的推测，明天会给出答案

**问题十七**

用户使用类的时候应该是希望类已经准备好了一些数据，我猜想jvm设计者设计先执行static代码块的机制，是希望开发者在这里把使用类之前需要准备的工作在这里准备好 

1. 为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？
2. 启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要

**答：**

1. 没错，必须有初始化过程，准备好类级别的数据
2. 双亲委派，避免重复加载，评论区里多次回复了这个问题，可以看一看

**问题十八**

其实初始化时机就是对类的主动使用：调用静态方法时对类的主动使用的一种场景，main方法本质上是个static方法，没有调用的main方法和没有调用的static方法没区别！

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

**答：**不会的，你启动一个jar包，需要指定某个main主类，优先就是加载他

**问题十九**

tomcat本身是java程序，那么tomcat的实现程序的class是由应用类加载器加载的，用户自己的java程序war包，放入tomcat的程序的classpath中

这样用户的程序和tomcat的程序都是由应用类加载器加载了，也就是处于一个jvm中了（此问题是003文章底下的评论）

**答：**非常好的回复，明天文章会给出答案

**问题二十**

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

**答：**你启动一个jar包的时候，会指定是走哪个main方法所在的类，是唯一的

**问题二十一**

1. 为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？
2. 启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要

**答：**

1. 没错，类在方法区，他在内存里，所以你必须给他初始化，赋值
2. 还是有必要，比如启动类加载器，可以通过一些方式指定加载其他目录的类，那么你必须得走双亲委派，如果对那些特殊区域的类加载，走双亲委派，才能上推到启动类加载器去执行，不会重复加载

**问题二十二**

老师好请问类加载双亲委派机制 为什么要先找父加载 而不是自己找？这种设计的好处是？

**答：**好处就在于，每个层级的类加载器各司其职，而且不会重复加载一个类。

比如你代码里用两个不同层级的类加载器，都去尝试加载了某个类，如果有双亲委派机制，那么都会先找父类加载器去加载，如果加载到了，那么以后就只会是他去加载这个类。

否则如果没有双亲委派机制，那么岂不是两个不同层级的类加载器可以加载同一个类，造成类的重复加载！

**问题二十三**

自定义类加载器如何实现？

**答：**自己写一个类，继承ClassLoader类，重写类加载的方法，然后在代码里面可以用自己的类加载器去针对某个路径下的类加载到内存里来

**问题二十四**

看到一个词:动态部署，那么是否也有对应的静态部署?如何解释呢？ (谢老师回答)

**答：**假设一个背景在Tomcat部署系统的话，那么动态部署，也成为热部署

就是直接系统放入Tomcat对应目录，他自动就重新加载你最新的代码给你热部署了，不需要对Tomcat进行停机再重启；

反之，则是先停止Tomcat，然后部署最新代码到Tomcat对应目录里，然后重启Tomcat

**问题二十五**

-XX:+TraceClassLoading 可以看加载了哪些类，动手实验了一下，jre\lib\rt.jar下的类全部加载了，其他都是用到时候加载。

**答：**没错，明天更新的第三篇文章里，会讲解类加载机制，rt.jar这属于核心类库，属于支撑我们Java系统运行的底层类库，所以他一定会被加载

我们自己写的代码，一般是你代码运行使用到了哪个类，就会去加载哪个类

**问题二十六**

老师，类加载器是把jar包里的所有类一次性全部加载进去吗？

**答：**不是的，首先加载包含main方法的主类，接着是运行你写的代码的时候，遇到你用了什么类，再加载什么类

**问题二十七**

通过代码混淆机制，加大反编译之后的可读性！ 或者是否可以基于二进制加密呢，学生没用过！

**答：**其实现在对于这个一般都是用商业产品的，有很多第三方公司提供加密产品，可以百度一下，class文件加密，就可以看到，直接用他们的产品即可

**问题二十八**

Class源文件的保护，可以采用代码混淆技术，方式有很多，如回答区中老师提到的商用加密软件

**答：**非常好，就是这样

**问题二十九**

看文中内容，是会加载两次字节码吗，第一次加载进jvm，然后程序执行的时候再加载。有点不解！

**答：**你好，不是加载两次，是JVM先把“.class”字节码文件中的类加载到内存里，然后执行的时候，就直接使用加载好的类极客，不会重复加载

**问题三十**

class文件通过工具可以反编译的，请问有没有方法对class文件进行加密又不影响它的执行。windows桌面程序里一般都是打包成dll文件，java中有没有比较好的方式？

**答：**可以的，比如jvmti小工具就可以实现class文件的加密

另外其实为了保护源代码安全，有很多商业公司推出了专业级别的class加密产品，可以付费使用。

解密的话一般可以基于自定义的类加载器来实现，在加载类的时候把class给解密，这样就可以保护自己的源代码安全了。

最后，附上两张Tomcat类加载如果**按委派模型的加载流程和实际实现的流程**（专栏读者所画）

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45640100_1562430625.png)



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80064300_1562430625.png)



**End**

# 008、聊聊JVM分代模型：年轻代、老年代、永久代

2019-06-23 14:40:22

**聊聊JVM分代模型：年轻代、老年代、永久代**



**目录：**

1. 背景引入
2. 大部分对象其实存活周期极短
3. 少数对象是长期存活的
4. JVM分代模型：年轻代和老年代
5. 为什么要分成年轻代和老年代？
6. 什么是永久代？
7. 上周思考题解答
8. 今日思考题





**1、背景引入**

今天开始，咱们进入第二周的内容，这一周会重点关注JVM内存划分的一些细节。

我会帮助大家更加深入的去理解JVM内存划分的原理细节，以及我们创建的那些对象在JVM中到底是如何分配，如何流动的，这对于大家理解JVM原理有更深一层的帮助。

首先这篇文章作为本周的一个开篇，我们来给大家介绍一下JVM内存的一个分代模型：年轻代、老年代、永久代。

大家现在应该都知道一点，那就是我们在代码里创建的对象，都会进入到Java堆内存中，比如下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/61041000_1562517499.png)



这段代码，我们稍微做了点改动，在main()方法里，会周期新的执行loadReplicasFromDisk()方法，加载副本数据。

首先一旦执行main()方法，那么就会把main()方法的栈帧压入main线程的Java虚拟机栈

如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68813000_1562517499.cn/txdocpic/0/04e1bc7e9b465b7d40b1e46243f08344/0)

然后每次在while循环里，调用loadReplicasFromDisk()方法，就会把loadReplicasFromDisk()方法的栈帧压入自己的Java虚拟机栈

如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80080800_1562517499.cn/txdocpic/0/e3896c4cea154b2422622ec685e74752/0)

接着在执行loadReplicasFromDisk()方法的时候，会在Java堆内存里会创建一个ReplicaManager对象实例

而且loadReplicasFromDisk()方法的栈帧里会有“replicaManager”局部变量去引用Java堆内存里的ReplicaManager对象实例

如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5349600_1562517500.cn/txdocpic/0/8d169c754c01f0340e3b1d9f40654709/0)

然后就会执行ReplicaManager对象的load()方法。



**2、大部分对象都是存活周期极短的**

现在有一个问题，在上面代码中，那个ReplicaManager对象，实际上属于短暂存活的这么一个对象

大家可以观察一下，在loadReplicasFromDisk()方法中创建这个对象，然后执行ReplicaManager对象的load()方法，然后执行完毕之后，loadReplicasFromDisk()方法就会结束。

一旦方法结束，那么loadReplicasFromDisk()方法的栈帧就会出栈，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24039100_1562517500.cn/txdocpic/0/d4436bf7fba6fe0bae6ba1e7f81de053/0)

然后接着上篇文章已经说过，此时一旦没人引用这个ReplicaManager对象了，就会被JVM的垃圾回收线程给回收掉，释放内存空间，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40140000_1562517500.cn/txdocpic/0/5046e4459ba2213095b4699d6f6d38c2/0)

然后在main()方法的while循环里，下一次循环再次执行loadReplicasFromDisk()方法的时候，又会走一遍上面那个过程，把loadReplicasFromDisk()方法的栈帧压入Java虚拟机栈，然后构造一个ReplicaManager实例对象放在Java堆里。

一旦执行完ReplicaManager对象的load()方法之后，loadReplicasFromDisk()方法又会结束，再次出栈，然后垃圾回收释放掉Java堆内存里的ReplicaManager对象。

所以其实这个ReplicaManager对象，在上面的代码中，是一个存活周期极为短暂的对象

可能每次执行loadReplicasFromDisk()方法的时候，被创建出来，然后执行他的load()方法，接着可能1毫秒之后，就被垃圾回收掉了。

所以从这段代码就可以明显看出来，大部分在我们代码里创建的对象，其实都是存活周期很短的。这种对象，其实在我们写的Java代码中，占到绝大部分的比例。



**3、少数对象是长期存活的**

但是我们来看另外一段代码，假如说咱们用下面的这种方式来实现同样的功能：

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/66557000_1562517500.png)



上面那段代码的意思，就是给Kafka这个类定义一个静态变量，也就是“replicaManager”，这个Kafka类是在JVM的方法区里的

然后让“replicaManager”引用了一个在Java堆内存里创建的ReplicaManager实例对象，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/82266400_1562517500.cn/txdocpic/0/b54c781435cdcbb11230945ba6d41d32/0)

接着在main()方法中，就会在一个while循环里，不停的调用ReplicaManager对象的load()方法，做成一个周期性运行的模式。

这个时候，我们就要来思考一下，这个ReplicaManager实例对象，他是会一直被Kafka的静态变量引用的，然后会一直驻留在Java堆内存里，是不会被垃圾回收掉的。

因为这个实例对象他需要长期被使用，周期新的被调用load()方法，所以他就成为了一个长时间存在的对象。

那么类似这种被类的静态变量长期引用的对象，他需要长期停留在Java堆内存里，这这种对象就是生存周期很长的对象，他是轻易不会被垃圾回收的，他需要长期存在，不停的去使用他。



**4、JVM分代模型：年轻代和老年代**

接下来就要进入今天的核心主题了，就是JVM的分代模型，年轻代和老年代。

现在大家已经看到，其实根据你写代码方式的不同，采用不同的方式来创建和使用对象，其实对象的生存周期是不同的。

所以JVM将Java堆内存划分为了两个区域，一个是年轻代，一个是老年代。

其中年轻代，顾名思义，就是把第一种代码示例中的那种，创建和使用完之后立马就要回收的对象放在里面

然后老年代呢，就是把第二种代码示例中的那种，创建之后需要一直长期存在的对象放在里面，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/94531400_1562517500.cn/txdocpic/0/5b65435b96c37267ecbb717150fd21e1/0)

比如下面的代码，我们再次来改造一下，再结合图，大家会看的更加的明确一些。

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4526200_1562517501.png)



上面那段代码稍微复杂了点，我们解释一下

Kafka的静态变量“fetcher”引用了ReplicaFetcher对象，这是长期需要驻留在内存里使用的

这个对象会在年轻代里停留一会儿，但是最终会进入老年代，大家看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/18143000_1562517501.cn/txdocpic/0/2c949e48487721b4f6018daf6fb91cad/0)

进入main()方法之后，会先调用loadReplicasFromDisk()方法，业务含义是系统启动就从磁盘加载一次副本数据，这个方法的栈帧会入栈

然后在这个方法里面创建了一个ReplicaManager对象，这个对象他是用完就会回收，所以是会放在年轻代里的，由栈帧里的局部变量来引用

此时对应着下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/39173000_1562517501.cn/txdocpic/0/9cddbf1f5698d44fcec30cd48c5e7ca5/0)

然后一旦loadReplicasFromDisk()方法执行完毕了，方法的栈帧就会出栈，对应的年轻代里的ReplicaManager对象也会被回收掉，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53703400_1562517501.cn/txdocpic/0/7e4a0ec31f4e69e421c11d7ab874443a/0)

但是接着会执行一段while循环代码，他会周期性的调用ReplicaFetcher的fetch()方法，去从远程加载副本数据。

所以ReplicaFetcher这个对象因为被Kafka类的静态变量fetcher给引用了，所以他会长期存在于老年代里的，持续被使用。



**5、为什么要分成年轻代和老年代？**

相信看完这篇文章，大家就一定看明白了，什么样的对象是短期存活的对象，什么样的对象是长期存在的对象，然后如何分别存在于年轻代和老年代里。

那么为什么需要这么区分呢？

因为这跟垃圾回收有关，对于年轻代里的对象，他们的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法

对于老年代里的对象，他们的特点是需要长期存在，所以需要另外一种垃圾回收算法，所以需要分成两个区域来放不同的对象。

很多人又会问了，你不是说“ReplicaFetcher”这个长期存在的对象，刚开始也在年轻代，后来才会进入老年代么？那他到底什么时候进入老年代？

别急，明天的文章就会分析这块。

然后还有人还会问了，那么年轻代和老年代分别怎么进行垃圾回收呢？

别急，下周的文章会主要分析垃圾回收这块的原理。这周我们主要关注JVM的内存划分的细节，搞明白对象是如何在不同的内存区域里分配的就可以了，学习要循序渐进。



**6、什么是永久代？**

很简单，JVM里的永久代其实就是我们之前说的方法区

上面那个图里的方法区，其实就是所谓的永久代，你可以认为永久代就是放一些类信息的。

这个话题现在不用过多考虑，后续涉及到的时候，我们会讲到的。



**7、上周思考题解答**

上周留了一个思考题，让大家思考**方法区内会不会进行垃圾回收**

其实有同学都回答了，非常的好，在以下几种情况下，方法区里的类会被回收。

- 首先该类的所有实例对象都已经从Java堆内存里被回收
- 其次加载这个类的ClassLoader已经被回收
- 最后，对该类的Class对象没有任何引用

满足上面三个条件就可以回收该类了。



**8、今日思考题**

给大家出一个脑筋急转弯，出题思路有点偏：每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？

# 009、大厂面试题：你的对象在JVM内存中如何分配？如何流转的？

2019-06-23 21:20:27

**大厂面试题：**

**你的对象在JVM内存中如何分配？如何流转的？**



**目录：**

1. 前文回顾
2. 大部分正常对象都优先在新生代分配内存
3. 到底什么情况下会触发新生代的垃圾回收？
4. 长期存活的对象会躲过多次垃圾回收
5. 老年代会垃圾回收吗？
6. 关于新生代和老年代的对象分配，这就完了吗？
7. 昨日思考题解答
8. 今日思考题



**1、前文回顾**

经过昨天的文章铺垫了一些对象分配的基础知识后，想必大家现在都心里非常有数了，咱们平时代码里创建出来的对象，一般就是两种：

- 一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收
- 另外一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用

第一种短期存活的对象，是在Java堆内存的新生代里的。第二种长期存活的对象，是在Java堆内存的老年代里的。这个结论，想必大家都已经理解了

好，那么接下来我们就来聊聊，对象到底什么时候进入新生代？然后什么情况下会进入老年代？

**提示一下：**本文是建立在大家都绝对理解上文的基础上来写的，上文是结合代码示例来阐述的核心原理，包括对象什么情况下短期存活，什么情况下长期存活。

所以本文就直接通过大量图示来给大家分析对象在内存中的分配机制了，大家务必透彻理解上文。

**2、大部分正常对象都优先在新生代分配内存**

首先我们先来看上篇文章中的一段代码，稍微带着大家来理解一个概念：大部分的正常对象，都是优先在新生代分配内存的。

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76237100_1562572322.png)



大家还记得上面那段代码吗？虽然我们看代码知道，类静态变量“fetcher”引用的那个“ReplicaFetcher”对象，是会长期存活在内存里的

但是哪怕是这种对象，其实刚开始你通过“new ReplicaFetcher()”代码来实例化一个对象时，他也是分配在新生代里的。

包括在“loadReplicasFromDisk()”方法中创建的“ReplicaManager”实例对象，也都是一样分配在新生代里的

同样，我们以一张图，来展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10298400_1562572323.cn/txdocpic/0/0e833f156ae7201a3e89d7afb5cd6447/0)



**3、到底什么情况下会触发新生代的垃圾回收？**

现在咱们来假设一个场景，大家应该都知道，一旦“loadReplicasFromDisk()”方法执行完毕之后，这个方法的栈帧出栈，会导致没有任何局部变量引用那个“ReplicaManager”实例对象了。

此时可能会如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36887600_1562572323.cn/txdocpic/0/408a5832f0db1590fc21d80316d7999c/0)

那么此时就一定会立即发生垃圾回收，去回收掉Java堆内存里那个没人使用的“ReplicaManager”实例对象吗？

**NO！**大家别想的那么简单了，实际上垃圾回收他也得有点触发的条件。

其中一个比较常见的场景可能是这样的，假设我们写的代码中创建了N多对象，然后导致Java堆内存里囤积了大量的对象。

然后这些对象都是之前有人引用，比如各种各样的方法中的局部变量，但是现在也都没人引用了。

如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65138200_1562572323.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)

这个时候，如果新生代我们预先分配的内存空间，几乎都被全部对象给占满了！此时假设我们代码继续运行，他需要在新生代里去分配一个对象，怎么办？发现新生代里内存空间都不够了！

这个时候，就会触发一次新生代内存空间的垃圾回收，新生代内存空间的垃圾回收，也称之为“Minor GC”，有的时候我们也叫“Young GC”，他会尝试把新生代里那些没有人引用的垃圾对象，都给回收掉。

比如上图中，那个“ReplicaManager”实例对象，其实就是没有人引用的垃圾对象

此时就会当机立断，把“ReplicaManager”实例对象给回收掉，腾出更多的内存空间，然后放一个新的对象到新生代里去。

包括上图中那大量的实例对象，其实也都没人引用，在这个新生代垃圾回收的过程中，就会把这些垃圾对象也都回收掉。

其实话说回来，大家自己仔细回忆一下，我们在代码中创建的大部分对象，其实都是这种使用之后立马就可以回收掉的生存周期极短的对象，是不是？

可能我们会在新生代里分配大量的对象，但是使用完之后立马就没人引用了，此时新生代差不多满了

然后要分配新的对象的时候，发现新生代内存空间不足，就会触发一次垃圾回收，然后就把所有垃圾对象给干掉，腾出大量的内存空间

如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/97232300_1562572323.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)



**4、长期存活的对象会躲过多次垃圾回收**

接着我们来看下一个问题，上图中大家都注意到了“ReplicaFetcher”实例对象，他是一个长期被“Kafka”类的静态变量“fetcher”引用的长期存活的对象。

所以虽然你的新生代可能随着系统的运行，不停的创建对象，然后让新生代变满，接着垃圾回收一次，大量对象被回收掉

但是你的这个“ReplicaFetcher”对象，他确是一直会存活在新生代里的。

因为他一直被“Kafka”类的静态变量给引用了，所以他不会被回收。那么此时JVM就有一条规定了

如果一个实例对象在新生代中，成功的在15次垃圾回收之后，还是没被回收掉，就说明他已经15岁了。

这是对象的年龄，每垃圾回收一次，如果一个对象没被回收掉，他的年龄就会增加1。

所以如果上图中的那个“ReplicaFetcher”对象在新生代中成功躲过10多次垃圾回收，成为一个“老年人”，那么就会被认为是会长期存活在内存里的对象。

然后他会被转移到Java堆内存的老年代中去，顾名思义，老年代就是放这些年龄很大的对象。

我们再来看一张图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21115900_1562572324.cn/txdocpic/0/4d4ea63678b59270725c2bf57b7005df/0)



**5、老年代会垃圾回收吗？**

接着下一个问题就是，老年代里的那些对象会被垃圾回收吗？

答案是**肯定的**，因为老年代里的对象也有可能随着代码的运行，不再被任何人引用了，就需要被垃圾回收。

大家可以思考一下，如果随着类似上面的情况，越来越多的对象进入老年代，一旦老年代也满了，是不是就要对老年代垃圾回收了？

没错，这是肯定的，但是暂时我们先不用过多的去考虑这里的细节，因为这将是**下周的主题**，下周我们会进行深入剖析。



**6、关于新生代和老年代的对象分配，这就完了吗？**

还有人会说，关于新生代和老年代的对象分配，这就结束了吗？

当然不是，今天这篇文章，仅仅是相较于之前的文章，更进一步给大家分析了一下对象分配的一些机制。

但是其实在对象分配这块，还有很多其他的复杂机制，比如：

- 新生代垃圾回收之后，因为存活对象太多，导致大量对象直接进入老年代
- 特别大的超大对象直接不经过新生代就进入老年代
- 动态对象年龄判断机制
- 空间担保机制

可能一些JVM书籍会在这里一下把这些复杂的东西都写出来给大家，但是我们的专栏不会是这个思路。

还是那句话，我们的专栏写作思路是循序渐进，从浅入深，通俗易懂，一步一图。

很多底层技术细节，不要在前期铺垫太多，会导致很多同学吃了没法消化

**我会****结合后续大量案例，结合真实生产问题，把JVM各种底层细节带出来。****结合实战食用，效果更佳。**

因此第二周，大家对对象内存分配，了解到这个程度就行了，给大家总结一下：

- 先理解对象优先分配在新生代
- 新生代如果对象满了，会触发Minor GC回收掉没有人引用的垃圾对象
- 如果有对象躲过了十多次垃圾回收，就会放入老年代里
- 如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉

大家通过本文，先理解上面几点即可。



**7、昨日思考题解答**

昨天的思考题，是一个脑筋急转弯，说每个线程执行方法的时候，那些方法对应的栈帧出栈了，那么那里的局部变量需要垃圾回收吗？

其实这是一个偏题，JVM里垃圾回收针对的是新生代，老年代，还有方法区（永久代），不会针对方法的栈帧。

方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉了。



**8、今日思考题**

今天想给大家出一个预习类的思考题：理解了今天的对象内存分配，垃圾回收以及老年代转移的机制之后。

大家能否结合短生存周期的对象的特点，以及长生存周期的对象的特点，思考一下，看看你们手头正在负责的系统，梳理梳理里面短生存周期的对象都有什么，长生存周期的对象都有什么。

可以在评论区踊跃回复，让大家开始从JVM的角度去思考自己手头负责的系统中的代码是怎么运行的。

**End**

# 010、动手实验：亲自感受一下线上系统部署时如何设置JVM内存大小？

2019-06-25 02:04:57

**动手实验：****亲自感受一下线上系统部署时如何设置JVM内存大小？**



**目录：**

1. 前文回顾
2. 跟JVM内存相关的几个核心参数图解
3. 如何在启动系统的时候设置JVM参数？
4. 通过案例，学习参数优化设置的预告
5. 昨日思考题解析
6. 今日思考题



**1、前文回顾**

咱们先简单回顾一下目前为止已经学到的内容，现在大家肯定都知道，我们平时代码里创建的对象，都是优先在新生代分配的

然后随着一些方法执行完毕，大部分新生代里的对象就没有人引用了，就成了垃圾对象，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35634000_1562678028.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)

大家可以想象一下，随着代码持续运行，新生代里对象会越来越多，而且里面大部分的对象其实都是那种短生存周期的对象，很快就没有人引用他们了，因此大部分都会是一些垃圾对象。

然后代码继续运行，是不是肯定会创建新的对象分配在新生代里？

肯定是的，所以一旦新生代里内存不够了，就会触发一次Minor GC，把新生代里那些没有人引用的垃圾对象都给回收掉，腾出来内存空间。如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57499700_1562678028.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)

如果是那种在长周期存活的对象，他在新生代里会持续躲过多次垃圾回收，每躲过 一次垃圾回收，年龄会增长1岁

然后当他成为是十多岁的“老年人”的时候，就会被转移到老年代里去，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79177100_1562678028.cn/txdocpic/0/4d4ea63678b59270725c2bf57b7005df/0)

好，到此为止，我们撇开一些特殊情况，至少JVM中基本的内存分配原理，大家就搞清楚了

本周最核心的概念，就是让大家屡清楚短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor GC，然后长生存周期的对象如何转移到老年代里去。



**2、跟JVM内存相关的几个核心参数图解**

本文就不涉及到任何原理性的东西了，直接开始逐步给大家讲解JVM的参数如何设置。

在JVM内存分配中，有几个参数是比较核心的，如下所示。

1. **-Xms**：Java堆内存的大小
2. **-Xmx**：Java堆内存的最大大小
3. **-Xmn**：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了
4. **-XX:PermSize**：永久代大小
5. **-XX:MaxPermSize**：永久代最大大小
6. **-Xss**：每个线程的栈内存大小

下面我们对上述参数来进行一一说明。

-Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。

对于这对参数，通常来说，都会设置为完全一样的大小。大家先不用太过于纠结这里的细节，因为其实JVM里的各种技术细节真的太多了，不能一下子全部都搞定，要随着后续几十个案例，层层铺展开来。

但是至少大家需要清楚，这两个参数，是用来**限定Java堆内存的总大小的**，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98941200_1562678028.cn/txdocpic/0/2ec320beb57b6ab3989125446ff8e67f/0)

-Xmn，这个参数也是很常见的，他用来**设置Java堆内存中的新生代的大小**，然后扣除新生代大小之后的剩余内存就是给老年代的内存大小，我们看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/18186900_1562678029.cn/txdocpic/0/6427be1d6cdedecdb553d6e4600580bd/0)

-XX:PermSize和-XX:MaxPermSize，分别**限定了永久代大小和永久代的最大大小**

通常这两个数值也是设置为一样的，至于原因，请看后面结合案例的文章分析。

如果是JDK 1.8以后的版本，那么这俩参数被替换为了-XX:MetaspaceSize和-XX:MaxMetaspaceSize，但是大家至少得知道，这两个参数限定了永久代的大小，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35593600_1562678029.cn/txdocpic/0/58bb148a07b08be2c5dfe56ba1aa0dec/0)

-Xss，这个参数**限定了每个线程的栈内存大小**

大家都很清楚，每个线程都有一个自己的虚拟机栈，然后每次执行一个方法，就会将方法的栈帧压入线程的栈里，方法执行完毕，那么栈帧就会从线程的栈里出栈，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60034100_1562678029.cn/txdocpic/0/f9060eaaabc058f558a2432f924eb3d1/0)



**3、如何在启动系统的时候设置JVM参数？**

那么现在大家结合图示都知道了JVM内存各个区域的大小该使用什么参数来设置，那么到底怎么设置呢？

现在就带着大家来做一些实验

你要是在Eclipse/IntelliJ IDEA里开发代码的话，如果要在这种开发IDE里启动一个程序，然后设置JVM参数，那么就需要对按照下面的步骤来设置：

首先右击你写好的一个带main()方法的类，他有一个菜单栏，里面有一个“**Debug as**”选项，鼠标移动进入，会看到一个“**Debug Configuration**”选项，接着会看到下面的面板。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79304600_1562678029.cn/txdocpic/0/9121baa8cd692145b40650ae03e6711d/0)

这个面板里有一个“**Arguments**”的选项，点击他，会看到下面的图。然后在“VM arguments”中输入你的JVM参数即可

比如你可以按照下面的示例来设置，-Xms之类的参数直接后面跟上你要设置的内存大小，多少M即可。

但是-XX:PermSize这种格式的参数，需要跟一个“=”符号，跟上你要设置的内存大小即可。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/489400_1562678030.cn/txdocpic/0/0eba43af1b132a488e6087f941f8a5c9/0)

那么如果是在线上部署系统应该如何设置JVM参数呢？

其实都很简单，比如说采用“java -jar”的方式启动一个jar包里的系统，那么就可以采用类似下面的格式：

java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar

如果是现在非常流行的那种启动Spring Boot开发的系统呢？

其实都是类似的，大家自行翻阅一下Spring Boot的文档即可。



**4、通过案例，学习参数优化设置的预告**

明天开始，我们会做发布本专栏的第一个案例，就是百万交易的支付系统案例

通过分析一个支付系统的核心业务流程，然后结合我们学习到的JVM相关的知识，来一步步探究，JVM内存相关的这些核心参数，到底在我们上线一个生产系统的时候，针对预估的并发压力，到底应该如何合理的给出一个未经过调优的比较合理的初始值。

另外我们会分析各种参数在设置的时候有哪些考虑的点，Java堆内存到底需要多大？新生代和老年代的内存分别需要多大？永久代和虚拟机栈分别 需要多大？这些我们都结合案例来一步一步的分析。

其实JVM参数到底该如何设置，一定是根据不同的业务系统他具体的一些场景来调整的，不是说有一个通用的配置和模板，照着设就没问题了，那个思路肯定是不对的，也不能干巴巴的告诉你，这个参数应该这样设置，那个参数应该那样设置。

一切都要从案例出发，结合业务场景来分析。



**5、昨日思考题解析**

昨天让大家结合学到的知识，去分析一下自己手头负责的那些业务系统，哪些是短生存周期的对象，哪些是长生存周期的对象

其实就是让大家开始在脑子里建立起来自己负责的系统在JVM中运行时的一个概念图，要有这个意识，才能更好的进行JVM调优。



**6、今日思考题**

给大家留一个思考题，大家都知道平时我们一般部署Java系统，主要以Tomcat部署Web系统居多，现在还更多的是通过Spring Boot来部署系统。

那么大家可以自行去网上查阅一下，Tomcat、Spring Boot部署启动系统的时候，JVM参数如何设置？

然后大家再看看自己公司手头负责的系统，你们部署系统的时候是通过什么方式来设置JVM参数的？

**End**

# 011、案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？

2019-06-25 02:08:29

**案例实战**

**每日百万交易的支付系统，如何设置JVM堆内存大小？**

**目录：**

1. 前文回顾
2. 支付系统背景引入
3. 支付的核心业务流程
4. 每日百万交易的支付系统的压力在哪里？
5. 支付系统每秒钟需要处理多少笔支付订单？
6. 每个支付订单处理要耗时多久？
7. 每个支付订单大概需要多大的内存空间？
8. 每秒发起的支付请求对内存的占用
9. 让支付系统运行起来分析一下
10. 对完整的支付系统内存占用需要进行预估
11. 支付系统的JVM堆内存应该怎么设置？
12. 本文总结
13. 昨日思考题解答
14. 今日思考题



**1、前文回顾**

本文是我们专栏的第一个案例，我将用一个每日百万交易的支付系统作为背景，来给大家分析一下，咱们在上线部署一个系统时，应该如何根据系统的业务量来合理的设置JVM的堆内存大小。

通过之前的文章，大家其实都知道我们写好的代码在JVM中运行的基本原理了，而且也知道通过什么参数可以设置JVM各个内存区域的大小。

但单看之前的文章，大家在自己部署一个线上系统的时候，一定还是会两眼一蒙圈，发现自己压根儿就不知道怎么来设置自己线上系统的JVM内存大小

所以我们通过一个案例来分析一下，教会大家自己负责的线上系统，到底该如何合理设置JVM内存大小。



**2、支付系统背景引入**

先来看看，如果在一个电商系统里，一个支付系统大概应该是一个什么样的位置，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67322600_1562736432.cn/txdocpic/0/f26c652fbdc55848532695111e696e4c/0)

其实只要大家网购过，大概的流程都会非常的清晰，假设我们在一个APP或者一个网站里买东西，大体上都是对一些商品加到购物车里，然后下个订单，接着对订单进行支付，钱从我们的账户划拨到人家网站的账户里去，大致如此。

上面的图就很清晰的展示了这个过程，所谓的支付系统，是一个网站或者APP后台系统中非常核心的一个环节，负责管理公司的资金流

它负责对接用户的支付请求，然后根据用户的付款方式，跟第三方的支付渠道对接起来，比如微信、支付宝，等等。

比如用户通过微信付款88元，那么他的钱在微信钱包里，需要划拨88块到电商公司账户里去，那么此时支付系统就得跟微信支付渠道对接，资金从微信划拨过来，大概的流程就是这个意思。



**3、支付的核心业务流程**

接着我们来讲一下支付的核心业务流程，大家先看下面的图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/78695100_1562736432.cn/txdocpic/0/e3ba379609a9e4b766c3e2fd70ed3e22/0)

通过上图标号序号的步骤，大家可以很清晰的知道这个流程了

首先用户在我们的商城系统提交支付一个订单的请求，接着商城系统把这个请求提交给支付系统，支付系统就会生成一个支付订单，此时订单状态可能是“待支付”的状态。

然后支付系统指引用户跳转到付款页面，选择一个付款方式

然后用户发起实际支付请求，支付系统把实际支付请求转交给第三方支付渠道，比如微信或者支付宝，它们会去处理支付请求进行资金转移。

如果微信或者支付宝处理完支付之后，就会返回支付结果给支付系统，支付系统可以更新自己本地的支付订单的状态变成“已完成”。

当然，其实一个完整的支付系统还包含很多东西。

比如还要负责对账以及跟合作商户之间的资金清算，支付系统得包含应用管理、账户管理、渠道管理、支付交易、对账管理、清算管理、结算管理，等各种功能模块，但是我们这里就关注最核心的支付流程即可。



**4、每日百万交易的支付系统的压力在哪里？**

接着我们来考虑一下，一个每日百万交易的支付系统的压力到底集中在哪里呢？

比如上面的那个核心支付流程，我们的这套系统每日要发生百万次交易。

一般达到百万交易，要不然是国内最大的互联网公司，要不就是一个通用型第三方支付平台，对接各种APP的支付交易。

其实大家通过上图都能明显看到，上述业务流程中，最核心的环节，就是在用户发起支付请求的时候，会生成一个支付订单

这个支付订单需要记录清楚比如是谁发起支付？对哪个商品的支付？通过哪个渠道进行支付？还有发起支付的时间？等等，诸如此类的信息。

如果每日百万交易，那么大家可以想象一下，在我们的JVM的角度来看，就是每天会在JVM中创建上百万个支付订单对象

大家仔细想想，是不是这么回事？如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99498000_1562736432.cn/txdocpic/0/3e67008bf948e409f89ae877a92d6c72/0)

所以我们的支付系统，其实他的压力有很多方面，包括高并发访问、高性能处理请求、大量的支付订单数据需要存储，等等技术难点。

但是抛开这些系统架构层面的东西，单单是在JVM层面，我们的支付系统最大的压力，就是每天JVM内存里会频繁的创建和销毁100万个支付订单，所以这里就牵扯到一个核心的问题。

- 我们的支付系统需要部署多少台机器？
- 每台机器需要多大的内存空间？
- 每台机器上启动的JVM需要分配多大的堆内存空间？
- 给JVM多大的内存空间才能保证可以支撑这么多的支付订单在内存里的创建，而不会导致内存不够直接崩溃？

这就是我们本文要考虑的核心问题。



**5、支付系统每秒钟需要处理多少笔支付订单**

要解决线上系统最核心的一个参数，也就是JVM堆内存大小的合理设置，我们首先第一个要计算的，就是每秒钟我们的系统要处理多少笔支付订单。

假设每天100万个支付订单，那么一般用户交易行为都会发生在每天的高峰期，比如中午或者晚上。

假设每天高峰期大概是几个小时，用100万平均分配到几个小时里，那么大概是每秒100笔订单左右，咱们就以每秒100笔订单来计算一下好了。

假设我们的支付系统部署了3台机器，每台机器实际上每秒大概处理30笔订单。

大家看下面的图，这个图可以反映出来支付系统每秒钟的订单处理压力。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12768400_1562736433.cn/txdocpic/0/6c71e9e4dac98ce455cdb5097f1113d0/0)



**6、每个支付订单处理要耗时多久？**

下一个问题，咱们必须要搞明白的一个事儿，就是每个支付订单大概要处理多长时间？

如果用户发起一次支付请求，那么支付需要在JVM中创建一个支付订单对象，填充进去数据，然后把这个支付订单写入数据库，还可能会处理一些其他的事情

咱们就假设一次支付请求的处理，包含一个支付订单的创建，大概需要1秒钟的时间。

那么大体上你的脑子里可以出现的一个流动的模型，应该是每台机器一秒钟接收到30笔支付订单的请求，然后在JVM的新生代里创建了30个支付订单的对象，做了写入数据库等处理

接着1秒之后，这30个支付订单就处理完毕，然后对这些支付订单对象的引用就回收了，这些订单在JVM的新生代里就是没人引用的垃圾对象了。

接着再是下一秒来30个支付订单，重复这个步骤。



**7、每个支付订单大概需要多大的内存空间？**

接着我们来计算一下，每个支付订单对象大概需要多大的内存空间？

之前的文章里有一个思考题， 已经教过大家这个怎么计算了，其实不考虑别的，你就直接根据支付订单类中的实例变量的类型来计算就可以了。

比如说支付订单类如下所示，你只要记住一个Integer类型的变量数据是4个字节，Long类型的变量数据是8个字节，还有别的类型的变量数据占据多少字节

百度一下都可以查到，然后就可以计算出每个支付订单对象大致占据多少字节。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27154800_1562736433.png)



一般来说，比如支付订单这种核心类，你就按20个实例变量来计算，然后一般大概一个对象也就在几百字节的样子

我们算他大一点好了，就算一个支付订单对象占据500字节的内存空间，不到1kb。



**8、每秒发起的支付请求对内存的占用**

之前说过，假设有3台机器，每秒钟处理30笔支付订单的请求，那么在这1秒内，大家都知道，肯定是有方法里的局部变量在引用这些支付订单的，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/37594500_1562736433.cn/txdocpic/0/c255c9b1f5251dd733c73dd7122e739e/0)

那么30个支付订单，大概占据的内存空间是30 * 500字节 = 15000字节，大概其实也就**15kb**而已。其实是非常非常小的。



**9、让支付系统运行起来分析一下**

现在我们已经把整个系统运行的关键环节的数据都分析清楚了，大家可以大致脑子里思考一下，每秒30个支付请求，创建30个支付订单对象，也就占据kb级别的内存空间而已

然后接着1秒过后，这30个对象就没有人引用了，就成了新生代里的垃圾了。

下一秒请求过来，我们的系统持续的创建支付订单对象，不停在新生代里放入30个支付订单，然后新生代里的对象会持续的累积和增加。

直到有一刻，发现可能新生代里都有几十万个对象了，此时占据了几百MB的空间了，可能新生代空间就快满了。

然后就会触发Minor GC，就把新生代里的垃圾对象都给回收掉了，腾出内存空间，然后继续来在内存里分配新的对象。

这就是这个业务系统的运行模型。



**10、对完整的支付系统内存占用需要进行预估**

之前的分析，全部都是基于一个核心业务流程中的一个支付订单对象来分析的，其实那只是一小部分而已。

真实的支付系统线上运行，肯定每秒会创建大量其他的对象，但是我们结合这个访问压力以及核心对象的内存占据，大致可以来估算一下整个支付系统每秒钟大致会占据多少内存空间。

其实如果你要估算的话，可以把之前的计算结果扩大10倍~20倍。也就是说，每秒钟除了在内存里创建支付订单对象，还会创建其他数十种对象。

那么每秒钟创建出来的被栈内存的局部变量引用的对象大致占据的内存空间就在**几百KB~1MB**之间。

然后下一秒继续来新的请求创建大概1MB的对象放在新生代里，接着变成垃圾，再来下一秒。

循环多次之后，新生代里垃圾太多，就会触发Minor GC回收掉这些垃圾。这就是一个完整系统的大致JVM层面的内存使用模型。



**11、支付系统的JVM堆内存应该怎么设置？**

其实结合支付系统的核心业务流程分析清楚了之后，大家就完全知道这么一个线上系统，每个机器上部署上线的时候，JVM的堆内存应该如何设置了。

其实一般来说这种线上业务系统，常见的机器配置是2核4G，或者是4核8G。

如果我们用2核4G的机器来部署，那么还是有点紧凑的，因为机器有4G内存，但是机器本身也要用一些内存空间，最后你的JVM进程最多就是2G内存

然后这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存可能最多就是个1G多的内存空间。

然后堆内存还分为新生代和老年代，你的老年代总需要放置系统的一些长期存活的对象吧，怎么也得给几百MB的内存空间，那么新生代可能也就几百MB的内存了。

这样的话，大家可以看到，我们上述的核心业务流程，只不过仅仅是针对一个支付订单对象来分析的，但是实际上如果扩大10倍~20倍换成对完整系统的预估之后，我们看到，大致每秒会占据1MB左右的内存空间。

那么如果你新生代就几百MB的内存空间，是不是会导致运行几百秒之后，新生代内存空间就满了？此时是不是就得触发Minor GC了？

其实如果这么频繁的触发Minor GC，会影响线上系统的性能稳定性，具体原因后续再说。

这里大家首先要明白的一点，就是频繁触发GC一定不是什么好事儿。

因此你可以考虑采用4核8G的机器来部署支付系统，那么你的JVM进程至少可以给4G以上内存，新生代在里面至少可以分配到2G内存空间

这样子就可以做到可能新生代每秒多1MB左右的内存，但是需要将近半小时到1小时才会让新生代触发Minor GC，这就大大降低了GC的频率。

举个例子：机器采用4核8G，然后-Xms和-Xmx设置为3G，给整个堆内存3G内存空间，-Xmn设置为2G，给新生代2G内存空间。

而且假设你的业务量如果更大，你可以考虑不只部署3台机器，可以横向扩展部署5台机器，或者10台机器，这样每台机器处理的请求更少，对JVM的压力更小。



**12、本文总结**

本文从一个支付系统案例出发，带着大家一点点计算了这个系统在日百万交易的压力下，部署3台机器的场景下，每秒钟每台机器需要处理多少笔订单，每笔订单要耗时多久处理，每秒钟会对JVM占据多大内存空间，根据这个横向扩展预估整个系统每秒需要占据多大内存空间。

接着根据上述数据模型推算出，在不同的机器配置之下，你的新生代大致会有多大的内存空间，然后在不同的新生代大小之下，多久会触发一次Minor GC

为了避免频繁的GC，那么应该选用什么样的机器配置，部署多少台机器，给JVM堆内存多大的内存空间，新生代多大的内存空间。

根据这套配置，就可以推算出来整个系统的运行模型了，每秒钟创建多少对象在新生代，然后1秒之后成为垃圾，大概系统运行多久，新生代会触发一次GC，频率有多高 。



**13、昨日思考题解答**

昨天让大家思考Spring Boot和Tomcat部署系统怎么设置JVM参数

很多同学都找到了，Spring Boot其实就是启动的时候可以加上JVM参数，Tomcat就是在bin目录下的catalina.sh中可以加入JVM参数

这个题目不难，主要是让大家建立起来一个意识，就是你得关注你部署的系统的JVM参数是怎么来设置的。



**14、今日思考题**

今天开始案例分析环节了，那思考题很简单，大家当然是应该去思考一下自己平时开发的系统：

- 你会去按照本文类似的思路估算系统压力吗？
- 你会去估算系统的JVM内存压力吗？
- 然后会去有针对性的合理设置JVM参数吗？
- 你们之前是这么做的吗？为什么？



上述几个问题，就是今天的思考题。



**End**

# 012、案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？

2019-06-25 02:09:28

**案例实战**

**每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？**

**目录：**

1. 前文回顾
2. 基于案例，说说不合理设置内存的反面示例
3. 大促期间，瞬时访问量增加十倍
4. 少数请求需要几十秒处理，导致老年代内存占用变大
5. 老年代对象越来越多导致频繁垃圾回收
6. 反面案例总结
7. 如何合理设置永久代大小？
8. 如何合理设置栈内存大小
9. 昨日思考题分析
10. 今日思考题



**1、前文回顾**

昨天的文章给大家基于案例分析了一下，如果我们准备上线一个新的系统，如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。

然后基于这个推算出来的JVM内存运转模型，再接着去在系统上线前就选择一个合理的机器配置，要多大内存的机器，另外给JVM堆内存空间一个合理的大小。

其实这是一项非常基础的技能，因为对于大厂工程师，每次上线一个新的系统，他可能上线就会面临很大的访问压力

所以必须要学会合理预估内存压力，然后选择对应的机器配置，并且给出合理的内存大小，希望大家好好掌握。



**2、基于案例，说说不合理设置内存的反面示例**

昨天说的是一个正面的例子，即如何合理的设置内存大小。

今天来说一个反面的不合理设置内存大小导致的问题，也是我们之前线上生产系统真实经历过的一次故障，但是当时不是发生在支付系统中的，是另外一个系统。

不过为了便于大家理解，咱们还是以支付系统作为案例来说明好了，其实思路是一样的。

比如现在我们假设一个前提，就是支付系统因为没有经过合理的内存预估，所以直接选用了1台2核4G的虚拟机来部署了线上系统，而且就只用了一台机器

然后线上JVM给的堆内存大小，仅仅就只有1G，扣除老年代之后，新生代其实就几百MB的内存空间，大家看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42547400_1562852415.cn/txdocpic/0/9b908d3e08623c968b3a82c462515cde/0)

好了，接着我们还是用昨天的那个业务压力，就是每天100万交易，高峰期每秒大概100笔支付交易，对应核心的支付订单对象有100个创建出来，每个支付订单对象占据500左右的字节大小，总共就是50kb左右。

然后一笔交易要1秒来处理，所以这100个对象在新生代中存在1秒的期间会被人引用，是无法被回收的。

而且我们之前说过一个全局预估的思路，从核心的支付订单对象扩展开来，拓展到系统里其他的对象中去，起码可以把内存占用扩大了10倍~20倍

比如我们就扩大个20倍好了，那么说明1秒之内，总共会创建出来大概1MB左右的对象，无法被回收。



**3、大促期间，瞬时访问量增加十倍**

其实按照估算出来的内存压力，你这么小的新生代在系统正常运行的情况下，其实还不算什么大问题

因为每秒新增1MB对象，然后几百秒过后，新生代快满了，自然就会触发Minor GC，回收掉里面99%的垃圾对象。

你要是内存那么小，最多就是发现系统每隔几分钟略微卡顿一下，因为这个时候在进行垃圾回收，会影响系统性能

至于为什么影响系统性能，下周垃圾回收的主题里会分析的。

但是现在我们假设，如果你的电商系统搞大促活动呢？

一般搞大促活动，很可能导致你的压力瞬间增大10倍，因为平时不来你网站的人，今天都来了。

此时可能会发现，每秒钟你的支付系统不是100笔订单了，可能是每秒钟上千笔订单。

这个时候你的系统压力本身就会很大了，不光是内存，尤其是线程资源、CPU资源，都会几乎打满。内存就更是岌岌可危了。



**4、少数请求需要几十秒处理，导致老年代内存占用变大**

咱们就针对内存来分析一下。

现在假设你每秒1000笔交易，那么每秒钟系统对内存的占用增加到10MB以上

我们甚至可以再大胆一点，预估每秒对内存占用达到几十MB，甚至上百MB也可以，因为毕竟大促时流量激增，就一切围绕这来预估。

而且最可怕的一点是，可能你每秒过来的1000笔交易，不再是1秒就可以处理完毕了，因为压力骤增，会导致你的系统性能下降，可能偶尔会出现每个请求处理完毕需要几秒钟，甚至几十秒的时间。

此时我们看下图可能出现什么问题，假设你的新生代里已经积压了很多的数据，都快满了。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54780800_1562852415.cn/txdocpic/0/1bfc18ec1bd17e114db748520933275e/0)

然后呢，此时内存里有比如几十MB的对象都被人引用着，因为少数请求突然处理的特别慢。

为什么会处理特别慢？因为压力太大，导致系统性能太差了，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/64397500_1562852415.cn/txdocpic/0/fe7ea3d9d0fce90a861bf68622234578/0)

这个时候，如果你要再次在新生代里分配对象，那么是不是会导致一次Minor GC去回收新生代？

没错，但是可能回收掉大量的对象之后，那少数几十MB的对象还在，因为少数请求特别的慢。

然后很快新生代继续被填满，再次触发Minor GC，然后少数几十MB的对象还在，此时多次之后后，就会被转移到老年代去，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73571200_1562852415.cn/txdocpic/0/db72be3ab71ce6795ec339ccea8bf7d2/0)



**5、老年代对象越来越多导致频繁垃圾回收**

那么大家思考一下，上述流程如果反复来多次，就是时不时有少数请求特别慢，创建的对象在新生代反复多次没法被回收，然后就会被弄到老年代去

然后后续处理完之后，老年代里的对象就没人引用了，成为了垃圾对象。

经常重复这个流程，老年代里的垃圾对象，是不是就会越来越多？

一旦老年代的垃圾对象越来越多，迟早会满，然后就会触发老年代的垃圾回收，而且这个老年代被占满的频率还很快，可能就会频繁触发老年代的垃圾回收。

大家要知道，老年代的垃圾回收速度是很慢的，这个为什么慢，下周会给大家讲

但是在上述场景下，我们基本可以分析出来，如果你不合理的设置内存，就会导致新生代内存不充足，然后导致很多对象不停的迁移到老年代去，最后导致老年代也要不停的进行垃圾回收。

最后这频繁的垃圾回收，就会极大的影响系统的性能。



**6、反面案例总结**

本文就通过一个支付系统内存设置过小，然后突发巨大的流量压力，突发的性能抖动，最后导致很多对象长期在新生代被人引用，无法被回收，最后持续进入老年代，最后触发老年代内存都频繁占满，然后老年代都频繁被垃圾回收。

这是我们之前另外一个线上系统真实发生的场景，只不过用支付系统作为案例给大家解释了一遍，所以大家更能从反面体会到，不合理的预估 业务系统压力，不合理的设置内存大小，就可能会导致很大的问题。



**7、如何合理设置永久代大小？**

话说回来，如何合理设置永久代大小呢？

其实一般永久代刚开始上线一个系统，没太多可以参考的规范，但是一般你设置个几百MB，大体上都是够用的

因为里面主要就是存放一些类的信息，后面也会用专门的案例给大家分析，什么样的系统容易出现永久代内存溢出。



**8、如何合理设置栈内存大小**

其实这个栈内存大小设置，一般也不会特别的去预估和设置的，一般默认就是比如512KB到1MB，就差不多够了。

这就是每个线程自己的栈内存空间，用来存放线程执行方法期间的各种布局变量的。后面也会用专门的案例演示，栈内存什么时候会发生内存溢出。



**9、昨日思考题分析**

昨天让大家去思考自己平时负责的系统，有没有按照这个思路去预估业务系统压力，然后给一个合理的内存设置

其实就是希望大家以后建立起来一个全面的工程素养，每个合格的工程师，都应该在上线系统的时候，对系统压力做出预估，然后对JVM内存、磁盘空间大小、网络带宽、数据库压力做出预估，然后各方面都给出合理的配置。



**10、今日思考题**

看完今天的文章，我想给大家一个思考题，假设大家手头负责的系统业务量暴增100倍，甚至1000倍，按照我们文章的思路，自己去分析一下，有没有可能出现JVM上的问题？

要是业务真的增长这么多，你应该怎么调整机器配置和JVM内存大小？

# 013、第2周作业：看看你们的线上系统是如何设置JVM内存大小的？

2019-06-25 02:10:10

第2周作业：

看看你们的线上系统是如何设置JVM内存大小的？



本周咱们已经把JVM的工作原理进一步的加深了理解，现在相信大家都知道咱们写好的系统平时运行的时候，都是优先把对象放新生代里，然后新生代满了就垃圾回收

如果有的长期存活的对象，躲过十多次垃圾回收，就进入老年代。

而且我们还结合案例分析了，一个新的系统上线之前，应该怎么去根据系统的线上负载，预估内存使用的压力，然后结合内存使用压力选择合理的机器配置以及JVM堆内存大小。

同时还给了一个反例，如果不合理设置内存，会导致什么样的问题。

**那么本周的作业是什么呢？**

非常简单，希望每个人按照案例里分析的那个过程，把你手头负责的系统的核心业务流程简化、抽象以及梳理出来，看看你们线上的真实负载情况，每秒钟多少请求？

然后根据你们的核心业务流程，看看每秒钟你负责的系统对内存使用的压力有多大？

假如你发现自己负责的系统很Low，没什么压力，那你可以尝试思考一下，如果你系统负载扩大100倍呢？此时对你内存使用压力有多大？

接着你再思考一下，就你的系统内存使用压力之下，目前你们线上机器是多大的堆内存？新生代多大？老年代多大？

如果没设置，可以自行百度默认的内存大小。然后分析一下，目前的这个内存配置，你们的垃圾回收有多频繁？

希望大家对自己手头的系统，严格的去分析一下，这个流程做下来，相信你对JVM的理解，对你负责的系统的理解，对线上系统的内存分配，都会提升一个理解的层次。

# 014、第2周答疑：本周问题答疑，上周作业点评

2019-06-25 02:11:02

**第2周问题答疑**



**问题一：**

既然栈帧存放了方法对应的局部变量的数据也包括了方法执行的其它相关信息，那为什么不把程序计算器那块记录执行的情况，也放在各个方法自己的栈帧里，而是要单独列一个程序计数区去存储呢？请教，谢谢



**答：**

这就是JVM设计者的设计思想了，因为程序计数器针对的是代码指令的执行，Java虚拟栈针对的是放方法的数据，一个是指令，一个是数据，分开设计



**问题二**

对于第二点问题，我理解是在初始化的阶段执行该段代码的，对么？那在执行的时候也是按照jvm执行代码的这套流程来执行的么？ || 老师 1.静态变量是放在什么内存区域呢? 2.然后静态代码块也是会生成一个栈帧然后压栈到当前虚拟机栈中吗,是不是只压栈一次?



**答：**

是在类初始化的时候来执行，但是不是JVM执行代码的流程来执行，他是类初始化，自成一套体系



**问题三**

回答问题：首先该类的所有实例（堆中）都已经被回收；其次该类的ClassLoader已经被回收；最后，对该类对应的Class对象没有任何引用。满足上面三个条件就可以回收该类了。



**答：**

正解



**问题四**

怎么判断离代码的远近？如果是一个mavne聚合工程，两个子工程都定义了这个类，这个时候会加载哪一个？按照classpath的声明顺序吗，先声明先加载？ || 我在使用mybatis时发现有个类不满足要求，于是在项目中新建同包同名类，复制源码然后加上我自己的逻辑，这个时候就会加载我自己写的那个类，而不是mybatis中的类，这是为什么呢？



**答：**

没错，他有一个顺序，你自己的那个代码是最近的，他会优先加载你代码里的那个类



**问题五**

文章很详细，但是对于新手而言还是很抽象。我在学这块的时候都是画了很多内存开辟的流程图。希望老师抽空写一些简单的代码，把内存开辟和初始化，赋值的步骤一步一步画出来。



**答：**

思路很好，同学，但是你是已经有一定了解的，都提到了内存开辟和赋值流程了，其实对新手而言，了解到文章目前的程度就可以了，不能一口气太深，要慢慢来，刚开始浅显易懂一些，接下来逐步深入。



**问题六**

感觉也可以按照回收堆内存对象的思路来思考。方法区的class可以回收，只需要满足任何地方都没有用到该class，即：没有任何实例，没有调用class的静态变量或静态方法，没有利用反射访问class。暂时想到的只有这些，不知道对不对



**答：**

推测基本正确



**问题七**

方法执行完后, 栈帧立马被出栈, 那该栈帧中的变量等数据是立马就被回收掉吗?还是需要等垃圾回收线程扫描到再回收掉?



**答：**

出栈就没了



**问题八**

那如果把public static int flushInterval = Configuration.getInt("xxx");中的static去掉, 那后面的getInt是在什么时候执行的呢 ,我自己测试了一下,好像是在构造方法之前执行的, 不明白这个到底属于什么阶段?



**答：**

这是属于类的对象实例初始化的阶段



**问题九**

双亲委派模型设计的出发点很重要，文章漏了 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

也就是说，，判断2个类是否“相等”，只有在这2个类是由同一个类加载器加载的前提下才有意义，否则即使这2个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这2个类必定不相等。

 基于双亲委派模型设计，那么Java中基础的类，Object类似Object类重复多次的问题就不会存在了，因为经过层层传递，加载请求最终都会被Bootstrap ClassLoader所响应。加载的Object类也会只有一个，否则如果用户自己编写了一个java.lang.Object类，并把它放到了ClassPath中，会出现很多个Object类，这样Java类型体系中最最基础的行为都无法保证，应用程序也将一片混乱



**答：**

这位同学非常不错，对jvm有一定的研究，不过我们第一周的文章，并不是说漏掉你说的这些点，而是我们的写作思路，是循序渐进，这点很重要。

如果在刚开始就给出大段这种说明，那么只有少数人会看懂，回到普通的那种学院派纯理论的知识传递方法了。你说的很好，不过希望耐心跟着继续看，我们会有意把很多细节放在后面讲，循序渐进，保证很多小白同学都轻松学习，这点很重要。



**问题十**

tomcat需要破坏双亲委派模型的原因：

 (1)tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；

 (2)同一个第三方类库的相同版本在不同web应用可以共享

 (3)tomcat自身依赖的类库需要与应用依赖的类库隔离 (3)jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器



**答：**

解答很详细，我们给的一些思考题，其实第二天只会给一些思路，鼓励大家自己查阅资料去思考，给出答案，给一些指引



**问题十一**

老师您好，我想问一下，我们的应用如果关掉，创建在堆中的对象，还有方法区的数据都还在吗



**答：**

应用关了，那么系统对应的JVM进程就没了，那JVM内存区域的数据就全没了



**问题十二**

请问老师：

1、“实例对象都已经从Java堆内存里被回收”和“Class对象没有任何引用”是一个概念么？

2、 “ClassLoader已经被回收”，什么时候会回收？



**答：**

1、不是，Class对象代表类，如果你有变量引用了类的Class对象，那么就是有引用 2、比如你自定义的ClassLoader，本身就是个对象，一旦他没人再使用了，就会被垃圾回收



**问题十三**

引用Class对象的是该类的实例对象？还是其他什么？



**答：**

比如用反射，可以获取一个对象的类的Class对象实例，比如Class clazz = replicaManager.getClass()，就可以通过replicaManager引用的对象，获取到ReplicaManager类的Class对象，那个clazz变量，就可以引用这个Class对象



**问题十四**

栈帧里的数据出栈就没有了，怎么理解？不是垃圾回收线程来回收，那是main线程执行完这个方法就直接将其栈帧里面的数据销毁了吗？



**答：**

没错



**问题十五**

第二周打卡，跟上节奏。今日思考题：项目中托管给Spring管理的对象，带@Configration的配置对象，都是长期存在老年代。自己定义那些pojo对象，如果不被定义为类对象就是朝生夕灭的，所以分配在年轻代里面。



**答：**

非常好，同学



**问题十六**

大多数情况下，方法中的对象都是短生存周期的对象，而实例对象和类对象都是长生存周期的对象。 

猜测一下：spring容器中管理的sington的bean是相对长生存周期的对象，而prototype是短生存周期对象



**答：**

可以多看看你手头负责的系统代码，去分析一下



**问题十八**

public void load(){ A a = new A(); a这个保存地址的变量是存在虚拟机栈的,这个方法执行完成后就销毁了, 那new A()这个对象是需要等待垃圾回收线程扫描后才回收吗?还是和a这个变量同时回收?



**答：**

对象要等待垃圾回收才销毁



**问题十九**

感觉每天篇幅内容太少了，每天都迫不及待期待下一节内容，有点像小时候追看连续剧的感觉



**答：**

要一步一步来，太快内容太多了，不利于消化总结，每周的文章，建议反复看2~3遍，自己配合作业，总结和梳理，学习+复习+作业，才能让你真正消化掉这个知识



**问题二十**

可以自己通过参数设置多大的对象直接放到老年代。 || 对于超大对象直接进入老年代这句话、老师可以给举个栗子吗



**答：**

是的



**问题二十一**

内存不够才会回收软引用对象，内存空间足够的话，不会回收软引用对象。弱引用不管内存空间够不够，只能撑到下次垃圾回收之前，就被会回收。 || gc回收的是软引用，弱应用和虚引用，关于软引用和弱引用傻傻分不清，这两者有何异同，请指教



**答：**

没错



**问题二十二**

大部分是spring容器的对象，spring默认单实例方式加载，这些对象可能会存在老年代中。但是方法内部new出来 对象不会存货太长时间，方法结束，引用消息，对象也会在下一次gc被回收。



**答：**

没错



**问题二十三**

类初始化时，变量引用的是new出来的对象，此时变量引用的对象会被实例化到堆内存吗？



**答：**

会实例化放到堆内存



**问题二十四**

老师好。我今天使用Java VisualVm看了一下，发现了一个问题，我配置的是-Xms4M -Xmx4M -Xmn2M。应该是年轻代2M 老年代2M。

写了一个while循环不断的在方法里创建临时变量对象，但是我发现当内存堆达到3m左右的时候，就发生了Minor GC，堆内存回到了2M，而不是4M的时候，理论上不应该是堆内存满了再Minor GC吗？

然后我老年代里的对象是一个静态的简单对象，这个对象会直接把2M占满嘛？因为每次堆内存都回到2M左右。是我理解的有问题吗？谢谢老师



**答：**

这个很正常的，因为后续第三周会讲新生代的内存结构，就是其实不是新生代全部占满才minor gc，是里面一块主要的内存区域满了，就minor gc



**问题二十五**

堆内存3G,给新生代2G,剩下老年代1G,一般是不是新生代设置得比老年代大？一般比例是多少？如果机器16G,还是这个支付环境，那么老年代还是1G，新生代7G好。还是老年代2G,新生代5G更好？



**答：**

明天会说这个老年代的事儿，别着急



**问题二十六**

打卡。做项目时候没有关注系统压力，主要是考虑功能怎么现实，然后按时交付测试。以后可以按老师今天这个思路去估算一下系统压力了。



**答：**

是的，如果没合理估算内存压力，没合理设置jvm内存大小，那么上线之后，可能会发现频繁gc问题，导致系统卡顿，这是jvm优化的第一步，合理估算业务压力，合理设置内存大小



**问题二十七**

总结: 

\1. 分析系统压力点在哪里？ 

\2. 压力点的每秒请求数？ 

\3. 每个请求耗时？ 

\4. 每个请求消耗的内存？ 

\5. 整个系统的所有请求重复1-4。 

\6. 算出部署多少台机器？每个机器多少内存？ 

思考题: 平时工作中很少这样预估系统压力，一般我的做法都是部署上去后分配一个堆内存，然后测试时再去监控GC的频率做适当调整。这样做确实很被动，很多时候上线后发现和测试的GC频率差太多，以后试试老师这种估算方法。 

这个案例分析的方法很好，虽然很浅，但也能学到东西。希望以后能多多发一些更加全面的案例分析。



**答：**

案例是一步一步来的，每个案例都针对不同的方面和问题，慢慢来，学完几十个案例，你对jvm的内部原理，参数优化，故障解决，就有全面的掌握了



**问题二十八**

上次发生内存溢出，我们搞到凌晨5点多，最后我们老大调大了堆内存解决的，说是由于使用过多的静态内部类，有地方引用到无法释放导致的，不过我现在还没有明白为啥??



**答：**

以后慢慢学习，你也能掌握这种能力



**问题二十九**

这篇文字最重要的收获是分析处理问题的思路，分解然后一步一步分析处理。赞。



**答：**

是的，思路非常的重要，按照这个思路来，你们自己也能做jvm内存压力预估，系统上线前，合理设置一个内存大小



**问题三十**

是不是不应该在高峰期的时候让系统进行垃圾回收，这样会造成STW。老师你们线上系统会考虑在低峰期手动触发垃圾回收么?



**答：**

建议不要手动触发，依托合理的内存设置以及参数优化，让系统自行运转



**问题三十一**

是不是应该通过老师说的估算方式，尽量设大新生代 ，让系统在高峰期不产生gc？



**答：**

是的，尽量是这样



**问题三十二**

老师，那不管三七二十一，在内存大的条件下，多分配给新生代就好了，如果不行就加内存??



**答：**

那你就浪费机器资源，要合理评估，不需要大内存，就用小内存就可以了



**问题三十三**

1、支付系统高分期需要处理的请求是是不是应该这么算：100万 / （24 * 3600） ≈ 12，根据28法则，大部分请求发生在中午12点到13点以及晚上的18点到19点，所以 80万请求 / （2 * 3600） ≈ 111，即算出如果单台每秒大概是100多个请求

 2、还有就是在完整的支付系统内存占用需要进行预估中，你提到“可以把之前的计算结果扩大10倍~20倍。也就是说每秒除了内存里创建的支付订单对象还创建数十种对象” 这里如果要计算的话 之前的计算结果是 30 * 500字节 * 20倍 = 300000字节=300KB 是这么算吗?



**答：**

没错的，这是大致估算的方法



**问题三十四**

老师 您这儿的案例中提到，一个支付请求需要1s中，30个请求也是1s钟，那是不是可以理解为开了30个线程同时并发处理支付请求入库？



**答：**

没错，就是这个意思



**问题三十五**

付订单对象，还创建其他数十种对象。那么计算的方式是不是：30 * 500字节/个 * 放大20倍≈300000字节≈300KB ？ || 

1、支付系统高分期需要处理的请求是是不是应该这么算：100万 / （24 * 3600） ≈ 12，根据28法则，大部分请求发生在中午12点到13点以及晚上的18点到19点，所以 80万请求 / （2 * 3600） ≈ 111，即算出如果单台每秒大概是100多个请求

2、还有就是在完整的支付系统内存占用需要进行预估中，你提到“可以把之前的计算结果扩大10倍~20倍。也就是说每秒除了内存里创建的支付订单对象还创建数十种对象” 这里如果要计算的话 之前的计算结果是 30 * 500字节 * 20倍 = 300000字节=300KB 是这么算吗?



**答**

是的，你学会大致估算系统内存压力的办法了



**问题三十六**

“可能你每秒过来的1000笔交易，不再是1秒就可以处理完毕了，因为压力骤增，会导致你的系统性能下降，可能偶尔会出现每个请求处理完毕需要几秒钟”:老师，这里说的压力骤增是磁盘读写压力吗还是内存CPU压力，出行每个请求处理完毕需要几秒这里是写入压力吗?与网络有关吗?谢谢



**答**

都有可能，主要是CPU负载过高，会导致高并发下每个请求的处理性能直线下降，还有网络问题也会有



**问题三十七**

我们订单一天二百多万，线上正常每秒产生也应该在1M以上，xmn2048，xmx8192,本来半个多小时一次minor gc,扩大一百倍，不到一分钟一次，应该会出现案例中的问题，老年代会频繁gc,不过我们有6g老年代，达到full gc应该时间会稍微长点



**答**

对的，自己分析的非常好，掌握这个方法了



**问题三十八**

我现在的业务遇到的瓶颈是带宽，压测的时候，请求量暴增百倍，上下行带宽瞬间被打满，导致部分业务直接不能用了。。直到慢慢恢复过来



**答**

是的，内存、网络带宽、磁盘IO、数据库，都是系统的瓶颈



**问题三十九**

老师, 可以说下, 为什么并发上来了, 压力就会剧增嘛? 哪些方面的压力.



**答**

并发上来之后，内存、网络带宽、磁盘IO、数据库，都是系统的瓶颈，比如网络带宽打满，你的请求就会排队卡住，磁盘IO变满，数据库性能下降，都会导致请求处理慢几十倍



**问题四十**

您好，我有一个问题，就是main函数中创建了对象，这个对象在堆中开启空间，那么如果这个对象中有成员变量，这个成员变量是存在哪里？成员变量的引用存在哪里



**答**

成员变量也是在堆内存里的



**问题四十一**

看了老师的专栏我觉得讲的非常清晰易懂，学到很多。但是，我这也有一个建议。学习的过程离不开实践，我在想老师能不能提供一个让我们能够模拟出一些问题的方式，然后通过设置jvm的内存分布来解决这个问题，这样会不会更好一些？



**答**

放心，现在你们还学的不够深入，后续大量的案例环节，会给很多示范代码，模拟故障，让你们动手去操作的



**问题四十二**

老师我上网查了一下资料，把问题弄明白了。Test.class是被加载了，但是并没有 执行初始化步骤。 

课程中提到了类加载的时机，但是没有提到类初始化的时机，我把一直理解类的 加载->验证->准备->解析->初始化是一个连续的动作，以为类一旦加载必定 会立即初始化。

补充类初始化的时机如下：

 1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

 2.当调用某个类的静态方法时

 3.当使用某个类或接口的静态字段时

 4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

 5.当初始化某个子类时

 6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)不满足上面6种情况，也就没有做初始化



**答**

对的，就是这样



**问题四十三**

老师 假如Kafka类里面 声明一个实例变量 private ReplicaFetcher = new ... 这个实例变量放在哪个区



**答**

实例变量就在堆内存里



**问题四十四**

很感谢这个平台，这次出去面了3家offer都拿到了，换作以前，是不可能的事情



**答**

加油，坚持学习，每天学习



**问题四十五**

老师 根据示例代码， 我做了以下jvm参数配置：-Xms10m -Xmx10m， 然后在visualVM里跟踪堆栈使用情况。 十分诧异的现象是： 在while true循环中，也就是执行fetchFromRemote的时候， 新生代大小一直在有规律的增长，然后不停的minor GC， 每次GC(而不是等到15次以后)，老年代都会相应的增长一点。 



我的问题是，使新生代增长的到底是什么对象？GC时又是什么对象跑到老年代里去了？ 按我的理解，fetcher对象应该有且只有一份实例，而且while循环中，不会生成新的对象， 最初，新生代里有一份fetcher，然后第16次minor GC的时候，fetcher被转移到老年代， 无论如何，新生代和老年代都不会不断增长。 所以，是不是有什么我不知道的对象混了进去，导致新生代不断增长？



**答**

新生代到老年代转移的机制不只是年龄一种，还有别的，下周会详细说的



**问题四十六**

老师，多谢回复，每个订单处理时间是1秒和10秒，10秒的就要比1秒的要多加内存吗？请问是怎样的逻辑？能否量化？



**答**

那你得计算一下，你的内存每秒被使用的速度，根据这个来规划内存大小，还有你要是10秒一个请求，可能内存里累计起来会有大量对象没法释放，会导致瞬间新生代被打满，而且大量对象没法回收，然后全部去老年代，然后老年代也很快就满了，最后内存不够，很快就内存溢出了



**问题四十七**

生活所迫，比较功利，我这套课程如果能达到老师的预期，我出去找工作要多少合适，我现在20K左右



**答**

跳槽不是一套课程就能搞定的，毕竟这就是一个88的专栏，能帮你搞定面试中的一个技术点而已，如果你要跳槽找好工作，需要系统训练，后续我们会出更多的课程的

# 015、大厂面试题：什么情况下JVM内存中的一个对象会被垃圾回收？

2019-06-25 02:12:45

**大厂面试题**

**什么情况下JVM内存中的一个对象会被垃圾回收？**



**目录：**

1. 什么时候会触发垃圾回收？
2. 被哪些变量引用的对象是不能回收的？
3. Java中对象不同的引用类型
4. finalize()方法的作用
5. 昨日思考题
6. 今日思考题





**1、什么时候会触发垃圾回收？**

通过之前的学习，相信大家都知道一点，平时我们系统运行创建的对象都是优先分配在新生代里的，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76744700_1563092345.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)



然后如果新生代里的对象越来越多，都快满了，此时就会触发垃圾回收，把新生代没有人引用的对象给回收掉，释放内存空间



大家务必注意，这就是新生代一个核心的垃圾回收触发时机，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87752100_1563092345.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)



那么本文就来针对这个过程，再次梳理其中的一些细节，看看触发垃圾回收的时候，到底是按照一个什么样的规则来回收垃圾对象的。



**2、被哪些变量引用的对象是不能回收的？**



首先第一个问题，一旦新生代快满了，那么垃圾回收的时候，到底哪些对象是能回收的，哪些对象是不能回收的呢？



这个问题非常好解释，JVM中使用了一种可达性分析算法来判定哪些对象是可以被回收的，哪些对象是不可以被回收的。



这个算法的意思，就是说对每个对象，都分析一下有谁在引用他，然后一层一层往上去判断，看是否有一个GC Roots。



**这句话相当的抽象，是不是？**



没关系，我们的特点就是一步一图，保证你看明白。



比如最常见的，就是下面的一种情况。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99069400_1563092345.png)



上面的代码其实就是在一个方法中创建了一个对象，然后有一个局部变量引用了这个对象，这种情况是最常见的



此时如下图所示。“main()”方法的栈帧入栈，然后调用“loadReplicasFromDisk()”方法，栈帧入栈，接着让局部变量“replicaManager”引用堆内存里的“ReplicaManager”实例对象。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10438200_1563092346.cn/txdocpic/0/8d169c754c01f0340e3b1d9f40654709/0)

假设现在上图中“ReplicaManager”对象被局部变量给引用了，那么此时一旦新生代快满了，发生垃圾回收，会去分析这个“ReplicaManager”对象的可达性



这时，发现他是不能被回收的，因为他被人引用了，而且是被局部变量“replicaManager”引用的。



在JVM规范中，局部变量就是可以作为GC Roots的



只要一个对象被局部变量引用了，那么就说明他有一个GC Roots，此时就不能被回收了。



另外比较常见的一个情况，其实就是类似下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/25075300_1563092346.png)



大家可以分析一下上面的代码，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36422500_1563092346.cn/txdocpic/0/b54c781435cdcbb11230945ba6d41d32/0)



大家按照上图思考一下，此时垃圾回收的时候一分析，发现这个“ReplicaManager”对象被Kafka类的一个静态变量“replicaManager”给引用了



此时在JVM的规范里，静态变量也可以看做是一种GC Roots，此时只要一个对象被GC Roots引用了，就不会去回收他。



所以说**，一句话总结**：只要你的对象被方法的局部变量、类的静态变量给引用了，就不会回收他们。



**3、Java中对象不同的引用类型**



关于引用和垃圾回收的关系，大家在这里务必有脑子里要引入一个新的概念，那就是Java里有不同的引用类型。



分别是强引用、软引用、弱引用和虚引用。下面分别用代码来示范一下。



强引用，就是类似下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/50919900_1563092346.png)



这个就是最普通的代码，一个变量引用一个对象，只要是强引用的类型，那么垃圾回收的时候绝对不会去回收这个对象的。



接着是软引用，类似下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/61128900_1563092346.png)



就是把“ReplicaManager”实例对象用一个“SoftReference”软引用类型的对象给包裹起来了，此时这个“replicaManager”变量对“ReplicaManager”对象的引用就是软引用了。



正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了



此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。



接着是弱引用，类似下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68680800_1563092345.png)



这个其实非常好解释，你这个弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉。



虚引用，这个大家其实暂时忽略他也行，因为很少用。



其实这里比较常用的，就是**强引用和软引用**，强引用就是代表绝对不能回收的对象，软引用就是说有的对象可有可无，如果内存实在不够了，可以回收他。



**4、finalize()方法的作用**



现在大家理解完了GC Roots和引用类型的概念，基本都知道了，哪些对象可以回收，哪些对象不能回收。



有GC Roots引用的对象不能回收，没有GC Roots引用的对象可以回收，如果有GC Roots引用，但是如果是软引用或者弱引用的，也有可能被回收掉。



接着就是到回收的环节了，假设没有GC Roots引用的对象，是一定立马被回收吗？



其实不是的，这里有一个finalize()方法可以拯救他自己，看下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74343700_1563092346.png)



假设有一个ReplicaManager对象要被垃圾回收了，那么假如这个对象重写了Object类中的finialize()方法



此时会先尝试调用一下他的finalize()方法，看是否把自己这个实例对象给了某个GC Roots变量，比如说代码中就给了ReplicaManager类的静态变量。



如果重新让某个GC Roots变量引用了自己，那么就不用被垃圾回收了。



不过说实话，这个东西没必要过多解读，因为其实平时很少用，就是给大家梳理出来这些细节，让大家清楚而已。



**5、昨日思考题**

上周的思考题和作业是一个意思，就是让大家去思考，自己负责的系统的内存压力，然后就是JVM内存大小是否合理，如果业务暴增100倍，是否会有内存问题。



作业更加详细的提示大家，自己画出核心业务流程图，然后一点点去分析，这是一个非常重要的技能。



其实JVM实战技能里的第一步，就是合理预估系统内存压力，合理设置JVM内存大小。



**6、今日思考题**

思考下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85146400_1563092346.png)

上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？

# 016、大厂面试题：JVM中有哪些垃圾回收算法，每个算法各自的优劣？

2019-06-25 16:37:23

**大厂面试题**

**JVM中有哪些垃圾回收算法，每个算法各自的优劣？**

**目录：**



1、前文回顾

2、复制算法的背景引入

3、一种不太好的垃圾回收思路

4、一个合理的垃圾回收思路

5、复制算法有什么缺点？

6、复制算法的优化：Eden区和Survivor区

7、新生代垃圾回收的各种“万一”怎么处理？

8、昨日思考题解答

9、今日思考题





**1、前文回顾**

上一篇文章我们重新梳理了一下什么时候触发垃圾回收，以及到底哪些对象可以垃圾回收



另外，对新生代填满，GC Roots对象，软引用、弱引用，还有finalize()等概念进行了比较细致的梳理。



那么这篇文章，我们就来看看在对新生代进行垃圾回收的时候，到底是采取一种什么样的算法进行的呢？



**2、复制算法的背景引入**

针对新生代的垃圾回收算法，他叫做复制算法



简单来说，就是如下图所示，首先把新生代的内存分为两块。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75985600_1563166809.cn/txdocpic/0/4dff58baa4fec1b8eb70de41dac17677/0)



接着假设有如下代码，在“loadReplicasFromDisk()”方法中创建了对象，此时对象就就会分配在新生代其中一块内存空间里



而且是由“main线程”的栈内存中的“loadReplicasFromDisk()”方法的栈帧内的局部变量来引用的，如下图所示。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/86348000_1563166809.png)



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96402400_1563166809.cn/txdocpic/0/992fa0baa62cd2989d818aa71cbf0490/0)



接着大家想象一下，假设与此同时，代码在不停的运行，然后大量的对象都分配在了新生代内存的其中一块内存区域里，也只会分配在那块区域里



而且分配过后，很快就失去了局部变量或者类静态变量的引用，成为了垃圾对象



此时如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12270400_1563166810.cn/txdocpic/0/01a079e093b0a75c0eb2b34cc8a340a7/0)



接着这个时候，新生代内存那块被分配对象的内存区域基本都快满了，再次要分配对象的时候，发现里面内存空间不足了。



那么此时就会触发Minor GC去回收掉新生代那块被使用的内存空间的垃圾对象。



那么回收的时候是怎么做的呢？



**3、一种不太好的垃圾回收思路**

假设现在采用的垃圾回收思路，就是直接对上图中被使用的那块内存区域中的垃圾对象进行标记



也就是根据上篇文章讲的那套思路，标记出哪些对象是可以被垃圾回收的，然后就直接对那块内存区域中的对象进行垃圾回收，把内存空出来。



大家想想，这种思路好吗？



这种思路去垃圾回收，可能会在回收完毕之后造成那块内存区域看起来跟下图一样。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26158700_1563166810.cn/txdocpic/0/ce2d7ea98a6c3e8d005955144310c9fe/0)

看上面的图，不知道大家发现什么没有，在那块被使用的内存区域里，回收掉了大量的垃圾对象，但是保留了一些被人引用的存活对象



但是呢，存活对象在内存区域里东一个西一个，非常的凌乱，而且造成了大量的内存碎片。



那么什么是内存碎片呢？



我们再看下面的图我用红线标记出来的区域，那些就是所谓的内存碎片。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38851600_1563166810.cn/txdocpic/0/f7da86e7f0652ee8f0ced04f96bf8a93/0)

看到了吗？在各种凌乱的存活对象的中间，出现了大量的红圈圈出来的内存碎片



这些内存碎片的大小不一样，有的可能很大，有的可能很小。



那么内存碎片太多会造成什么问题呢？



**内存浪费**



啥意思？比如现在打算分配一个新的对象，尝试在上图那块被使用的内存区域里去分配



此时如下图所示，可能因为内存碎片太多的缘故，虽然所有的内存碎片加起来其实有很大的一块内存，但是因为这些内存都是碎片式分散的，所以导致没有一块完整的足够的内存空间来分配新的对象。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51626000_1563166810.cn/txdocpic/0/ae0520de7c821da6ae5023cb0c3c78bb/0)



所以这种直接对一块内存空间回收掉垃圾对象，保留存活对象的方法，绝对是不可取的



因为内存碎片太多，就是他最大的问题，会造成大量的内存浪费，很多内存碎片压根儿是没法使用的。



**4、一个合理的垃圾回收思路**

那么能不能用一种合理的思路来进行垃圾回收呢？



**可以！**这个时候上图中一直没派上用场的另外一块空白的内存区域就出场了。



首先，并不是按照上述思路直接对已经使用的那块内存把垃圾对象全部回收掉，然后保留全部存活对象。



而是先对那块在使用的内存空间标记出里面哪些对象是不能进行垃圾回收的，就是要存活的对象



然后先把那些存活的对象转移到另外一块空白的内存中，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/64122200_1563166810.cn/txdocpic/0/710691fc7149c52eccbeb8bddb9b747c/0)



不知道大家发现这里的玄机没有？



没错，通过把存活对象先转移到另外一块空白内存区域，我们可以把这些对象都比较紧凑的排列在内存里



这样就可以让被转移的那块内存区域几乎没有什么内存碎片，对象都是按顺序排列在这块内存里的。



然后那块被转移的内存区域，是不是多出来一大块连续的可用的内存空间？



此时就可以将新对象分配在那块连续内存空间里了，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83624700_1563166810.cn/txdocpic/0/c79070baf8f1519a0396dfceaff1f267/0)

这个时候，再一次性把原来使用的那块内存区域中的垃圾对象全部一扫而空，全部给回收掉，空出来一块内存区域，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95077100_1563166810.cn/txdocpic/0/b0c24ccd1a57a69e66b76af9a0227eff/0)



这就是所谓的“**复制算法**“，把新生代内存划分为两块内存区域，然后只使用其中一块内存



待那块内存快满的时候，就把里面的存活对象一次性转移到另外一块内存区域，保证没有内存碎片



接着一次性回收原来那块内存区域的垃圾对象，再次空出来一块内存区域。**两块内存区域就这么重复着循环使用。**



**5、复制算法有什么缺点？**

复制算法的缺点其实非常的明显，如果按照上述的思路，大家会发现，假设我们给新生代1G的内存空间，那么只有512MB的内存空间是可以用的



另外512MB的内存空间是一直要放在那里空着的，然后512MB内存空间满了，就把存活对象转移到另外一块512MB的内存空间去



从始至终，就只有一半的内存可以用，这样的算法显然对内存的使用效率太低了。



**6、复制算法的优化：Eden区和Survivor区**

之前我给大家分析过，系统运行时，对JVM内存的使用模型，大体上就是我们的代码不停的创建对象然后分配在新生代里，但是一般很快那个对象就没人引用了，成了垃圾对象。



接着一段时间过后，新生代就满了，此时就会回收掉那些垃圾对象，空出来内存空间，给后续其他的对象来使用。



但是我们之前分析过，其实绝大多数的对象都是存活周期非常短的对象，可能被创建出来1毫秒之后就没人引用了，他就是垃圾对象了。



所以大家可以想象一下，可能一次新生代垃圾回收过后，99%的对象其实都被垃圾回收了，就1%的对象存活了下来，可能就是一些长期存活的对象，或者还没使用完的对象。



所以实际上真正的复制算法会做出如下优化，把新生代内存区域划分为三块：



**1个Eden区，2个Survivor区**，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间，比如说Eden区有800MB内存，每一块Survivor区就100MB内存，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5523900_1563166811.cn/txdocpic/0/c47a4494b5fbdb7431efada0256b42cb/0)



平时可以使用的，就是Eden区和其中一块Survivor区，那么相当于就是有900MB的内存是可以使用的，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29303400_1563166811.cn/txdocpic/0/3448969fb7b050a97dce23f81aaaf4cd/0)



然后如果Eden和一块Survivor都快满了，就会触发垃圾回收



此时就会把Eden区和一块Survivor中的存活对象都一次性转移到另外一块空着的Survivor区。



所以这里大家就能体会到，为啥是这么分配内存空间了。



因为之前分析了，每次垃圾回收可能存活下来的对象就1%，所以在设计的时候就留了一块100MB的内存空间来存放垃圾回收后转移过来的存活对象



比如Eden区+一块Survivor区有900MB的内存空间都占满了，但是垃圾回收之后，可能就10MB的对象是存活的。



此时就把那10MB的存活对象转移到另外一块Survivor区域就可以，然后再一次性把Eden区和之前使用的Survivor区里的垃圾对象全部回收掉，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40603400_1563166811.cn/txdocpic/0/ce048ddd962037a4c3dceae5d0c94b47/0)

接着新对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空着的，就这样一直循环使用这三块内存区域。



这么做**最大的好处**，就是只有10%的内存空间是被闲置的，90%的内存都被使用上了



无论是垃圾回收的性能，内存碎片的控制，还是说内存使用的效率，都非常的好。



**7、新生代垃圾回收的各种“万一”怎么处理？**

这个时候很多人看完了本文之后，一定对这里有可能发生的各种“万一”情况有疑惑了



比如：

- 万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？









- 万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？
- 到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？



别着急，明天就会来分析这些新生代的各种“万一”情况，以及新生代的对象是如何转移到老年代的，然后老年代是如何触发垃圾回收的，垃圾回收的算法又是什么样的。



看完这两篇文章，大家就会对新生代和老年代的对象分配、垃圾回收、对象转移等各种原理，都非常的熟悉了。



**8、昨日思考题解答**

思考下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51144500_1563166811.png)



上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？



明显是不会的，因为ReplicaFetcher对象被ReplicaManager对象中的实例变量引用了，然后ReplicaManager对象被Kafka类的静态变量给引用了



所以垃圾回收的时候，是不会回收掉ReplciaFetcher对象的，否则让存活下来的ReplicaManager对象情何以堪？



**9、今日思考题**

各位还记得之前教给过大家的那个系统对内存使用压力的估算方法么？



可以借助那个方法估算一下，每秒钟系统会使用多少内存空间，然后多长时间会触发一次垃圾回收？



垃圾回收之后，你们系统内大体会有多少对象存活下来？为什么？



然后都有哪些对象会存活下来？存活下来的对象会占多少内存空间？



随着不停的跟着专栏学习，希望大家多结合自己负责的系统来思考，你会养成一个核心能力，能够从JVM的角度去考虑系统运行时的模型



这样在真正发生JVM内存问题的时候，就能有一个非常深入的思考能力去解决问题。

# 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？

2019-06-25 16:38:17

**大厂面试题**

**年轻代和老年代分别适合什么样的垃圾回收算法？**

**目录：**

1. 前文回顾
2. 躲过15次GC之后进入老年代
3. 动态对象年龄判断
4. 大对象直接进入老年代
5. Minor GC后的对象太多，无法放入Survivor区怎么办？
6. 老年代空间分配担保规则
7. 老年代垃圾回收算法
8. 昨日思考题解答
9. 今日思考题





**1、前文回顾**

上篇文章已经给大家讲清楚了新生代的垃圾回收算法，包括跟这个垃圾回收算法搭配的新生代内存区域的划分，大家也都清楚了为什么有一块Eden区域和两块Survivor区域



那么本文就要给大家说说，新生代里的对象一般在什么场景下会进入老年代。



首先我们来看下面的图，我们写好的代码在运行的过程中，就会不断的创建各种各样的对象，这些对象都会优先放到新生代的Eden区和Survivor1区。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24600000_1563288057.cn/txdocpic/0/d9b92f69714c9367d0b164e34a97253b/0)



接着假如新生代的Eden区和Survivor1区都快满了，此时就会触发Minor GC，把存活对象转移到Survivor2区去



如下图所示

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33669500_1563288057.cn/txdocpic/0/01ff42fcc0c2639fa44f5535f5589a56/0)



然后接着就会使用Eden区和Survivor2区，来分配新的对象，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45264400_1563288057.cn/txdocpic/0/d68d168777dc43f832c2dd7ec0dd8995/0)



这个过程上篇文章已经讲的非常的清楚了。那么这篇文章我们就来依次看看各种情况下，对象是如何进入老年代的，以及老年代的垃圾回收算法是什么样的？



**2、躲过15次GC之后进入老年代**



按照上面的图示的那个过程，其实大家可以理解为我们写的系统刚启动的时候，创建的各种各样的对象，都是分配在新生代里的。



然后慢慢系统跑着跑着，新生代就满了，此时就会触发Minor GC，可能就1%的少量存活对象转移到空着的Survivor区中。



然后系统继续运行，继续在Eden区里分配各种对象，大概就是这个过程。



那么之前给大家讲过，我们写的系统中有些对象是长期存在的对象，他是不会轻易的被回收掉的，比如下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56111400_1563288057.png)



只要这个“Kafka”类还存在，那么他的静态变量“replicaManager”就会长期引用“ReplicaManager”对象，所以你无论新生代怎么垃圾回收，类似这种对象都不会被回收掉的。



此时这类对象每次在新生代里躲过一次GC被转移到一块Survivor区域中，此时他的年龄就会增长一岁



默认的设置下，当对象的年龄达到15岁的时候，也就是躲过15次GC的时候，他就会转移到老年代里去。



这个具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67467800_1563288057.cn/txdocpic/0/c6296e51361a1930ec2b6e874213b1e8/0)



**3、动态对象年龄判断**



这里跟这个对象年龄有另外一个规则可以让对象进入老年代，不用等待15次GC过后才可以。



他的大致规则就是，假如说当前放对象的Survivor区域里，相同年龄的一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。



说着有点抽象，具体还是看图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83936800_1563288057.cn/txdocpic/0/8ca1934d51237ac2f84a0359ad1b11e3/0)

假设这个图里的Survivor2区有两个对象，这俩对象的年龄一样，都是2岁



然后俩对象加起来对象超过了50MB，超过了Survivor2区的100MB内存大小的一半了，这个时候，Survivor2区里的大于等于2岁的对象，就要全部进入老年代里去。



这就是所谓的动态年龄判断的规则，这条规则也会让一些新生代的对象进入老年代。



其实说白了，无论是15岁的那个规则，还是动态年龄判断的规则，都是希望那些可能是长期存活的对象，尽早进入老年代



既然你是长期存活的，那么老年代才是属于你的地盘，别赖在新生代里占地方了。





**4、大对象直接进入老年代**



有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。



他的意思就是，如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年代里去。压根儿不会经过新生代。



之所以这么做，就是要避免新生代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入老年代，



那么大的一个对象在内存里来回复制，不是很耗费时间吗？



所以说，这也是一个对象进入老年代的规则。





**5、Minor GC后的对象太多无法放入Survivor区怎么办？**



现在有一个比较大的问题，就是如果在Minor GC之后发现剩余的存活对象太多了，没办法放入另外一块Survivor区怎么办？如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/93224100_1563288057.cn/txdocpic/0/ac4375fb7b1c4adce02b6dcef9b06ba1/0)



比如上面这个图，假设在发生GC的时候，发现Eden区里超过150MB的存活对象，此时没办法放入Survivor区中，此时该怎么办呢？



这个时候就必须得把这些对象直接转移到老年代去，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/2653900_1563288058.cn/txdocpic/0/d1ccf4ed6a79d1de5d38916eb7e5aaea/0)





**6、老年代空间分配担保规则**



这个时候大家又想提一个问题了，如果新生代里有大量对象存活下来，确实是自己的Survivor区放不下了，必须转移到老年代去



那么如果老年代里空间也不够放这些对象呢？这该咋整呢？



别急，一步一图，跟着下面的图来看。



首先，在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。



为啥检查这个呢？因为最极端的情况下，可能新生代Minor GC过后，所有对象都存活下来了，那岂不是新生代所有对象全部要进入老年代？如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11464100_1563288058.cn/txdocpic/0/3269e14f77837ff692fbffda42ab4e76/0)



如果说发现老年代的内存大小是大于新生代所有对象的，此时就可以放心大胆的对新生代发起一次Minor GC了，因为即使Minor GC之后所有对象都存活，Survivor区放不下了，也可以转移到老年代去。



但是假如执行Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了



那么这个时候是不是有可能在Minor GC之后新生代的对象全部存活下来，然后全部需要转移到老年代去，但是老年代空间又不够？



理论上，是有这种可能的。



所以假如Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:-HandlePromotionFailure”的参数是否设置了



如果有这个参数，那么就会继续尝试进行下一步判断。



下一步判断，就是看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。



举个例子，之前每次Minor GC后，平均都有10MB左右的对象会进入老年代，那么此时老年代可用内存大于10MB。



这就说明，很可能这次Minor GC过后也是差不多10MB左右的对象会进入老年代，此时老年代空间是够的，看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21312700_1563288058.cn/txdocpic/0/44fe84f8b3d6913c4f85a181dba0396f/0)



如果上面那个步骤判断失败了，或者是“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“Full GC”，就是对老年代进行垃圾回收，尽量腾出来一些内存空间，然后再执行Minor GC。



如果上面两个步骤都判断成功了，那么就是说可以冒点风险尝试一下Minor GC。此时进行Minor GC有几种可能。



第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor区域即可。



第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小的，此时就直接进入老年代即可。



第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触发一次“Full GC”。



Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。



因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代里面。



如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了



因为内存实在是不够了，你还是要不停的往里面放对象，当然就崩溃了。



这段规则有点烧脑，但是我觉得如果大家仔细对这段文字多看两遍，然后结合我们的图，脑子里想一想，基本都能看懂这个规则。





**7、老年代垃圾回收算法**



其实把上面的内容都看懂之后，大家现在基本就知道了Minor GC的触发时机，然后就是Minor GC之前要对老年代空间大小做的检查



包括检查失败的时候要提前触发Full GC给老年代腾一些空间出来，或者是Minor GC过后剩余对象太多放入老年代内存都不够，也要触发Full GC。包括这套规则，还有触发老年代垃圾回收的Full GC时机，都给大家讲清楚了。



简单来说，一句话总结，对老年代触发垃圾回收的时机，一般就是两个：



要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；



要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。



那么对老年代进行垃圾回收采用的是什么算法呢？



简单来说，老年代采取的是**标记整理算法**，这个过程说起来比较简单



大家看下图，首先标记出来老年代当前存活的对象，这些对象可能是东一个西一个的。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/31260500_1563288058.cn/txdocpic/0/1db631782af595970dd54ce31f156bf5/0)



接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片



然后再一次性把垃圾对象都回收掉，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41766300_1563288058.cn/txdocpic/0/1398e6a418987cb83e383a31bcf9ae68/0)



大家一定要注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。



如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。



所以后面用各种案例给大家展现出来的，就是在各种业务系统的生产故障下，怎么去一步一步分析到底为什么频繁的Full GC，然后怎么来调整JVM的各种参数进行优化。



其实大家如果透彻理解了最近的几篇文章涵盖的JVM的运行原理，就会知道，所谓JVM优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。



关于如何优化JVM，后续会有大量的案例带着大家去实战，而且会给出模拟生产的代码，让大家运行起来看到模拟出来的案发现场是如何导致JVM频繁GC的，对性能是如何影响的，然后再一步一步来优化JVM参数解决性能问题。





**8、昨日思考题**



各位同学还记得之前教给过大家的那个系统对内存使用压力的估算方法么？可以借助那个方法估算一下，每秒钟系统会使用多少内存空间，然后多长时间会触发一次垃圾回收，垃圾回收之后，你们系统内大体会有多少对象存活下来？为什么？都有哪些对象会存活下来？存活下来的对象会占多少内存空间？



昨天留了这个思考题，希望大家跟着文章的思路去好好分析自己手头写的代码，从JVM角度去理解你的代码是如何运行的。



**9、今日思考题**

今天的思考题算是一个小作业，今天的文章稍微有点难，有点烧脑，但是我觉得顺着文章思路和大量的图示，每个人是可以看懂的。



只不过消化起来需要点时间，希望大家今天能够花点时间，梳理出来GC的全流程。



- 到底什么时候会尝试触发Minor GC？
- 触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？
- 什么时候在Minor GC之前就会提前触发一次Full GC？
- Full GC的算法是什么？
- Minor GC过后可能对应哪几种情况？
- 哪些情况下Minor GC后的对象会进入老年代？



希望大家自己通过画图的形式，把这个过程完整的梳理出来，**对这个过程的透彻理解，会成为我们后续进行JVM优化实战的核心基石。**

# 018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？

2019-06-25 16:42:30

**大厂面试题**

**JVM中都有哪些常见的垃圾回收器，各自的特点是什么？**





**1、前文回顾**



上一篇文章我们给大家分析了一下到底什么时候会触发Minor GC，什么时候会让对象从新生代转移到老年代，包括为了新生代转移到老年代的内存足够安全，Minor GC之前要如何检查老年代的内存空间，在什么情况下会触发老年代的Full GC，老年代的垃圾回收算法是什么，这些问题都已经给大家分析清楚了。



这篇文章，我们先接着上篇文章，给大家来一个真实的我们之前一个生产系统的老年代频繁Full GC的案例，让大家更加透彻的理解整个对象分配以及转移到老年代，以及Minor GC和Full GC的全过程。





**2、一个日处理上亿数据的计算系统**



先给大家说一下这个系统的案例背景，大概来说是当时我们团队里自己研发的一个数据计算系统，日处理数据量在上亿的规模。



为了方便大家集中注意力理解这个系统的生产环境的JVM相关的东西，所以对系统本身就简化说明了。



简单来说，这个系统就是会不停的从MySQL数据库以及其他数据源里提取大量的数据，加载到自己的JVM内存里来进行计算处理，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41194200_1563362991.cn/txdocpic/0/a2a44346a04ac9e835c45bc763f5fbe2/0)



这个数据计算系统会不停的通过SQL语句和其他方式从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。



但是这是一套分布式运行的系统，所以生产环境部署了多台机器，每台机器大概每分钟负责执行100次数据提取和计算的任务。



每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间



然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60965600_1563362991.cn/txdocpic/0/0f1c80d13cc35c5a59e006c125ab6471/0)



**3、这个系统到底多块会塞满新生代？**



现在明确了一些核心数据，接着我们来看看这个系统到底多快会塞满新生代的内存空间？



既然这个系统每台机器上部署的实例，每分钟会执行100次数据计算任务，每次是1万条数据需要计算10秒的时间，那么我们来看看每次1万条数据大概会占用多大的内存空间？



这里每条数据都是比较大的，大概每条数据包含了平均20个字段，可以认为平均每条数据在1KB左右的大小。那么每次计算任务的1万条数据就对应了10MB的大小。



所以大家此时可以思考一下，如果新生代是按照8:1:1的比例来分配Eden和两块Survivor的区域，那么大体上来说，Eden区就是1.2GB，每块Survivor区域在100MB左右，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80778800_1563362991.cn/txdocpic/0/27013616e76c608d90f90c4aa8839ad0/0)



基本上按照这个内存大小而言，大家会发现，每次执行一个计算任务，就会在Eden区里分配10MB左右的对象，那么一分钟大概对应100次计算任务



其实基本上一分钟过后，Eden区里就全是对象，基本就全满了。



所以说，回答这个小节的问题，新生代里的Eden区，基本上1分钟左右就迅速填满了。



**4、触发Minor GC的时候会有多少对象进入老年代？**



此时假设新生代的Eden区在1分钟过后都塞满对象了，然后在接着继续执行计算任务的时候，势必会导致需要进行Minor GC回收一部分的垃圾对象。



那么上篇文章给大家讲过这里在执行Minor GC之前会先进行的检查。



首先第一步，先看看老年代的可用内存空间是否大于新生代全部对象？



看下图，此时老年代是空的，大概有1.5G的可用内存空间，新生代的Eden区大概算他有1.2G的对象好了。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21041100_1563362992.cn/txdocpic/0/0c9b3fef4480068f6596d7e497b69f43/0)



此时会发现老年代的可用内存空间有1.5GB，新生代的对象总共有1.2GB，即使一次Minor GC过后，全部对象都存活，老年代也能放的下的，那么此时就会直接执行Minor GC了。



那么此时Eden区里有多少对象还是存活的，无法被垃圾回收呢？



大家可以考虑一下之前说的那个点，每个计算任务1万条数据需要计算10秒钟，假设此时80个计算任务都执行结束了，但是还有20个计算任务共计200MB的数据还在计算中，此时就是200MB的对象是存活的，不能被垃圾回收掉，然后有1GB的对象是可以垃圾回收的



大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41986600_1563362992.cn/txdocpic/0/2c9dd6de204132c1782abb9befc0108f/0)



此时一次Minor GC就会回收掉1GB的对象，然后200MB的对象能放入Survivor区吗？



**不能！**因为任何一块Survivor区实际上就100MB的空间，此时就会通过空间担保机制，让这200MB对象直接进入老年代去，占用里面200MB内存空间，然后Eden区就清空了



大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/55667700_1563362992.cn/txdocpic/0/595cc6ef34ae543070f7c2a199041ada/0)



**5、系统运行多久，老年代大概就会填满？**



那么大家想一下，这个系统大概运行多久，老年代会填满呢？



按照上述计算，每分钟都是一个轮回，大概算下来是每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，然后大概都会有200MB左右的数据进入老年代。



那么大家可以想一下，假设现在2分钟运行过去了，此时老年代已经有400MB内存被占用了，只有1.1GB的内存可用，此时如果第3分钟运行完毕，又要进行Minor GC，会做什么检查呢？如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76842100_1563362992.cn/txdocpic/0/5b5b675f627b6e4079b5a25c51fd7489/0)



此时会先检查老年代可用空间是否大于新生代全部对象？



此时老年代可用空间1.1GB，新生代对象有1.2GB，那么此时假设一次Minor GC过后新生代对象全部存活，老年代是放不下的，那么此时就得看看一个参数是否打开了 。



如果“-XX:-HandlePromotionFailure”参数被打开了，当然一般都会打开，此时会进入第二步检查，就是看看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。



我们已经计算过了，大概每分钟会执行一次Minor GC，每次大概200MB对象会进入老年代。



那么此时发现老年代的1.1GB空间，是大于每次Minor GC后平均200MB对象进入老年代的大小的



所以基本可以推测，本次Minor GC后大概率还是有200MB对象进入老年代，1.1G可用空间是足够的。



所以此时就会放心执行一次Minor GC，然后又是200MB对象进入老年代。



转折点大概在运行了7分钟过后，7次Minor GC执行过后，大概1.4G对象进入老年代，老年代剩余空间就不到100MB了，几乎快满了



如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99420900_1563362992.cn/txdocpic/0/4858e3f283323859740672320cd34233/0)





**6、这个系统运行多久，老年代会触发1次Full GC？**



大概在第8分钟运行结束的时候，新生代又满了，执行Minor GC之前进行检查，此时发现老年代只有100MB内存空间了，比之前每次Minor GC后进入老年代的200MB对象要小，此时就会直接触发一次Full GC。



Full GC会把老年代的垃圾对象都给回收了，假设此时老年代被占据的1.4G空间里，全部都是可以回收的对象，那么此时一次性就会把这些对象都给回收了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/22846400_1563362993.cn/txdocpic/0/dfa1aa67d11adc2344b6eaf6b8f0afe5/0)



然后接着就会执行Minor GC，此时Eden区情况，200MB对象再次进入老年代，之前的Full GC就是为这些新生代本次Minor GC要进入老年代的对象准备的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45332900_1563362993.cn/txdocpic/0/ff8e4614f20b8854780172685c53ea1c/0)



按照这个运行模型，基本上平均就是七八分钟一次Full GC，这个频率就相当高了。因为每次Full GC速度都是很慢的，性能很差，而且明天的文章会告诉大家，为什么Full GC的时候会严重影响系统性能。





**7、该案例应该如何进行JVM优化？**



相信通过这个案例，大家结合图一路看下来，对新生代和老年代如何配合使用，然后什么情况下触发Minor GC和Full GC，什么情况下会导致频繁的Minor GC和Full GC，大家都有了更加深层次和透彻的理解了。



对这个系统，其实要优化也是很简单的，因为这个系统是数据计算系统，每次Minor GC的时候，必然会有一批数据没计算完毕



但是按照现有的内存模型，最大的问题，其实就是每次Survivor区域放不下存活对象。



所以当时我们就是对生产系统进行了调整，增加了新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代



这样Survivor区大概就是200MB，每次刚好能放得下Minor GC过后存活的对象了，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56883800_1563362993.cn/txdocpic/0/c6dd4fa67166c92a852d81497602b4bd/0)



只要每次Minor GC过后200MB存活对象可以放Survivor区域，那么等下一次Minor GC的时候，这个Survivor区的对象对应的计算任务早就结束了，都是可以回收的了



此时比如Eden区里1.6GB空间被占满了，然后Survivor1区里有200MB上一轮 Minor GC后存活的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70308800_1563362993.cn/txdocpic/0/1529a0eb09d15c59499ee08fdaf539a7/0)



然后此时执行Minor GC，就会把Eden区里1.6GB对象回收掉，Survivor1区里的200MB对象也会回收掉，然后Eden区里剩余的200MB存活对象会放入Survivor2区里，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89497000_1563362993.cn/txdocpic/0/6ea6749024c342adef6918b21d3751f6/0)



以此类推，基本上就很少对象会进入老年代中，老年代里的对象也不会太多的。



通过这个分析和优化，定时我们成功的把生产系统的老年代Full GC的频率从几分钟一次降低到了几个小时一次，大幅度提升了系统的性能，避免了频繁Full GC对系统运行的影响。



**8、垃圾回收器简介**



在新生代和老年代进行垃圾回收的时候，都是要用垃圾回收器进行回收的，不同的区域用不同的垃圾回收器。



垃圾回收器是下周和下下周的重点内容，到时候会深入分析我们常用的ParNew、CMS和G1三种垃圾回收器的工作原理和优缺点。



这篇文章先简单给大家介绍一下：



**Serial和Serial Old垃圾回收器：**分别用来回收新生代和老年代的垃圾对象



工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。



**ParNew和CMS垃圾回收器：**ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。下周会着重分析这两个垃圾回收器。



**G1垃圾回收器：**统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，是下下周的重点，一周都会来分析G1垃圾回收器的工作原理和优缺点。



大家本周的重点，就是透彻理解新生代和老年代的对象分配以及垃圾回收的触发时机和运行机制，然后简单了解有哪些垃圾回收器即可。



明天会给大家讲垃圾回收最让人讨厌的**Stop The World**是怎么回事。



经过本周的学习，相信大家从原理层面对JVM有一个更加深入的认识。



**9、昨日思考题**



- 到底什么时候会尝试触发Minor GC？
- 触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？
- 什么时候在Minor GC之前就会提前触发一次Full GC？
- Full GC的算法是什么？
- Minor GC过后可能对应哪几种情况？
- 哪些情况下Minor GC后的对象会进入老年代？



昨天让大家把这个过程自己详细的梳理出来，相信看了今天的文章，理解的就更加透彻了。



**10、今日小作业**



本文是一个非常经典的真实生产案例和优化实践经验，建议大家不要光看，自己把今天的案例，从背景到分析到解决，一步一步自己画图来推演一遍，彻底吃透这个案例。



这对大家以后分析更多的JVM案例和优化，有非常好的作用

# 019、“Stop the World”问题分析：JVM最让人无奈的痛点！

2019-07-19 07:00:00



**1、前文回顾**



上一篇文章已经通过一个真实的案例分析了新生代的对象分配以及如何转移到老年代，如何频繁触发Full GC的一个场景，同时给出了优化的说明



相信大家通过上一篇文章就已经非常深刻的理解了JVM的核心运行原理了。



这篇文章我们就来讨论一下基于JVM运行的Java系统，最让我们Java工程师内心痛苦的到底是个什么问题？





**2、先来回顾一个新生代GC的场景**



大家先来看下面的图，新生代的内存大家都知道是分为Eden和两个Survivor的。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8865200_1563439787.cn/txdocpic/0/1128cbe6782d0e9dac8777de1bb38935/0)

那么此时如果系统不停的运行，然后把Eden给塞满了呢？如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26042500_1563439787.cn/txdocpic/0/a41ddcf0c02216216d04e62ec01cd07f/0)

这个时候势必就会触发Minor GC了，好，那么之前给大家说过，进行垃圾回收是有专门的垃圾回收线程的，而且对不同的内存区域会有不同的垃圾回收器，大家还记得这个事儿吗？



相当于垃圾回收线程和垃圾回收器配合起来，使用自己的垃圾回收算法，对指定的内存区域进行垃圾回收，大家看看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52156700_1563439787.cn/txdocpic/0/5b2a2c74597f3bb4f81c21ef23d0a16b/0)



通过上面这个图，大家对垃圾回收线程、垃圾回收器以及垃圾回收算法，是不是就有了一个非常清晰的关系的认识了？



没错，垃圾回收一定会通过一个后台运行的垃圾回收线程来执行他具体的一个逻辑



比如针对新生代我们会用ParNew垃圾回收器来进行回收，然后ParNew垃圾回收器针对新生代采用的就是复制算法来垃圾回收。



这个时候垃圾回收器，就会把Eden区中的存活对象都标记出来，然后全部转移到Survivor1去，接着一次性清空掉Eden中的垃圾对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/77248100_1563439787.cn/txdocpic/0/64d6b42ffb7e996605660a7d550794d3/0)



接着系统继续运行，新的对象继续分配在Eden中，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/94319600_1563439787.cn/txdocpic/0/3a674f6f57a2c2ab8a4ce5f4443511e9/0)



当Eden再次塞满的时候，就又要触发Minor GC了，此时已然是垃圾回收线程运行垃圾回收器中的算法逻辑，也就是采用复制算法逻辑，去标记出来Eden和Survivor1中的存活对象



然后一次性把存活对象转移到Survivor2中去，接着把Eden和Survivor1中的垃圾对象都回收掉，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11657100_1563439788.cn/txdocpic/0/193a23eef2b80e99108694d4973e6a49/0)

**3、GC的时候还能继续创建新的对象吗？**



不知道大家有没有考虑过一个问题，之前我们一直都是说GC的原理和JVM整体运行的机制



但是从来没说过在GC的时候，到底我们写好的Java系统在运行期间还能不能继续在新生代里创建新的对象了？



大家可以自己思考一下，假设允许在GC期间，然后还可以继续让系统在新生代的Eden区里创建新的对象，会是一个什么样的场景？



大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33767300_1563439788.cn/txdocpic/0/3f5c8776b548b08b6cadde7dcd62fc49/0)



根据上图所示，如果一边垃圾回收器在想办法把Eden和Survivor2里的存活对象标记出来转移到Survivor1去，然后还在想办法把Eden和Survivor2里的垃圾对象都清理掉，结果这个时候系统程序还在不停的在Eden里创建新的对象。



这些新的对象有的很快就成了垃圾对象，有的还有人引用是存活对象，那现在咋办？



全部乱套了，对于程序新创建的这些对象，你怎么让垃圾回收器去持续追踪这些新对象的状态？



怎么想办法在这次垃圾回收的过程中把新对象中的那些存活对象转移到Survivor2中去？



怎么想办法把新创建的对象中的垃圾都给回收了？



有的同学可能会想当然的说，那就想办法让垃圾回收器来做到啊！



我只能说，大家可以去搞清楚JVM的运行原理，但是不要随意去质疑人家JVM的垃圾回收机制为什么不去那么设计。



因为有些事情想着很简单，但是一旦你要在JVM中去实现的时候，会发现务必的复杂，成本极高，而且很难做到。



所以说，在垃圾回收的过程中，同时还允许我们写的Java系统继续不停的运行在Eden里持续创建新的对象，目前来看是非常不合适的一个事情。



**4、JVM的痛点：Stop the World**



所以现在大家就好理解了，我们平时使用JVM最大的痛点，其实就是在垃圾回收的这个过程



因为在垃圾回收的时候，尽可能要让垃圾回收器专心致志的干工作，不能随便让我们写的Java系统继续对象了，所以此时JVM会在后台直接进入“Stop the World”状态。



也就是说，他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！



然后让垃圾回收线程可以专心致志的进行垃圾回收的工作，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52177800_1563439788.cn/txdocpic/0/4d5ef76c8ce392f50e4156d2774c718c/0)

这样的话，就可以让我们的系统暂停运行，然后不再创建新的对象，同时让垃圾回收线程尽快完成垃圾回收的工作，就是标记和转移Eden以及Survivor2的存活对象到Survivor1中去，然后尽快一次性回收掉Eden和Survivor2中的垃圾对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79799200_1563439788.cn/txdocpic/0/3ced8eda6d01e98200b95d5c8c1210f3/0)



接着一旦垃圾回收完毕，就可以继续恢复我们写的Java系统的工作线程的运行了，然后我们的那些代码就可以继续运行，继续在Eden中创建新的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/358600_1563439789.cn/txdocpic/0/898af1ab808606ae42691e17edd13386/0)



**5、Stop the World造成的系统停顿**



现在大家就很清晰“Stop the World”会对系统造成的影响了， 假设我们的Minor GC要运行100ms，那么可能就会导致我们的系统直接停顿100ms不能处理任何请求



在这100ms期间用户发起的所有请求都会出现短暂的卡顿，因为系统的工作线程不在运行，不能处理请求。



假设你开发的是一个Web系统，那么可能导致你的用户从网页或者APP上点击一个按钮，然后平时只要几十ms就可以返回响应了



现在因为你的Web系统的JVM正在执行Minor GC，暂停了所有的工作线程，导致你的请求过来到响应返回，这次需要等待几百毫秒。



那么大家可以思考一下，回忆一下上篇文章讲到的案例，因为内存分配不合理，导致对象频繁进入老年代，平均七八分钟一次Full GC，而Full GC是最慢的，有的时候弄不好一次回收要进行几秒钟，甚至几十秒，有的极端场景几分钟都是有可能的。



那么此时一旦你频繁的Full GC，难道你希望你的系统每隔七八分钟就卡死个30秒吗？



在30秒内任何用户的请求全部卡死无法处理，然后用户看到的都是系统超时之类的提示，这会让用户体验极差



所以说，无论是新生代GC还是老年代GC，都尽量不要让频率过高，也避免持续时间过长，避免影响系统正常运行，这也是使用JVM过程中一个最需要优化的地方，也是最大的一个痛点。



**6、不同的垃圾回收器的不同的影响**



接着今天的话题，再来延伸说一下昨天提到的那些垃圾回收器



比如对新生代的回收，Serial垃圾回收器就是用一个线程进行垃圾回收，然后此时暂停系统工作线程，所以一般我们在服务器程序中很少用这种方式。



但是我们平时常用的新生代垃圾回收器是ParNew，他针对服务器一般都是多核CPU做了优化，他是支持多线程个垃圾回收的，可以大幅度提升回收的性能，缩短回收的时间



所以下周我们深入分析这块的时候，会告诉大家他的很多参数该如何优化



大致原理图如下

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20663800_1563439789.cn/txdocpic/0/b489262a7939856e34fdff6019fac936/0)



大家可以看到，不同的垃圾回收器他会有不同的机制和原理，使用多线程或者单线程，都是有区别的。



然后包括之前给大家提到的CMS垃圾回收器，专门负责老年代的垃圾回收，他也有自己特殊的一套机制和原理，非常的复杂



下周会深入讲CMS垃圾回收器的原理和参数优化，他也是基于多线程的，而且可以使用一套独特的机制尽可能的在垃圾回收的过程中减少“Stop the World”的时间，避免长时间卡死我们的系统。



包括下下周要深入剖析的现在很多公司都在使用的最新的G1垃圾回收器，他更是将采用复杂的回收机制将回收性能优化到机制，尽可能更多的降低“Stop the World”的时间。



其实JVM本身的迭代演进，就是不断的在优化垃圾回收器的机制和算法，尽可能的降低垃圾回收的过程对我们的系统运行的影响。



而我们作为一个合格的Java工程师，我们的责任就是尽可能搞懂这些垃圾回收器的运行机制和算法



然后合理的对线程系统优化内存分配和垃圾回收，尽可能减少垃圾回收的频率，降低垃圾回收的时间，减少垃圾回收对系统运行的影响。



所谓的JVM优化，其实指的就是这个。后续我们会结合大量的案例展开



相信大家一旦坚持3个多月学习完这个专栏，一定会从此脱胎换骨，对JVM的运行原理，垃圾回收机制，然后各种生产故障的监控、排查、定位、分析和解决，都有一个本质的能力提升，在公司里绝对可以搞定自己负责的生产系统的JVM故障。



**7、昨日思考题**

昨天给大家分析了一个经典的案例，是一个非常经典的真实生产案例和优化实践经验



建议大家不要光看，自己把今天的案例，从背景到分析到解决，一步一步自己画图来推演一遍，彻底吃透这个案例。



这对大家以后分析更多的JVM案例和优化，有非常好的作用。



**8、今日思考题**

给大家一个小小思考题：到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？



大家想想，明天给出答案。

**End**

# 020、第3周作业：自己动手画出各种垃圾回收算法和垃圾回收器的原理图

 2019-07-20 07:00:00





第3周作业：

自己动手画出各种垃圾回收算法和垃圾回收器的原理图



本周的作业非常重要，大家务必认真去做，因为这决定了大家是否吃透本周的内容，也决定了大家是否有足够扎实的基础去研究后续大量的优化案例。



本周希望大家自己画一幅非常完整的图，把以下流程全部画清楚：



- 对象在新生代的分配
- 什么时候会触发Minor GC
- 触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小
- 如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小
- 什么情况下Minor GC之前会提前触发Full GC
- 什么情况下会直接触发Minor GC
- Minor GC之后有哪几种情况对象会进入老年代



大家可以画一幅完整的图，然后配合大量的文字说明，一点一点条理清晰的把JVM的核心运行流程全部梳理清晰，这将成为后续研究JVM优化的坚实基础。

#   021、第3周答疑：本周问题答疑，上周作业点评

 2019-07-21 07:00:00





**第3周答疑问题汇总**





**问题**

一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



我的回答: 

1)加大分代年龄，比如默认15加到30; 



2)修改新生代老年代比例，比如新生代老年代比例改成2:1 



3)修改e区和s区比例，比如改成6:2:2 面试官说他们内部服务已经做到fullgc次数为0，只做ygc



想听听老师的意见



**答：**其实对这个面试题，非常的简单，需要深度结合线上系统的实际运行来看，你如果把本周文章全部看懂了，那么可以轻易回答这个问题。



首先上线系统之后，要借助一些工具（后面会讲）观察每秒钟会新增多少对象在新生代里，然后多长时间触发一次Minor GC，平均每次MInor GC之后会有多少对象存活，Survivor区是否可以放的下。



这里的关键点就是必须让Survivor区放下，而且不能因为动态年龄判定规则直接升入老年代。然后只要Survivor区可以放下，那么下次Minor GC后还是存活这么多对象，依然可以在另外一块Survivor区放下，基本就不会有对象升入老年代里去。



我们的案例其实也是做了类似的优化，几乎消灭了Full GC。包括一些检查参数如何设置





**问题：**

老师，我们公司的项目是一个数据采集解析的系统。对于每一条采集的数据都会封装成一个对象放到缓存中，然后继续走后续的流程。



假设一个对象（包含原始日志，扩展信息）有1kb大小。一秒一万数据量的话就是一秒将近10mb。然后如果一台给的4g内存给新生代内存。



那么400秒就会触发gc。请问这样算对吗？有什么优化的手段吗？之前开发重来没有考虑过gc问题



**答：**是的，还得考虑你每条消息需要处理多长时间，如果发生GC，最多可能有多少数据是被引用的，无法回收





**问题**

我总结了本周所学的知识，得出一套演算过程和公式，请看一下是这样吗？



每台机器可以提供给JVM的最大内存： each_m，比如2核4G机器，可提供JVM最大内存2G 栈占用：stack_m = QPS估值 * 1M * 20倍数，估值30QPS，栈约为600M 



新生代以30分钟一次GC计算总内存：30(Monitor GC间隔) * 60 * QPS估值 * 接口内存估值,young_m 所需机器数量，假设等于N 



方法区：200M，一般够用，method_m 老年代：500M，一般不大，300M也行，像我们结算服务，100M都够用



old_m 演算公式: JVM最大内存*N = stack_m + young_m + old_m + method_m * N 机器数N，也同时估算出来，是这样吗



**答：**是这样，总结的非常好





**问题**

老师，在上面看到一句，gc回收的是软引用，弱应用和虚引用，对吗？



还有我记得jvm是自动去垃圾回收的，程序员没法指定，现在加上弱引用，是去指定回收吗



**答：**不是的，软引用，弱引用之类的，只不过是指定哪些对象可以回收而已





**问题**

当初始化静态变量replicaManager的时候，replicaManager成员变量也会初始化，按今天课程的理解，有静态变量引用，所以不会回收。不知道我的理解是否正确。



**答：**理解正确





**学员思考题回答：**

**思考题：**

**![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/78545800_1563545979.png)**



上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？



**学员回答：**不会回收，ReplicaFecher对象被replicaFetcher强引用，而ReplicaManager对象又被可作为GC ROOT的replicaManager强引用



所以ReplicaFetcher对象可以向上找到GCROOT，因此不会回收





**学员思考题回答：**

对于新生代内存清理，首先是栈桢出栈，新生代的引用对象消失，然后就是minoc gc 垃圾回收



**问题**

老师您好！有个问题想不明白！



比如在方法里有个局部变量A a= new A()，变量a存储在当前方法的栈帧的局部变量表，实例对象存储在堆里！ 在执行到该方法时创建了实例对象



当方法结束后，虚拟机栈都会清空，刚刚执行方法时创建的对象在gc时不会清除？为啥呢，留着还有用吗！那下次再调用这个方法时还会new新的对象啊！想不太明白！



**答：**此时不会，此时仅仅是对象没人引用而已，要等待垃圾回收的时候给回收掉



**问题**

打卡。今天内容很简单，不过有一个疑问，就是存活对象在移动的时候内存地址不会发生改变吗？句柄引用的内存地址到底是不是一个固定的值？



**答：**内存地址会改变



**问题**

在给新建对象分配内存的时候，被利用的survivor区和Eden区这90%可以看做一个整体，新建对象可以分配到被利用的survivor区，也可以分配到Eden区，只有垃圾回收进行复制的时候才会明显区分出survivor区的作用，这样理解对吗？



**答：**

对的，理解正确





**问题**

您好，关于内存大小估算这块，您说可以把之前的计算结果扩大10倍~20倍。



也就是说，每秒钟除了在内存里创建支付订单对象，还会创建其他数十种对象。



为什么是10倍~20倍，为什么您不估算5倍，不估算50倍，每秒中除了在内存里创建支付订单对象，还会创建其他数十种对象这个思路是怎么来的?



望回复，谢谢，如果我们出去面试的话，可能有些面试官会这么问的



**答：**这是一个经验值，是根据那个支付案例来说的，其实核心含义不是让大家记住这个10~20倍的数字，而是应该你自己根据自己的系统来考虑



不同的系统都是不一样的，你只要把你负责的系统大致看看，就知道他每秒请求过来，会连带创建多少种对象，大致其实就估算出来了



**问题**

老师讲的思路很清晰，从优缺点分析，有浅入深，能否解答一下：eden区和survivor区 对象是通过什么规则被分配到这两个区的呢？还是说是随机分配



**答：**优先分配到Eden区，Survivor区是用来放每次GC过后的那些存活对象的



**问题**

有个地方描述不够严谨吧。比如：接着新对象继续分配在Eden区和另外那块开始被使用的survivor区，然后始终始终保持一块survivor区是空着的。



这个应该没有survivor区是空的吧，之前垃圾回收后不是剩余的存活的对象已经被移动到另一块survivor区了吗？它里面并不是空的啊?是不是这样呢老师



**答：**假设Eden区和Survivor1区里有对象，一次Minor GC过后，存活对象全部进入Survivor2区域



接着新对象继续在Eden区里分配，Survivor2里放之前Minor GC后存活的对象，然后Survivor1区是空的。



下一次Minor GC过后，剩余存活对象进入Survivor1区里，然后Survivor2区就是空的了。





**问题**

"接着新的对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空的"



那么老师，程序在刚刚启动的时候，第一次创建对象时也会分配到Eden区和其中一个Survivror区吗？ 



还是说只分配到Eden区，此时发现Eden区满了，其他两个survivor区还是空的情况下，触发第一次小GC？



**答：**只分配到Eden区的，然后第一次Minor GC后会转移存活对象到一块Survivor去





**问题**

问个问题，为什么老年代不采用复制算法，像新生代那样一个E两个S呢，或者说为什么新生代不采用标记整理算法呢？还有就是标记清除算法会产生内存碎片，那jvm中是在哪里用到了



**答：**老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。





**问题**

今天的内容比起之前的逻辑性强很多，需要好好思考和梳理一下，感谢老师一步一步带着我们由浅入深。



**答：**加油，继续坚持



**问题**

两个问题：

1. 假设MinorGC之前老年代空间担保成功，但是实际不幸的是MinorGC之后老年代放不下而触发了FullGC，之后马上又会伴随一次MinorGC是吗，相当于短时间内进行了两次MinorGC，有这个必要吗？ 

   

   

2. 老年代为什么用标记整理算法？优势在哪里



**答：**

1、多一次Minor GC没什么，他速度很快 



2、老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。





**问题**

大神，默认情况下，新生代占整个堆的3/8，实际情况我们新生代大小占多少合适，我看你在这个支付系统给的是2/3，我们系统在压测的时候，yong gc明显，我把新生代调整为一半了



**答：**这个新生代设置为多少，其实没有固定的大小，需要自己根据实际系统运行情况来调节





**学员的思考题作答：**

**1、到底什么时候会尝试触发Minor GC？**

 新生代剩余内存空间放不下新对象，此时需要触发GC。



触发MinorGC情况有: 

1- 新生代现有存活对象小于老年代剩余内存 ，即老年空间代足以支撑可能晋升的对象 

2- 情况1不成立，查看设置了空间担保且可以担保成功 



**2、触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？** 

1、判断新生代存活是否大于老年代剩余 

2、条件1成立且设置空间担保的情况下，判断老年代剩余是否大于之前进入老年代平均存活大小 



**3、什么时候在Minor GC之前就会提前触发一次Full GC？** 

新生代现有存活对象>老年代剩余内存情况下，未设置空间担保 或 空间担保失败



**4、Full GC的算法是什么？** 

标记整理算法，速度很慢 



**5、Minor GC过后可能对应哪几种情况？** 

放入新对象前进行判断，新对象大小+存活对象是否可以分配在新生代。可以则放入，否则判断是否可以放入老年代。可以则放入，否则 OOM



**6、哪些情况下Minor GC后的对象会进入老年代？** 

新生代放不下，老年代可以放下的情况下





**问题**

先说一下问题： 

1、MinorGC后，存活对象大于survivor区域，小于老年代可用空间，是所有对象都进入老年代，还是一部分



如果所有的对象都进入，是不是会有一些浑水摸鱼？



比如新建的对象，刚好一次MinorGC后还存活，也就是说年龄只有1岁的对象进入老年代，这些对象可能在第二次MinorGC就可以回收，只是正好赶上了这趟车，这样进入老年代没一会就成为垃圾对象了



2、记得之前讲的说设置堆内存，新生代一般是比老年代大的。新生代如果触发MinorGC，表示这新生代满了



一般情况下，新生代满了，对象占用内存肯定是大于老年代可用空间的



所以不明白MinorGC前检查老年代可用空间是否大于新生代所有对象内存，大部分情况下，这个检查的结果都为true呀。难道只是为了文中所说的，规避极端情况吗？



那我直接进行-XX:-HandlePromotionFailure，之后进行FullGC，或MinorGC，如果是极端情况，再抛出OOM，这样不也很好吗。 请老师指点一下 



**下面是我的今日思考题回答：**

1、

Eden区和存对象的Survivor区满的时候触发MinorGC 



2、

检查新生对所有对象所占空间是否大于老年代可用空间， 如果小于，进行MinorGC。 



如果大于，查看"-XX:-HandlePromotionFailure"是否设置。



如果没设置，进行FullGC。如果设置如果没设置，进行FullGC。



如果设置，判断老年代空间是否大于之前MinorGC后进入老年代对象的平均大小。 如果大于，进行MinorGC。 如果小于，进行FullGC。 



3、

(1)新生代对象大小大于老年代空间，且没有设置"-XX:-HandlePromotionFailure" 



(2)设置了"-XX:-HandlePromotionFailure"，老年代可用空间小于之前每次MinorGC后进入老年代的平均大小



 4、

标记整理算法，老年代对象存活时间较长，赋值算法不太适合，标记-清理算法会产生内存碎片。标记整理可以规避。 



5、

(1)小于Survivor区域，进入Survivor区域



(2)大于survivor区域，小于老年代可用空间，进入老年代 



(3)大于survivor区域，大于老年代可用空间，进行FullGC，如果FullGC后，老年代可用空间仍小于存活对象，抛出OOM 



6、 

(1)经过15次(默认，可以设置)MinorGC的 



(2)某个年龄的对象大于survivor区域的



**答：**

1、所有对象都进入老年代 



2、不见得，新生代和老年代谁大谁小，看具体场景怎么设置，老年代更大其实很正常，所以一般要设置那个参数，突破第一重检查的限制



**问题**

是每次Minor GC之前都会去检查是否老年代的大小大于新生代所有内存的大小？还是每次Minor GC之前如果预估到Survivor区域不够了，才会去做这个检查？ 



如果第一种情况，那么假如Survivor能存的下回收后的对象，每次检查一下老年到貌似不必要。



如果第二种情况，到底是怎么预估的回收后的对象Survivor能放得下？难道遍历一次GCROOT然后计算他们的内存大小。感觉不太靠谱，遍历GC root是垃圾回收器做的事情，发生在“垃圾回收过程中”而不是“垃圾回收之前”



**答：**每次Minor GC前直接检查新生代全部对象的大小是否小于老年代可用内存大小，不是检查新生代的存活对象的大小，所以这个比较成本是很低的





**问题**

请教下，我们写好等代码在运行等过程中，对于创建的各种各样的对象，放入新生代的内存顺序一定首先是eden区，然后survivor1区吗？还是也可能是eden区和survivor2区？谢谢老师



**答：**仅仅放在Eden区里，Survivor是用来放每一次Minor GC后存活的对象的





**非常棒的学员思考题回答**

到底什么时候会尝试触发Minor GC？ 

答：当新生代的Eden区和其中一个Survivor区空间不足时。 



触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？ 

答：

1、先判断新生代中所有对象的大小是否 小于 老年代的可用区域 true 则 触发Minor GC，false则继续进行下面2中的判断 



2、如果设置了-XX:HandlePromotionFailure这个参数，那么进入第3步 如果没有设置-XX:HandlePromotionFailure参数，那么触发Full GC 



3、判断Minor GC历次进入老年代的平均大小是否 小于 老年代的可用区域 true 则触发Minor GC，false则会触发Full GC 什么时候在Minor GC之前就会提前触发一次Full GC？ 

答：当判断 新生代历次进入老年代对象的平均大小 大于 老年代的可用区域就会触发一次Full GC，让老年代腾出一些空间，腾出空间后再进行Minor GC。 



FullGC的算法是什么？ 

答：标记整理算法。 



Minor GC过后可能对应哪几种情况？ 

答： 

**情况1：**Minor GC前先判断：存活的对象所占的内存空间 < Survivor区域内存空间的大小，那么存活的对象进入Survivor区。 



**情况2：**Minor GC前先判断：Survivor区域内存空间的大小 < 存活的对象所占的内存空间 < 老年代的可用空间大小。那么存活的对象，直接进入老年代。 



**情况3：**Minor GC前先判断： (存活的对象所占的内存空间 > Survivor区域内存空间的大小) && (存活的对象所占的内存空间 > 老年代的可用空间大小)。那么会触发Full GC，老年代腾出空间后，再进行Minor GC。如果腾出空间后还不能存放存活的对象，那么会导致OOM即堆内存空间不足、堆内存溢出。 



哪些情况下Minor GC后的对象会进入老年代？ 

答：

1、 Survivor区 < 存活对象占用的空间 && 老年代可用区域 < 存活对象占用的空间 

2、经过XX:MaxTenuringThreshold次M





**问题**

老师，诚心求教，希望能帮忙解释清楚，反复看了几次，确实文章开头说的也是我们写好的代码在运行过程中，会不断的创建各种各样的对象



这些对象会优先存放在新生代的Eden和survivor1区，接着假如新生代的Eden和s1都快满了，就发生minor gc，存活对象移动到s2.



然后接着就会使用Eden和s2区来分配新的对象



那文章下面为什么又提到系统继续运行，继续在Eden区里分配各种对象？难道不该是系统继续运行，继续在Eden区和s2区里分配各种对象，发生minor gc后，再移动到s1吗？这里的描述前后理解困惑



**答：**同学，你可能理解错一点了，对象都是在Eden区分配的，然后一次Minor GC过后，存活对象转移到S1区，此时Eden区就清空了，对吧？



然后接着系统继续运行，对象继续分配在Eden区，下一次Minor GC过后，看看Eden + S1里的存活对象有哪些，都转移到S2区。



接着系统继续运行，对象继续分配在Eden区，下一次Minor GC过后，看看Eden + S2里的存活对象有哪些，都转移到S1区。S1和S2就是用来放存活对象的，Eden区用来让系统分配新的对象进去。





**问题**

非常感激老师的耐心解答，那是不是可以理解为minor gc触发条件是Eden区放不下新的对象为触发条件？



然后追问一个关于full gc，是不是存在minor gc检查历次的放入老年代的对象大小小于本次实际要挪移的对象大小情况，从而才会说有minor gc发生后，再次full gc再minor gc的情况？感谢，感谢



**答：**

1、对的 

2、不对，是历次进入老年代的对象大小小于当前老年代的内存大小，才会触发minor gc；否则先是full gc给老年代腾空间，再minor gc





**问题**

忍不住再追加一个确认，会不会存在minor gc前检查历次进入老年代的对象均值是10M，然后当前老年代剩余50M，明显大于历次的10M这个值，于是触发minor gc正常执行，但执行后发现本次实际要放入老年代的对象大小大于均值且大于50M的情况，从而再来一次fullgc和minor gc这样的情况？感恩分享



**答：**会的，如果是这种情况，就是会先执行minor gc，然后发现老年代内存不足，触发full gc







**问题**

老师，每次Minor GC后剩余的是200MB是根据2 8法则推测的吗，我们平时做优化假设也是按照这个法则来吗？那如果我想知道实际中真正剩余多少内存的对象有什么办法吗？



**答：**不是的，这个数字是根据线上生产日志判断出来的，后续会教大家看gc日志，很清晰可以看到每分钟minor gc的时候多少对象进入老年代





**问题**

打卡。今天这个案例很好的结合估算内存压力大小和新老代回收机制进行了产线问题排查，这个思路在以后的工作中也很重要，学习了。



**答：**是的，建议直接按照这个案例背景从头到尾画一下整个内存分析的全流程和优化过程







**问题**

老师，评估每次任务或者每秒系统产生的数据大小是不是有专门的工具可以结合起来看。



**答：**是的，后续会带着动手操作一些工具的使用，这里就是先讲原理，结合案例说明原理





**问题**

每个计算计算任务1万条数据需要计算10秒钟，假设此时计算出80个计算任务都执行成功了。。。卡在这里了



后来想明白了：假设1分钟100个计算任务，每个计算任务是10秒钟，在60秒到来的那一刻，只有50-60秒开始执行的计算任务是没有执行完毕的，占比1/6,100 / 6 = 16.66 。 所以可以大致估算还有20个计算任务还在计算中。



**答：**是的，线上生产系统大致就是这个比例



**问题**

关于空间分配担保有一点疑问 当老年代的可用内存空间小于新生代所有对象的总大小时, 无论有没有空间分配担保, 最坏的情况都是一次minor GC + Full Gc 



那为什么还需要这个分配担保?? 直接minor GC, 之后再进行那三种可能的判断不就行了, HandlePromotionFail的意义何在?



**答：**不是的，如果说没有开启一个检查，此时可能提前Full GC，那么这样就太频繁了；但是如果经过文章里说的检查机制，发现不需要Full GC那么就直接Minor GC；差别在于不需要频繁Full GC





**问题**

按照每一次Minor GC之前JVM都会检测老年代空间是否大于新生代对象的总大小。一般上线的环境下，控制Minor GC的频率后，如果资源是不是是尽量为老年代分配更大的空间。如果不行，就需要设置参数HandlePromationFail。



这样理解可以吗？老师



**答：**理解正确的，但是其实具体一个系统要如何分配Eden、Survivor、老年代的内存，其实是很有讲究的，主要得看系统运行的特点



# 022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！

 2019-07-22 07:00:0





**一步一图**

**深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！**



**1、前文回顾**



上周的文章已经给大家把整个JVM的核心运行原理全部梳理清楚了，大家现在应该对以下问题非常的清晰明了：



1. 对象在新生代分配，然后什么时候会触发Minor GC

   

2. 触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小，如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小

3. 什么情况下Minor GC之前会提前触发Full GC，什么情况下会直接触发Minor GC

4. Minor GC之后有哪几种情况对象会进入老年代



而且大家也大概知道了垃圾回收器、垃圾回收线程、垃圾回收算法之间的关系，包括垃圾回收的过程中的“Stop the World”现象和场景对系统运行性能的影响。



这周我们就要来相对深入的研究一下常见的新生代和老年代的垃圾回收器的运行原理了，同时看看常见的垃圾回收参数一般会怎么来设置。



同时结合案例来研究一下在你上线一个新系统的时候，如何通过预估的手段和方法提前对系统的垃圾回收参数进行合理的设置。



**2、最常用的新生代垃圾回收器：ParNew**



一般来说，在之前多年里，假设没有最新的G1垃圾回收器的话，通常大家线上系统都是ParNew垃圾回收器作为新生代的垃圾回收器



当然现在即使有了G1，其实很多线上系统还是用的ParNew。



通常运行在服务器上的Java系统，都可以充分利用服务器的多核CPU的优势，所以大家可以想一下，假设你的服务器是4核CPU，如果对新生代垃圾回收的时候，仅仅使用单线程进行垃圾回收，是不是会导致没法充分利用CPU资源？



如下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76102200_1563502885.cn/txdocpic/0/78d07e79a2613879f51d7c5506b196ae/0)



比如上图，现在你在垃圾回收的时候，都把系统程序所有的工作线程全部停掉了，就一个垃圾回收线程在运行



那么此时4核CPU的资源根本没法充分利用，理论上4核CPU就可以支持4个垃圾回收线程并行执行，可以提升4倍的性能！



所以说，新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。



大家看下图，ParNew垃圾回收器如果一旦在合适的时机执行Minor GC的时候，就会把系统程序的工作线程全部停掉，禁止程序继续运行创建新的对象，然后自己就用多个垃圾回收线程去进行垃圾回收，回收的机制和算法就跟之前说的是一样的。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98227500_1563502885.cn/txdocpic/0/2101a5af1ad707d3174c3c22320150e7/0)



**3、如何为线上系统指定使用ParNew垃圾回收器？**

一般来说，对于线上系统部署启动的时候，我们之前都看过多种方式来设置JVM参数了，在Eclipse/IntelliJ IDEA中可以设置Debug JVM Arguments，使用“java -jar”命令启动时直接在后面跟上JVM参数即可



部署到Tomcat时可以在Tomcat的catalina.sh中设置Tomcat的JVM参数，使用Spring Boot也可以在启动时指定JVM参数。



那么在启动系统的时候如果要指定使用ParNew垃圾回收器，是用什么参数呢？



很简单，使用“-XX:+UseParNewGC”选项，只要加入这个选项，JVM启动之后对新生代进行垃圾回收的，就是ParNew垃圾回收器了。



那么Minor GC的时机，检查机制，包括垃圾回收的具体过程，以及对象升入老年代的机制，都是我们之前说过的那套原理了，只不过大家要知道，ParNew会使用多个线程来进行垃圾回收。



**4、ParNew垃圾回收器默认情况下的线程数量**

因为现在一般我们部署系统的服务器都是多核CPU的，所以为了在垃圾回收的时候充分利用多核CPU的资源，一旦我们指定了使用ParNew垃圾回收器之后，他默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的。



比如我们线上机器假设用的是4核CPU，或者8核CPU，或者16核CPU，那么此时ParNew的垃圾回收线程数就会分别是4个线程、8个线程、16个线程



这个东西一般不用我们手动去调节，因为跟CPU核数一样的线程数量，是可以充分进行并行处理的。



比如下图，大家可以看到，每个线程都通过一个CPU在运行。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11681600_1563502886.cn/txdocpic/0/8a237f1723e379efa239fdb1e261c4c2/0)



但是如果你一定要自己调节ParNew的垃圾回收线程数量，也是可以的，使用“-XX:ParallelGCThreads”参数即可，通过他可以设置线程的数量



但是建议一般不要随意动这个参数，如果要优化，具体结合后续的案例我们给大家展开。



**5、本文总结**

这篇文章篇幅不长，主要介绍一下ParNew垃圾回收器，其实垃圾回收器的工作原理之前上周就全部介绍过了



这周的第一篇文章，主要就是对ParNew垃圾回收器本身的多线程原理和相关的参数做一些说明。



**6、昨日思考题**

上篇文章让大家思考了一个问题，其实反而在这篇文章里要多花点时间来说明。



之前让大家思考的问题就是：



- 到底是用单线程垃圾回收好，还是多线程垃圾回收好？
- 到底是Serial垃圾回收器好还是ParNew垃圾回收器好？



对这个问题要给大家略微展开做点解释。



启动系统的时候是可以区分服务器模式和客户端模式的，如果你启动系统的时候加入“-server”就是服务器模式，如果加入“-cilent”就是客户端模式。



他们俩的**区别**就是，如果你的系统部署在比如4核8G的Linux服务器上，那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式。



那么服务器模式和客户端模式的区别是啥呢？



服务器模式通常运行我们的网站系统、电商系统、业务系统、APP后台系统之类的大型系统，一般都是多核CPU



所以此时如果要垃圾回收，那么肯定是用ParNew更好，因为多线程并行垃圾回收，充分利用多核CPU资源，可以提升性能。如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38639500_1563502886.cn/txdocpic/0/8a237f1723e379efa239fdb1e261c4c2/0)



反之如果你部署在服务器上，但是你用了单线程垃圾回收，那么就有一些CPU是被浪费了，根本没用上



比如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/62351800_1563502886.cn/txdocpic/0/a8f06e044c5639c4b8807137e2a657e1/0)



那么如果你的Java程序是一个客户端程序，比如类似百度云网盘的Windows客户端，或者是印象笔记的Windows客户端，运行在Windows个人操作系统上呢？



这种操作系统很多都是单核CPU，此时你如果要是还是用ParNew来进行垃圾回收，就会导致一个CPU运行多个线程，反而加重了性能开销，可能效率还不如单线程好



因为单CPU运行多线程会导致频繁的线上上下文切换，有效率开销，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/86104900_1563502886.cn/txdocpic/0/262513a5e0cd2dc1b3568e5b1d136352/0)



所以如果是类似于那种运行在Windows上的客户端程序，建议采用Serial垃圾回收器，单CPU单线程垃圾回收即可，反而效率更高，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5675600_1563502887.cn/txdocpic/0/064051b3f80a807a9e844ae7d08c6ae3/0)

但是其实现在一般很少有用Java写客户端程序的，几乎很少见，Java现在主要是用来构建复杂的大规模后端业务系统的，所以常见的还是用“-server”指定为服务器模式，然后配合ParNew多线程垃圾回收器。



但是大家还是应该清楚单线程和多线程对垃圾回收的适用场景。



**7、今日思考题**

其实我们一直是鼓励大家在评论区提出有价值的提问的，有自己的思考在里面



昨天有个同学提了一个自己经历过的JVM的面试题，我觉得非常好，给出来让大家思考一下：



“一个面试题，parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



我的回答（这里指该同学回答）: 

1. 加大分代年龄，比如默认15加到30; 
2. 修改新生代老年代比例，比如新生代老年代比例改成2:1 
3. 修改e区和s区比例，比如改成6:2:2



面试官说他们内部服务已经做到fullgc次数为0，只做ygc，想听听老师的意见



对于这个面试题，如果大家吃透了咱们这个专栏前三周的JVM原理和案例，完全可以把这个面试题回答的滴水不漏



结合案例和画图给面试官说明，而不是干巴巴的简单给几个方法，可以回答的有血有肉，让面试官无话可说。



其实要做到仅仅young gc，而几乎没有full gc是不难的，只要结合自己系统的运行，根据他的内存占用情况，GC后的对象存活情况，合理分配Eden、Survivor、老年代的内存大小，合理设置一些参数，即可做到。



**End**

# 023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？

2019-07-23 07:20:35

**1、前文回顾**



本文我们就要进入最核心的老年代垃圾回收环节了，之前的文章大家看过之后对JVM的核心原理都有一定的了解了，年轻代的垃圾回收机制也都很清楚了，其实年轻代的垃圾回收通过复制算法来，还是比较简单的。



大家心里最希望的，就是对象都分配在新生代的Eden区，然后每次垃圾回收之后，存活对象都进入Survivor区，然后下一次垃圾回收后的存活对象都进入另外一个Survivor区。



这样几乎很少很少的对象会进入老年代里去，也就几乎不太会触发老年代的垃圾回收了。



但是理想很丰满，现实很骨干。其实大家想想，你们在写代码的时候，有谁会考虑垃圾回收啥的？不会有人考虑这个吧，就是不停的狂写代码，然后直接上线部署，根本没多少人会考虑自己的代码对垃圾回收的影响。



最多有经验的工程师上线之前，通过我们之前的案例讲解的方法估算一下系统的内存压力以及垃圾回收的运行模型，然后合理设置一下内存各个区域的大小，尽量避免太多对象进行老年代里去。



但是真实情况是，线上系统很可能就会因为各种各样的情况，导致很多对象进入老年代，然后甚至频繁触发老年代的Full GC。



之前我们用案例给大家演示过很多这种情况，比如说Survivor区太小，容纳不了每次Minor GC后的存活对象，导致对象频繁进入老年代，频繁触发老年代Full GC。



类似的情况其实很多，所以，咱们不能过于理想化的期待永远没有老年代GC，还是要对老年代的垃圾回收器是如何回收的，有一个了解和认识。



**2、CMS垃圾回收的基本原理**

一般老年代我们选择的垃圾回收器是CMS，他采用的是标记清理算法，其实非常简单，就是先用之前文章里讲过的标记方法去标记出哪些对象是垃圾对象，然后就把这些垃圾对象清理掉，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27951000_1563838359.cn/txdocpic/0/e64448b93c84a54644aec30be5c7e38c/0)



上面图里是一个老年代内存区域的对象分布情况，现在假设因为老年代内存空间小于了历次Minor GC后升入老年代对象的平均大小，判断Minor GC有风险，可能就会提前触发Full GC回收老年代的垃圾对象。



或者是一次Minor GC后的对象太多了，都要升入老年代，发现空间不足，出发了一次老年代的Full GC。



总之就是要进行Full GC了，此时所谓的标记-清理算法，其实就是我们之前给大家讲过的一个算法，先通过追踪GC Roots的方法，看看各个对象是否被GC Roots给引用了，如果是的话，那就是存活对象，否则就是垃圾对象。



先将垃圾对象都标记出来，然后一次性把垃圾对象都回收掉，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38850200_1563838359.cn/txdocpic/0/5393937869fd98892422643e55740510/0)



这种方法其实最大的问题，就是会造成很多内存碎片



大家看下图的红圈处就是所谓的内存碎片，这种碎片不大不小的，可能放不小 任何一个对象，那么这个内存就被浪费了，之前我们聊过这个问题。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49393000_1563838359.cn/txdocpic/0/ea251f968c885067b86fba7624aa1653/0)



这就是CMS采取的“标记-清理”算法。





**3、如果Stop the World然后垃圾回收会如何？**

现在大家思考一个问题，假设要先“Stop the World”，然后再采用“标记-清理”算法去回收垃圾，那么会有什么问题？



之前文章也说过了，如果停止一切工作线程，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长，很多响应无法处理。



所以CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。



**4、CMS如何实现系统一边工作的同时进行垃圾回收？**

CMS在执行一次垃圾回收的过程一共分为4个阶段：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清理



我们一点一点来看。



首先，CMS要进行垃圾回收时，会先执行初始标记阶段，这个阶段会让系统的工作线程全部停止，进入“Stop the World”状态，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57926200_1563838359.cn/txdocpic/0/7b4b94700deabfe69dee1e5e121960d2/0)



所谓的“初始标记”，他是说标记出来所有GC Roots直接引用的对象，这是啥意思呢？



比如下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/69169300_1563838359.png)



在初始标记阶段，仅仅会通过“replicaManager”这个类的静态变量代表的GC Roots，去标记出来他直接引用的ReplicaManager对象，这就是初始标记的过程。



他不会去管ReplicaFetcher这种对象，因为ReplicaFetcher对象是被ReplicaManager类的“replicaFetcher”实例变量引用的



之前说过，方法的局部变量和类的静态变量是GC Roots。但是类的实例变量不是GC Roots。



如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80271100_1563838359.cn/txdocpic/0/566ee7ab4279ab1af92d5aeda6935adc/0)



所以第一个阶段，初始标记，虽然说要造成“Stop the World”暂停一切工作线程，但是其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象罢了。



接着第二个阶段，是并发标记，这个阶段会让系统线程可以随意创建各种新对象，继续运行



在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行GC Roots追踪。



所谓进行GC Roots追踪，意思就是对类似“ReplicaFetcher”之类的全部老年代里的对象，他会去看他被谁引用了？



比如这里是被“ReplicaManager”对象的实例变量引用了，接着会看，“ReplicaManager”对象被谁引用了？会发现被“Kafka”类的静态变量引用了。



那么此时可以认定“ReplicaFetcher”对象是被GC Roots间接引用的，所以此时就不需要回收他。如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/88544800_1563838359.cn/txdocpic/0/0ba5aed67a0c066939c5c5d44751daac/0)



但是这个过程中，在进行并发标记的时候，系统程序会不停的工作，他可能会各种创建出来新的对象，部分对象可能成为垃圾，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98069600_1563838359.cn/txdocpic/0/30a65b913e1e3e71ae10b9020e15ee3f/0)



第二个阶段，就是对老年代所有对象进行GC Roots追踪，其实是最耗时的



他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响的。



接着会进入第三个阶段，重新标记阶段



因为第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾



所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/7863600_1563838360.cn/txdocpic/0/a35cde5bee7ccb9b91eb76104422bb00/0)



所以此时进入第三阶段，要继续让系统程序停下来，再次进入“Stop the World”阶段。



然后重新标记下在第二阶段里新创建的一些对象，还有一些已有对象可能失去引用变成垃圾的情况，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/17323800_1563838360.cn/txdocpic/0/41036b424d0e3a5284f8436bfccb8d53/0)



这个重新标记的阶段，是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。



接着重新恢复系统程序的运行，进入第四阶段：**并发清理**



这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。



这个阶段其实是很耗时的，因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26374900_1563838360.cn/txdocpic/0/0d832fc8cc9c572bbe12e593431c3667/0)



**5、对CMS的垃圾回收机制进行性能分析**

其实大家看完CMS的垃圾回收机制之后，就会发现，他已经尽可能的进行了性能优化了



因为最耗时的，其实就是对老年代全部对相关进行GC Roots追踪，标记出来到底哪些可以回收，然后就是对各种垃圾对象从内存里清理掉，这是最耗时的。



但是他的第二阶段和第四阶段，都是和系统程序并发执行的，所以基本这两个最耗时的阶段对性能影响不大。



只有 第一个阶段和第三个阶段是需要“Stop the World”的，但是这两个阶段都是简单的标记而已，速度非常的快，所以基本上对系统运行响应也不大。



明天的文章，我们就继续深入来看看CMS垃圾回收机制的各种细节以及一些参数一般如何设置。



**6、昨日思考题**

昨天的思考题，是一个学员真实面试中遇到的一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



该学员的回答: 

1. 加大分代年龄，比如默认15加到30; 
2. 修改新生代老年代比例，比如新生代老年代比例改成2:1 
3. 修改e区和s区比例，比如改成6:2:2



其实让大家去梳理这个思路，就是希望大家多一些思考，多一些梳理和总结。答案就在我们之前讲过的案例里，大家只要结合那个案例分析，就知道解答这面试题的思路。



大家可以尝试着作答，将自己的答案发至评论区。



**7、今日思考题**

看完了新生代和老年代的垃圾回收机制之后，大家来思考一下：为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？



明天的文章我们会深入探讨CMS垃圾回收机制和对应的参数，同时解答这个问题。

# 024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？

2019-07-24 07:00:00

**目录：**

1. 前文回顾
2. 并发回收垃圾导致CPU资源紧张
3. Concurrent Mode Failure问题
4. 内存碎片问题
5. 昨日思考题解答
6. 今日思考题





**1、前文回顾**

上篇文章用一步一图的方式给大家讲清楚了CMS垃圾回收的运行机制



简单来说，为了避免长时间“Stop the World”，CMS采用了4个阶段来垃圾回收，其中初始标记和重新标记，耗时很短，虽然会导致“Stop the World”，但是影响不大。



然后并发标记和并发清理，两个阶段耗时最长，但是是可以跟系统的工作线程并发运行的，所以对系统没太大影响。



这就是CMS的基本工作原理。



但是本文要更加深入的去说一说CMS垃圾回收期间的一些细节问题，同时给出CMS常见的JVM参数应该如何设置。



**2、并发回收垃圾导致CPU资源紧张**

首先大家回顾一下这个图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73362100_1563871849.cn/txdocpic/0/20ceb2b12462f65eda7f98d7d1011ae8/0)

CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分。



并发标记的时候，需要对GC Roots进行深度追踪，看所有对象里面到底有多少人是存活的



但是因为老年代里存活对象是比较多的，这个过程会追踪大量的对象，所以耗时较高。并发清理，又需要把垃圾对象从各种随机的内存位置清理掉，也是比较耗时的。



所以在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4。



我们用最普通的2核4G机器和4核8G机器来计算一下，假设是2核CPU，本来CPU资源就有限，结果此时CMS还会有个“(2 + 3) / 4” = 1个垃圾回收线程，去占用宝贵的一个CPU。



所以其实CMS这个并发垃圾回收的机制，第一个问题就是会消耗CPU资源。



**3、Concurrent Mode Failure问题**

第二个问题，是很多同学都很关注的一个问题，就是如下图



在并发清理阶段，CMS只不过是回收之前标记好的垃圾对象



但是这个阶段系统一直在运行，可能会随着系统运行让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“**浮动垃圾**”。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/86853700_1563871849.cn/txdocpic/0/5bd81858c4051cbd855c33926990d883/0)



大家看上图那个红圈画的地方，那个对象就是在并发清理期间，系统程序可能先把某些对象分配在新生代，然后可能触发了一次Minor GC，一些对象进入了老年代，然后短时间内又没人引用这些对象了。



这种对象，就是老年代的“**浮动垃圾**”。



因为他虽然成为了垃圾，但是CMS只能回收之前标记出来的垃圾对象，不会回收他们，需要等到下一次GC的时候才会回收他们。



所以为了保证在CMS垃圾回收期间，还有一定的内存空间让一些对象可以进入老年代，一般会预留一些空间。



CMS垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就自动执行GC。



“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。



也就是说，老年代占用了92%空间了，就自动进行CMS垃圾回收，预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。



那么如果CMS垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，此时会如何？



这个时候，会发生Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。



此时就会自动用“Serial Old”垃圾回收器替代CMS，就是直接强行把系统程序“Stop the World”，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生



然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。



所以在生产实践中，这个自动触发CMS垃圾回收的比例需要合理优化一下，避免“Concurrent Mode Failure”问题



**接下来我们会用两篇文章结合案例来分析垃圾回收参数的设置。**



**4、内存碎片问题**

之前给大家说过内存碎片的问题，就是老年代的CMS采用“标记-清理”算法，每次都是标记出来垃圾对象，然后一次性回收掉，这样会导致大量的内存碎片产生。



如果内存碎片太多，会导致后续对象进入老年代找不到可用的连续内存空间了，然后触发Full GC。



所以CMS不是完全就仅仅用“标记-清理”算法的，因为**太多的内存碎片实际上会导致更加频繁的Full GC。**



CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了



他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。



还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次Full GC之后都会进行一次内存整理。



如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96968400_1563871849.cn/txdocpic/0/e6acda9b7607ff721594ebb1483a2c4b/0)



上图有一个画红圈的地方，就是说在垃圾回收之后，有一些内存碎片，接着会停止工作线程进行碎片整理，如下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/6757300_1563871850.cn/txdocpic/0/dd350808f7139e4034a0c9a7c872ecdb/0)



大家可以看到，内存碎片整理完之后，存活对象都放在一起，然后空出来大片连续内存空间可供使用。



**5、昨日思考题解答**

昨天给大家出来一个思考题，意思是说，为啥老年代的Full GC要比新生代的Minor GC慢很多倍，一般在10倍以上？



其实原因很简单，大家分析一下他们俩的执行过程。



新生代执行速度其实很快，因为直接从GC Roots出发就追踪哪些对象是活的就行了，新生代存活对象是很少的，这个速度是极快的，不需要追踪多少对象。



然后直接把存活对象放入Survivor中，就一次性直接回收Eden和之前使用的Survivor了。



但是CMS的Full GC呢？



在并发标记阶段，他需要去追踪所有存活对象，老年代存活对象很多，这个过程就会很慢；



其次并发清理阶段，他不是一次性回收一大片内存，而是找到零零散散在各个地方的垃圾对象，速度也很慢；



最后完事儿了，还得执行一次内存碎片整理，把大量的存活对象给挪在一起，空出来连续内存空间，这个过程还得“Stop the World”，那就更慢了。



万一并发清理期间，剩余内存空间不足以存放要进入老年代的对象了，引发了“Concurrent Mode Failure”问题，那更是麻烦，还得立马用“Serial Old”垃圾回收器，“Stop the World”之后慢慢重新来一遍回收的过程，这更是耗时了。



所以综上所述，老年代的垃圾回收，就是一个字：慢



**6、今日思考题**

今天是一个小问题，让大家复习梳理一下，还记得说过几个触发老年代GC的时机吗？



**第一**是老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；



**第二**是老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；



**第三**是新生代Minor GC后的存活对象大于Survivor，那么就会进入老年代，此时老年代内存不足。



上述情况都会导致老年代Full GC。



今天加了一个触发时机，就是“-XX:CMSInitiatingOccupancyFaction”参数



刨除掉上述几种情况，如果老年代可用内存大于历次新生代GC后进入老年代的对象平均大小，但是老年代已经使用的内存空间超过了这个参数指定的比例，也会自动触发Full GC。



希望大家认真回顾一下上述过程，把老年代Full GC的几个时机都仔细梳理一下

# 025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化？

2019-07-25 07:00:00

**1、案例背景引入**

按照惯例，我们接下来会用案例驱动来带着大家分析到底该如何在特定场景下，预估系统的内存使用模型



然后合理优化新生代、老年代、Eden和Survivor各个区域的内存大小，接着再尽量优化参数避免新生代的对象进入老年代，尽量让对象留在新生代里被回收掉。



我们这里的背景是电商系统，电商系统其实一般会拆分为很多的子系统独立部署，比如商品系统、订单系统、促销系统、库存系统、仓储系统、会员系统，等等



我们这里就以比较核心的订单系统作为例子来说明。



我们的**案例背景**是每日上亿请求量的电商系统，那么大家可以来推算一下每日上亿请求量的电商系统，他会每日有多少活跃用户？



一般按每个用户平均访问20次来计算，那么上亿请求量，大致需要有500万日活用户。



那么继续来推算一下，这500万的日活用户都是会进来进行大量的浏览，那么多少人会下订单？



这里可以按照10%的付费转化率来计算，每天大概有50万人会下订单，那么大致就是每天会有50万订单。



这50万订单算他集中在每天4小时的高峰期内，那么其实平均下来每秒钟大概也就几十个订单，大家是不是觉得根本没啥可说的？



因为几十个订单的压力下，根本就不需要对JVM多关注，基本上就是每秒钟占用一些新生代内存，隔很久新生代才会满，然后一次Minor GC后垃圾对象清理掉，内存就空出来了，几乎无压力。



**2、特殊的电商大促场景**

但是如果你要是考虑到特殊的电商大促场景，就不会这么想了



因为很多中小型的电商平台，确实平时系统压力其实没那么大，也没太大的高并发，每秒几千并发压力就算是高峰压力了。



但是如果遇到一些大促场景，比如双11什么的，情况就不同了。



假设在类似双11的节日里，零点的时候，很多人等着大促开始就要剁手购物，这个时候，可能在大促开始的短短10分钟内，瞬间就会有50万订单。



那么此时每秒就会有接近1000的下单请求，我们就针对这种大促场景来对订单系统的内存使用模型分析一下。



**3、抗住大促的瞬时压力需要几台机器？**

那么要抗住大促期间的瞬时下单压力，订单系统需要部署几台机器呢？



基本上可以按3台来算，就是每台机器每秒需要抗300个下单请求。这个也是非常合理的，而且需要假设订单系统部署的就是最普通的标配4核8G机器。



从机器本身的CPU资源和内存资源角度，抗住每秒300个下单请求是没问题的。



但是问题就在于需要对JVM有限的内存资源进行合理的分配和优化，包括对垃圾回收进行合理的优化，让JVM的GC次数尽可能最少，而且尽量避免Full GC，这样可以尽可能减少JVM的GC对高峰期的系统新更难的影响。





**4、大促高峰期订单系统的内存使用模型估算**



背景已经全部说完了，接下来咱们就得来预估订单系统的内存使用模型了.



基本上可以按照每秒钟处理300个下单请求来估算，其实无论是订单处理性能还是并发情况，都跟生产很接近



因为处理下单请求是比较耗时的，涉及很多接口的调用，基本上每秒处理100~300个下单请求是差不多的。



那么每个订单咱们就按1kb的大小来估算，单单是300个订单就会有300kb的内存开销



然后算上订单对象连带的订单条目对象、库存、促销、优惠券等等一系列的其他业务对象，一般需要对单个对象开销放大10倍~20倍。



此外，除了下单之外，这个订单系统还会有很多订单相关的其他操作，比如订单查询之类的，所以连带算起来，可以往大了估算，再扩大10倍的量。



那么每秒钟会有大概300kb * 20 * 10 = 60mb的内存开销。但是一秒过后，可以认为这60mb的对象就是垃圾了，因为300个订单处理完了，所有相关对象都失去了引用，可以回收的状态。



大家看下图

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57897900_1563968637.cn/txdocpic/0/e91a8081686c199caff5d29cf115039c/0)



**5、内存到底该如何分配？**



假设我们有4核8G的机器，那么给JVM的内存一般会到4G，剩下几个G会留点空余给操作系统之类的来使用，不要想着把机器内存一下子都耗尽，其中堆内存我们可以给3G，新生代我们可以给到1.5G，老年代也是1.5G。



然后每个线程的Java虚拟机栈有1M，那么JVM里如果有几百个线程大概会有几百M



然后再给永久代256M内存，基本上这4G内存就差不多了。



同时还要记得设置一些必要的参数，比如说打开“-XX:HandlePromotionFailure”选项，JVM参数如下所示：（**不熟悉这个参数的，可以回头复习一下专栏之前的文章**）



“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure”



此时JVM内存入下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83101300_1563968637.cn/txdocpic/0/504965c0282fa452ef721de1939e2fd2/0)

接着就很明确了，订单系统的系统程序在大促期间不停的运行，每秒处理300个订单，都会占据新生代60MB的内存空间



但是1秒过后这60MB对象都会变成垃圾，那么新生代1.5G的内存空间大概需要25秒就会占满，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/9858900_1563968638.cn/txdocpic/0/cbe653478949e2ca88c8580c69cbdc4a/0)

25秒过后就会要进行Minor GC了，此时因为有“-XX:HandlePromotionFailure”选项，所以你可以认为需要进行的检查，主要就是比较 “老年代可用空间大小”和“历次Minor GC后进入老年代对象的平均大小”，刚开始肯定这个检查是可以通过的。



所以Minor GC直接运行，一下子可以回收掉99%的新生代对象，因为除了最近一秒的订单请求还在处理，大部分订单早就处理完了，所以此时可能存活对象就100MB左右。



但是这里问题来了，如果“-XX:SurvivorRatio”参数默认值为8，那么此时新生代里Eden区大概占据了1.2GB内存，每个Survivor区是150MB的内存，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/32386900_1563968638.cn/txdocpic/0/96db2d2d503736d394249286b5ad9601/0)

所以Eden区1.2GB满了就要进行Minor GC了，因此大概只需要20秒，就会把Eden区塞满，就要进行Minor GC了。



然后GC后存活对象在100MB左右，会放入S1区域内。如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52810900_1563968638.cn/txdocpic/0/69af51522556e6c9fccc3e3e3915a5fa/0)



然后再次运行20秒，把Eden区占满，再次垃圾回收Eden和S1中的对象，存活对象可能还是在100MB左右会进入S2区，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/69575800_1563968638.cn/txdocpic/0/524be07e39784fbe670f1e2cbeaf4e33/0)



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8”



**6、新生代垃圾回收优化之一：Survivor空间够不够**



首先在进行JVM优化的时候，第一个要考虑的问题，就是你通过估算，你的新生代的Survivor区到底够不够



按照上述逻辑，首先每次新生代垃圾回收在100MB左右，有可能会突破150MB，那么岂不是经常会出现Minor GC过后的对象无法放入Survivor中？然后岂不是频繁会让对象进入老年代？



还有，即使Minor GC后的对象少于150MB，但是即使是100MB的对象进入Survivor区，因为这是一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代。

（**关于jvm的垃圾回收规则，如果忘记了的同学，请参加专栏之前的文章**）



所以其实按照我们这个模型来说，Survivor区域是明显不足的。



这里其实建议的是调整新生代和老年代的大小，因为这种普通业务系统，明显大部分对象都是短生存周期的，根本不应该频繁进入老年代，也没必要给老年代维持过大的内存空间，首先得先让对象尽量留在新生代里。



所以此时可以考虑把新生代调整为2G，老年代为1G，那么此时Eden为1.6G，每个Survivor为200MB，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89940600_1563968638.cn/txdocpic/0/b3309cff7a4dcf9f150623d0edea5432/0)



这个时候，Survivor区域变大，就大大降低了新生代GC过后存活对象在Survivor里放不下的问题，或者是同龄对象超过Survivor 50%的问题。



这样就大大降低了新生代对象进入老年代的概率。



此时JVM的参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8”



其实对任何系统，首先类似上文的内存使用模型预估以及合理的分配内存，尽量让每次Minor GC后的对象都留在Survivor里，不要进入老年代，这是你首先要进行优化的一个地方。



**7、新生代对象躲过多少次垃圾回收后进入老年代？**



大家都知道，除了Minor GC后对象无法放入Survivor会导致一批对象进入老年代之外，还有就是有些对象连续躲过15次垃圾回收后会自动升入老年代。



其实按照上述内存运行模型，基本上20多秒触发一次Minor GC，那么如果按照“-XX:MaxTenuringThreshold”参数的默认值15次来说，你要是连续躲过15次GC，就是一个对象在新生代停留超过了几分钟了，此时他进入老年代也是应该的。



有些博客会说，应该提高这个参数，比如增加到20次，或者30次，其实那种说法根本是不对的



因为你对这个参数考虑必须结合系统的运行模型来说，如果躲过15次GC都几分钟了，一个对象几分钟都不能被回收，说明肯定是系统里类似用@Service、@Controller之类的注解标注的那种需要长期存活的核心业务逻辑组件。



那么他就应该进入老年代，何况这种对象一般很少，一个系统累计起来最多也就几十MB而已。



所以你说你提高“-XX:MaxTenuringThreshold”参数的值，有啥用呢？让这些对象在新生代里多停留几分钟？



所以说，考虑问题，一定不要人云亦云，要结合运行原理，自己推演和思考，不同的业务系统还都是不一样的。



其实这个参数甚至你都可以降低他的值，比如降低到5次，也就是说一个对象如果躲过5次Minor GC，在新生代里停留超过1分钟了，尽快就让他进入老年代，别在新生代里占着内存了。



总之，对于这个参数务必是结合你的系统具体运行的模型来考虑。



要记住，JVM没有万能的最佳参数，但是有一套通用的分析和优化的方法。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5”



**8、多大的对象直接进入老年代？**



另外有一个逻辑是说，大对象可以直接进入老年代 ，因为大对象说明是要长期存活和使用的



比如在JVM里可能会缓存一些数据，这个一般可以结合自己系统中到底有没有创建大对象来决定。



但是一般来说，给他设置个1MB足以，因为一般很少有超过1MB的大对象。如果有，可能是你提前分配了一个大数组、大List之类的东西用来放缓存的数据。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M”



**9、别忘了指定垃圾回收器**



同时大家别忘了要指定垃圾回收器，新生代使用ParNew，老年代使用CMS，如下JVM参数 ：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”



ParNew垃圾回收器的核心参数，其实就是配套的新生代内存大小、Eden和Survivor的比例，只要你设置合理，避免Minor GC后对象放不下Survivor进入老年代，或者是动态年龄判定之后进入老年代，给新生代里的Survivor充足的空间，那么Minor GC一般就没什么问题。



同时记得把“XX:HandlePromotionFailure”打开，允许老年代空间担保，避免老年代空间小于新生代全部对象大小就触发Full GC。



然后根据你的系统运行模型，合理设置“-XX:MaxTenuringThreshold”，让那些长期存活的对象，抓紧尽快进入老年代，别在新生代里一直待着。



这样基本上一个初步的优化好的JVM参数就结合你的业务出来了。明天我们继续结合案例来分析 老年代的垃圾回收和参数优化方式。



**10、昨日思考题**



上次让大家梳理了一下**触发Full GC的几个时机**，大家一定要好好梳理一下。



**11、今日思考题**



大家看完这个案例，可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小



然后去估算一下你的系统运行模型：



- 每秒占用多少内存？
- 多长时间触发一次Minor GC？
- 一般Minor GC后有多少存活对象？
- Survivor能放的下吗？
- 会不会频繁因为Survivor放不下导致对象进入老年代？
- 会不会因动态年龄判断规则进入老年代？



# 026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参数又该如何优化呢？

2019-07-26 07:00:00

**1、前文回顾**



上一篇文章我们已经给大家介绍了一个每日百万日活以及上亿请求量的电商系统的案例背景，同时采用这个中型电商系统在大促期间的瞬时高峰下单场景，作为我们的JVM优化分析的一个场景，推测出来在大促高峰期，每秒每台机器会有300个下单请求。



进而推测出每秒钟会使用60MB的内存，然后根据这个背景推算出来了我们一台4核8G的机器上，应该如何合理的给JVM各个区域分配内存



进而可以保证每隔20多秒一次新生代GC后的100MB左右的存活对象，会进入200MB的Survivor区域内，一般不会因为Survivor塞不下或者是动态年龄判定规则让对象进入老年代中。



同时还根据Minor GC的频率，合理降低了大龄对象进入老年代的年龄，尽快让一些长期存活的对象赶紧进入老年代，不要停留在新生代里，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56510800_1564059685.cn/txdocpic/0/85fcb4db20b84da5d73133db6eb1d23d/0)



此时的JVM参数如下所示：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”



**2、在案例背景下什么时候对象会进入老年代？**



接着我们来分析一个问题，在目前优化好的背景下，一般什么情况下会让一些对象进入老年代呢？



首先第一种情况，那绝对就是“-XX:MaxTenuringThreshold=5”这个参数会让在一两分钟内连续躲过5次Minor GC的对象迅速进入老年代中。



这种对象一般就是一些@Service、@Controller之类的注解标注的那种系统业务逻辑组件，这种对象实例一般全局就有一个实例就可以了，要一直使用的



所以一般会长期被GC Roots引用，这种对象一般不会太多，大概最多一个系统就几十MB这种对象。



所以此时类似这样的长期存活的对象就会进入老年代中，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74684000_1564059685.cn/txdocpic/0/ec81e44bc63aa7026267de3628582132/0)

此外，按照我们的JVM参数，如果分配一个超过1MB的大对象，比如说你创建一个大数组或者是大List之类的，就会直接进入老年代。



但是这种大对象我们假设在这个案例里是没有的，所以可以忽略不计。



此外就是Minor GC过后可能存活的对象超过200MB放不下Survivor了，或者是一下子占到超过Surviovr的50%，此时会有一些对象进入老年代中。



但是我们之前对新生代的JVM参数进行优化，就是为了避免这种情况，经过我们的测算，这种概率应该是很低的。



但是虽说是很低，也不能完全是是没有这种情况，比如某一次GC过后可能刚好机缘巧合有超过200MB对象，就会进入老年代里。



我们可以做一个假设，大概就是这个订单系统在大促期间，每隔5分钟会在Minor GC之后有一小批对象进入老年代，大概200MB左右的大小，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99821100_1564059685.cn/txdocpic/0/7f5c4c49a7f38cf63684a0bd0ac73246/0)



**3、大促期间多久会触发一次Full GC？**

接着我们来研究一下，那么按照Full GC的触发条件，多久会触发一次Full GC？



首先来看看，Full GC的触发条件目前我们学习到的有以下4种：



（1）没有打开“ -XX:HandlePromotionFailure”选项，结果老年代可用内存最多也就1G，新生代对象总大小最多可以有1.8G



那么会导致每次Minor GC前一检查，都发现“老年代可用内存” < “新生代总对象大小”，这会导致每次Minor GC前都触发Full GC。



当然，上篇文章提到过了，现在JDK 1.6以后的版本废弃了这个参数，其实只要满足下面第二个条件就可以直接触发Minor GC，不需要触发Full GC。



（2）每次Minor GC之前，都检查一下“老年代可用内存空间” < “历次Minor GC后升入老年代的平均对象大小”



其实按照我们目前设定的背景，要很多次Minor GC之后才可能有一两次碰巧会有200MB对象升入老年代，所以这个“历次Minor GC后升入老年代的平均对象大小”，基本是很小的。



（3）可能某次Minor GC后要升入老年代的对象有几百MB，但是老年代可用空间不足了



（4）设置了“-XX:CMSInitiatingOccupancyFaction”参数，比如设定值为92%，那么此时可能前面几个条件都没满足，但是刚好发现这个条件满足了，比如就是老年代空间使用超过92%了，此时就会自行触发Full GC



其实在真正的系统运行期间，可能会慢慢的有对象进入老年代，但是因为新生代我们优化过了内存分配，所以对象进入老年代的速度是很慢的。



所以很可能是在系统运行半小时~1小时之后，才会有接近 1GB的对象进入老年代。



此时可能会因为上述的条件234中任何一个满足了，就触发Full GC。



但是这三个条件一般都需要老年代近乎占满的时候，才有可能会触发。



大家可以思考一下，我们假设在大促期间，订单系统运行1小时之后，大促下单高峰期几乎都快过了，此时才可能会触发一次Full GC。



注意，**这个推论很重要**，因为按照大促开始10分钟就有50万订单来计算，其实大促开始后一堆用户等着下单剁手购物



那么1小时候就可能有两三百万订单了，这是一年难得罕见的节日大促才会有的，然后这个高峰期过后，基本订单系统访问压力就很小了，那么GC的问题几乎就更不算什么了。



所以经过新生代的优化，可以推算出，基本上大促高峰期内，也就可能1小时才1次Full GC，然后高峰期一过，随着订单系统慢慢运行，可能就要几个小时才有一次Full GC。



**4、老年代GC的时候会发生“Concurrent Mode Failure”吗？**

经过前面的推算，我们基本可知道，假设就是订单系统运行1小时之后，老年代大概有900MB的对象了，剩余可用空间仅仅只有100MB了，此时就会触发一次Full GC，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21588300_1564059686.cn/txdocpic/0/22e96a4c676b738628bc2f7008e1367a/0)

但是有一个很大的问题，就是CMS在垃圾回收的时候，尤其是并发清理期间，系统程序是可以并发运行的，所以此时老年代空闲空间仅剩100MB了



然后此时系统程序还在不停的创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代，此时会如何？



如下图

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47901200_1564059686.cn/txdocpic/0/ccedf85c20a35383a69442daea74afe3/0)

这个时候就会触发“**Concurrent Mode Failure**”问题，因为此时老年代没有足够内存来放这200MB对象，此时就会导致立马进入Stop the World，然后切换CMS为Serial Old，直接禁止程序运行，然后单线程进行老年代垃圾回收，回收掉900MB对象过后，再让系统继续运行，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/77713000_1564059686.cn/txdocpic/0/1f36c8ae27b01d5e2c405cc83b4f7c41/0)



所以可以想一下，这种情况可能发生吗？



概率是挺小的，因为必须是CMS触发Full GC的时候，系统运行期间还让200MB对象进入老年代，这个概率其实本身就很小，但是理论上是有可能的。



大家此时需要思考一下，相对于这种小概率的事件而言，有必要去调整参数吗？



暂时看来是没有必要的，不需要针对小概率事件特意优化参数。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92”



**5、CMS垃圾回收之后进行内存碎片整理的频率应该多高？**

接着来看最后一个问题，在CMS完成Full GC之后，一般需要执行内存碎片的整理，可以设置多少次Full GC之后执行一次内存碎片整理，但是我们有必要修改这些参数吗？



其实没必要，因为通过前面的分析，在大促高峰期，Full GC可能也就1小时执行一次，然后大促高峰期过去之后，就没那么多的订单了，此时可能几个小时才会有一次Full GC。



所以就保持默认的设置，每次Full GC之后都执行一次内存碎片整理就可以，目前JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”



其实从本文可以看到，Full GC优化的前提是Minor GC的优化，Minor GC的优化的前提是合理分配内存空间，合理分配内存空间的前提是对系统运行期间的内存使用模型进行预估。



其实对很多普通的Java系统而言，只要对系统运行期间的内存使用模型做好预估，然后分配好合理的内存空间，尽量让Minor GC之后的存活对象留在Survivor里不要去老年代，然后其余的GC参数不做太多优化，系统性能基本上就不会太差。



**6、昨日思考题**

昨天让大家可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小



然后去估算一下你的系统运行模型，每秒占用多少内存，多长时间触发一次Minor GC，一般Minor GC后有多少存活对象，Survivor能放的下吗？会不会频繁因为Survivor放不下导致对象进入老年代？会不会因动态年龄判断规则进入老年代？



希望大家好好吸收这里的精华，真正能够从业务系统运行的层面以及内存使用模型的层面去看你的各种JVM参数在系统运行期间起到的作用。



**7、今日思考题**

今天的思考题跟昨天是一样的，大家去思考一下，对你的系统运行模型做出预估，看一般多久会塞满老年代触发Full GC？触发Full GC的时候是否需要优化CMS相关的各种参数？