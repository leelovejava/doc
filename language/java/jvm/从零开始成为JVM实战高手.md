# 从零开始成为JVM实战高手

https://pc-shop.xiaoe-tech.com/apppuKyPtrl1086/columnist_detail?id=p_5d0ef9900e896_MyDfcJi8

# 000、目录

![0001.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99095400_1561716166.jpg)

![0002.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54065200_1561716172.jpg)

![0003.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65007000_1561716176.jpg)



![0004.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27755400_1561716180.jpg)

![0005.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15382100_1561716185.jpg)

![0006.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96144100_1561716189.jpg)

![0007.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/16578000_1561716193.jpg)

![0008(7~10).jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27893700_1561716197.jpg)

![0009(11~12).jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60352200_1561716200.jpg)

![0010(13~15).jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56900_1561716204.jpg)

![0012](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26540400_1561716214.jpg)

![0013](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60747000_1561716221.jpg)

![0014](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/88792600_1561716225.jpg)

# 001、开篇词：JVM优化实战，广大Java工程师心中永远的痛！

2019-06-23 12:15:22

**开篇词：**

**JVM优化实战，广大Java工程师心中永远的痛！**



平时很多朋友跑来找我问以下一些类似的问题：

1. 线上用Dubbo开发的一个系统突然卡死了，JVM FullGC太频繁，求救！

   

   

2. 生产环境部署的一个系统隔几天就莫名其妙的进程崩溃，看了眼异常信息，说是OOM内存溢出，如何解决？在线等，急！

3. 出去面试，光是说一些JVM的内存模型、垃圾回收算法，不够啊！

   面试官怎么老是盯着我问生产环境遇到的JVM问题，各种参数的优化之类的，完全没经历过



类似的问题听的多了，我发现目前国内大多数Java工程师都面临一个共同的问题。



即对JVM的了解仅停留于书本和理论知识，而对JVM生产环境中的实战优化几乎一无所知。



有的朋友是一直开发那种几十个人使用的内部系统，所以没机会接触和经历。有的朋友是突然遇到线上JVM生产事故，毫无头绪。



为什么会造成这类现状呢？



答案其实也很简单，目前国内JVM相关的学习资料主要是两类：

- 一种是一些JVM大牛作者写的书籍
- 一种是网上大量凌乱繁杂的JVM实践博客。



对于JVM大牛写的一些书籍，其实都是很好的一些资料。但是书的本意并不是提供给你实战经验。



书的作用是站在理论知识总结和梳理的角度，把一个完整的理论知识体系呈现给你。



因此，从书上学到的也主要是体系化的理论知识。



而且虽然很多书籍的作者技术功底极为深厚，但是书里的内容非常的深奥晦涩，难以理解。



导致很多人即使是这种JVM的理论知识，也仅仅是吸收了里面可能就10%的精华，其他的也没法消化理解。



更重要的，从书本中，也更不可能获得JVM生产故障的实践经验和解决方案。



然后就是网上大量凌乱繁杂的JVM相关博客，很多作者其实确实是在记录自己遇到的一些JVM的生产故障的解决过程。



但是问题在于，博客往往是作者自己记录的r经历，面向的是自己，一切站在自己的角度出发。



而对于这个项目的背景、线上多大用户量、多少数据量、多大并发量、核心业务流程，在什么生产场景下发生的问题？**啥都没有！**



此外，对解决问题过程中涉及到的一些JVM底层原理，很多作者也不会说明白。



这就导致很多读者看博客，根本看不懂，搞不明白为什么会发生这个问题，搞不明白解决这个JVM生产故障背后的原理是什么！



**一句话总结**：放眼望去，目前国内并没有一个真正系统化讲解**JVM生产实战**的技术资料！



正是这个原因，导致了大量的Java工程师内心中对“**JVM实战**”这块内容有很大的痛点。



造成的直接后果就是遇到JVM生产事故不知道怎么处理和解决，出去面试被人问JVM生产实践毫无头绪！



因此我针对这些痛点，推出了**《**从零开始带你成为JVM实战高手**》**专栏。



这个专栏将作为一座桥梁，我将通过它，将我十余年线上处理JVM生产事故的经验，浓缩精华，传授给你。



考虑到目前国内大部分java程序员的JVM学习现状，这个专栏从设计时，就完全从两个角度出发：

- JVM理论知识从0起步，基于大量手绘图，保证让小白都能看懂

  

- 全程专注于JVM生产实践，主要解决JVM生产环境的参数优化，JVM GC问题和JVM OOM问题的处理



下面详细说一下上述两点：

1. 对于JVM必不可少的内存模型、类加载、垃圾回收等核心理论知识，我会采用几乎一步一图的方式进行讲解。

   另外配合上通俗易懂的大白话描述，带着大家彻底搞明白JVM底层的一些原理性知识

   JVM理论知识**讲解标准**：哪怕是对JVM完全不了解的小白同学，也一定能看得懂、学得会！

2. 然后重点，则完全放在“**实战**”二字。整个专栏一共有30多个真实的生产案例，都是我多年带团队负责的各种系统中出现和遇到的JVM生产问题，比如：

3. - 每日百万交易的支付系统的JVM生产参数优化
   - 每日上亿请求量的电商系统的GC参数优化
   - 百万级用户的在线教育平台的G1垃圾回收优化
   - 更不用说每秒10万并发的BI系统、每日百亿数据量的处理系统、视频系统、大促系统等各类系统中的JVM GC问题和JVM OOM问题的生产优化



更重要的一点，每个案例绝对**站在一个读者的角度**出发，也就是从业务背景出发。



案例中会包含这个系统的用户量、并发量、数据量以及核心业务流程，进而给出发生生产故障的真实场景



然后是一步一步如何分析、排查和定位每个问题的，包括解决问题的过程中涉及到的底层JVM原理的剖析。



我的思路，就是用大量的生产案例贯穿整个专栏，进而教给大家遇到JVM生产事故时一个常规性的定位排查、分析解决问题的思路和方法



同时通过大量真实案例的演练，让大家直接积累起丰富的生产故障排查经验



此外，在专栏中还有大量的动手实验的环节，会设计很多的实验，大家只要照着做，就可以体验到各种JVM生产问题的现场。



然后再自己一步步去进行监控、分析日志，这样可以很好的锻炼大家的动手实践能力。



而且在每周我都会留下很多作业，作业会引导你去思考你手头负责的系统。



假设你的并发量、数据量扩大100倍，你会不会遇到JVM问题？如果在你的系统中遇到问题，你该怎么来处理和解决？



通过这类作业，目的就是引导大家思考如何将学习到的各种实战技能进行落地，让自己真正掌握。



通过这样的一个JVM实战专栏的学习，我相信每个认真跟着学习下来的Java工程师，都能够拥有如下的能力：

- 对自己负责的线上系统，可以进行生产环境的JVM参数优化
- 线上遇到生产故障，自己绝对有思路去进行分析、排查和定位
- 你会清楚怎么去动手实践，明白背后的JVM的底层原理
- 此外，你通过课程积累好的几十个案例的经验，也将支撑你去对各种不同的生产故障进行解决和处理



另外专栏还会贯穿大量的**大厂JVM面试题剖析**，因此在学习完专栏过后，大家出去面试，无论是JVM的原理，还是JVM的生产实践，国内没有公司面得倒你。



最后，从这篇文章开始，咱们即将一起走过15周的学习旅程。希望15周之后，这里的每个同学都能从0开始，成为一个JVM实战高手！



**End**



# 002、一探究竟：我们写的Java代码到底是如何运行起来的？

2019-06-23 14:08:45

**一探究竟：**

**我们的Java代码到底是如何运行起来的？**

本文是我们正式开始讲解JVM的第一篇文章。

第一周我们不会讲解太多过于深奥的原理知识，那样会让很多原本对JVM不太了解的同学难以平滑的入门。

第一周的内容主要是高屋建瓴的把JVM运行机制的整体脉络梳理清楚，而很多原本对JVM就有一定了解的同学，可以耐下心来，就当做是复习梳理一下。

要研究JVM技术，先得搞明白一个问题：

- **我们平时写的Java代码，到底是怎么运行起来的？**

针对这个问题，我们来一步一步的分析。

首先假设咱们写好了一份Java代码，那这份Java代码中，是不是会包含很多的“.java”为后缀的代码文件？

比如User.java，OrderService.java，CustomerManager.java

其实咱们Java程序员平时在Eclipse、Intellij IDEA等开发工具中，就有很多类似这样的Java源代码文件。

那么大家现在思考一下，当我们写好这些“.java”后缀的代码文件之后，接下来你要部署到线上的机器上去运行，你会怎么做？

一般来说，都是把代码给打成“.jar”后缀的jar包，或者是“.war”后缀的war包，是不是？

然后呢，就是把你打包好的jar包或者是war包给放到线上机器去部署。

这个部署就有很多种途径了，但是最基本的一种方式，就是通过Tomcat这类容器来部署代码，也可以是你自己手动通过“java”命令来运行一个jar包中的代码。

咱们先用下面这张图，回忆一下这个顺序。

![01_打包.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60992200_1561998556.png)



但是实际上这里有一个非常关键的步骤，那就是“**编译**”

也就是说，在我们写好的“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件，比如“User.class”，“Hello.class”，”Customer.class“。

然后这个“.class”后缀的字节码文件，他才是可以被运行起来的！

所以首先，无论大家对JVM机制是否熟悉，咱们都先来回顾一下这个编译的过程，以及“.class”字节码文件的概念。

来看看下图，一起来感受一下：

![02_编译.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85310300_1561998556.png)

接着我们可能就要思考下一个问题：

对于编译好的这些“.class”字节码，是怎么让他们运行起来的呢？

这个时候就需要使用诸如“java -jar”之类的命令来运行我们写好的代码了。

此时一旦你采用“java”命令，实际上此时就会启动一个JVM进程。

这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

所以平时我们写好的某个系统在一台机器上部署的时候，你一旦启动这个系统，其实就是启动了一个JVM，由它来负责运行这台机器上运行的这个系统。

对这个概念，大家一定要先搞清楚。

我们还是用一张图来展示一下，相信大家图文结合，会理解的更好。

![03_jvm.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3266600_1561998557.png)



接着下一步，JVM要运行这些“.class”字节码文件中的代码，那是不是首先得把这些“.class”文件中包含的各种类给加载进来？

这些“.class”文件不就是我们写好的一个一个的类吗？对不对？

此时就会有一个“**类加载器**”的概念。

此时会采用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

我们再看下图。

![04_类加载.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13473300_1561998557.png)



接着，最后一步，JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了

比如你的代码中有一个“main()”方法，那么JVM就会从这个“main()”方法开始执行里面的代码。

他需要哪个类的时候，就会使用类加载器来加载对应的类，反正对应的类就在“.class”文件中。

大家最后看看下面的图。

![05_执行代码.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24399300_1561998557.png)

好，最后我们来对本文小结一下：

无论是对JVM了解或者是不了解的同学，我们都希望通过第一周的基本原理知识讲解，降低学习后面JVM优化实战技术的门槛。

对于了解JVM的同学权当复习梳理，而且鼓励大家在底部评论发言，说说自己的理解和看法。

对于不太了解JVM的小白同学，也可以抄底门槛迅速入门，无缝衔接后续的知识学习。

所以本文从我们平时写“.java”后缀的源代码开始，一步一步梳理了以下的流程：

- 写好的代码编译成“.class”后缀的字节码文件
- JVM是个什么东西
- JVM跟我们平时运行在机器上的系统之间是什么关系
- 类加载器的概念
- 针对加载进内存的类进行代码的执行

这就是本文讲解的内容总结，希望大家对这部分内容高屋建瓴的先有一个认识。

另外，最后我给大家留一个思考题：既然“.java”文件可以编译成“.class”文件再运行，那么也肯定可以将“.class”文件反编译成“.java”文件。

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

大家可以思考思考，踊跃提问和发言，明天的文章里，在末尾我会跟大家探讨一下这个问题。

**End**



# 003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？

2019-06-23 14:31:28

**面试官对于JVM类加载机制的猛烈炮火，****你能顶住吗？**



**目录：**

1. 前文回顾
2. JVM在什么情况下会加载一个类？
3. 从实用角度出发，来看看验证、准备和初始化的过程
4. 核心阶段：初始化
5. 类加载器和双亲委派机制
6. 昨日思考题的解答





**1、前文回顾**

咱们今天先来回顾一下昨天讲到的JVM整体的一个运行原理。

我们首先从“.java”代码文件，编译成“.class”字节码文件

然后类加载器把“.class”字节码文件中的类给加载到JVM中

接着是JVM来执行我们写好的那些类中的代码，整体是这么个顺序。

再看看下图，感受一下这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67189100_1562062006.cn/txdocpic/0/85881164faa1fa93a71120127057d4c3/0)

那么今天，我们就来仔细看看上图中的“**类加载**”这个过程，看看JVM的类加载机制到底是怎么样的？

搞清楚这个过程了，那么以后在面试时，对面试官常问的JVM类加载机制，就能把一些核心概念说清楚了。



**2、JVM在什么情况下会加载一个类？**

其实类加载过程非常的琐碎复杂，但是对于我们平时从工作中实用的角度来说，主要是把握他的核心工作原理就可以。

一个类从加载到使用，一般会经历下面的这个过程：

**加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载**

所以首先要搞明白的第一个问题，就是JVM在执行我们写好的代码的过程中，一般在什么情况下会去加载一个类呢？

也就是说，啥时候会从“.class”字节码文件中加载这个类到JVM内存里来。

其实答案非常简单，就是在**你的代码中用到这个类的时候**。

举个简单的例子，比如下面你有一个类（Kafka.class），里面有一个“main()”方法作为主入口。

那么一旦你的JVM进程启动之后，它一定会先把你的这个类（Kafka.cass）加载到内存里，然后从“main()”方法的入口代码开始执行。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/81370700_1562062006.png)



我们还是坚持一步一图，大家先看看下图，感受一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99941000_1562062006.cn/txdocpic/0/20b99ce2902c58d0a246861f046cc402/0)

接着假设上面的代码中，出现了如下的这么一行代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/16673900_1562062007.png)



这时可能大家就想了，你的代码中明显需要使用“ReplicaManager”这个类去实例化一个对象，此时必须得把“ReplicaManager.class”字节码文件中的这个类加载到内存里来啊！是不是？

所以这个时候就会触发JVM通过类加载器，从“ReplicaManager.class”字节码文件中加载对应的类到内存里来使用，这样代码才能跑起来。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/34835300_1562062007.cn/txdocpic/0/8a2acdae659f69979687cafb5470e80a/0)

上面就是给大家举的一个例子，相信非常的通俗易懂。

简单概括一下：首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。



**3、从实用角度出发，来看看验证、准备和初始化的过程**

其实上面的类加载时机的问题，对于很多有经验的同学来说不是什么问题。

但是对于很多初学者来说，是一个非常重要的需要捋清的概念。

接下来就来简单带着大家，从实用的角度出发，过一下另外三个概念：

**验证、准备、初始化**

其实对于这三个概念，没太大的必要去深究里面的细节，这里的细节很多很繁琐，对于大部分同学而言，只要脑子里有下面的几个概念就可以了：

**（1）验证阶段**

简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。

这个相信很好理解，假如说，你的“.class”文件被人篡改了，里面的字节码压根儿不符合规范，那么JVM是没法去执行这个字节码的！

所以把“.class”加载到内存里之后，必须先验证一下，校验他必须完全符合JVM规范，后续才能交给JVM来运行。

下面用一张图，展示了这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47365600_1562062007.cn/txdocpic/0/9b5b706b0486cce3c20e53cc2d13cd07/0)

**（2）准备阶段**

这个阶段其实也很好理解，咱们都知道，我们写好的那些类，其实都有一些类变量

比如下面的这个“ReplicaManager”类：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/71602900_1562062007.png)

假设你有这么一个“ReplicaManager”类，他的“ReplicaManager.class”文件内容刚刚被加载到内存之后，会进行验证，确认这个字节码文件的内容是规范的

接着就会进行准备工作。

这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间

然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值

比如上面的示例里，就会给“flushInterval”这个类变量分配内容空间，给一个“0”这个初始值。

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83060200_1562062007.cn/txdocpic/0/c9f43e3b1451aa91cfbfb8a7b6abad30/0)



**（3）解析阶段**

这个阶段干的事儿，实际上是把**符号引用替换为直接引用**的过程，其实这个部分的内容很复杂，涉及到JVM的底层

但是注意，同学们，就我本意而言，希望第一周的文章，绝对是浅显易懂的，循序渐进，要保证每个同学都能绝对看懂。

所以针对这个阶段，现在不打算做过深的解读，因为从实用角度而言，对很多同学在工作中实践JVM技术其实也用不到，所以这里大家就暂时知道有这么一个阶段就可以了。

同样，我还是给大家画图展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96343600_1562062007.cn/txdocpic/0/34ebc43cda680141456638ca4963e770/0)

**（4）三个阶段的小结**

其实这三个阶段里，最核心的大家务必关注的，就是**“准备阶段”**

因为这个阶段是给加载进来的类分配好了内存空间，类变量也分配好了内存空间，并且给了默认的初始值，这个概念，大家心里一定要有。



**4、核心阶段：初始化**

之前说过，在准备阶段时，就会把我们的“ReplicaManager”类给分配好内存空间

另外他的一个类变量“flushInterval”也会给一个默认的初始值“0”，那么接下来，在初始化阶段，就会正式执行我们的类初始化的代码了。

那么什么是类初始化的代码呢？我们来看看下面这段代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8399800_1562062008.png)

大家可以看到，对于“flushInterval”这个类变量，我们是打算通过Configuration.getInt("replica.flush.interval")这段代码来获取一个值，并且赋值给他的

但是在准备阶段会执行这个赋值逻辑吗？

**NO！**在准备阶段，仅仅是给“flushInterval”类变量开辟一个内存空间，然后给个初始值“0”罢了。

那么这段赋值的代码什么时候执行呢？答案是在**“初始化”**阶段来执行。

在这个阶段，就会执行类的初始化代码，比如上面的  Configuration.getInt("replica.flush.interval")  代码就会在这里执行，完成一个配置项的读取，然后赋值给这个类变量“flushInterval”。

另外比如下图的static静态代码块，也会在这个阶段来执行。

类似下面的代码语义，可以理解为类初始化的时候，调用“loadReplicaFromDish()”方法从磁盘中加载数据副本，并且放在静态变量“replicas”中：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24615100_1562062008.png)

那么搞明白了类的初始化是什么，就得来看看类的初始化的规则了。

**什么时候会初始化一个类？**

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41037200_1562062008.png)

如果你要“new ReplicaManager()”初始化这个类的实例，那么会加载这个类，然后初始化这个类

但是初始化这个类之前，发现AbstractDataManager作为父类还没加载和初始化，那么必须先加载这个父类，并且初始化这个父类。

这个规则，大家必须得牢记，再来一张图，借助图片来进行理解：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53805800_1562062008.cn/txdocpic/0/605fa929375991cb7645c28f8f815b0f/0)



**5、类加载器和双亲委派机制**

现在相信大家都搞明白了整个类加载从触发时机到初始化的过程了，接着给大家说一下类加载器的概念

因为实现上述过程，那必须是依靠类加载器来实现的

那么Java里有哪些类加载器呢？简单来说有下面几种：

**（1）启动类加载器**

**Bootstrap ClassLoader**，他主要是负责加载我们在机器上安装的Java目录下的核心类的

相信大家都知道，如果你要在一个机器上运行自己写好的Java系统，无论是windows笔记本，还是linux服务器，是不是都得装一下JDK？

那么在你的Java安装目录下，就有一个“**lib**”目录，大家可以自己去找找看，这里就有Java最核心的一些类库，支撑你的Java系统的运行。

所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

**（2）扩展类加载器**

**Extension ClassLoader**，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

那么你的JVM一旦启动，是不是也得从Java安装目录下，加载这个“lib\ext”目录中的类？

**（3）应用程序类加载器**

**Application ClassLoader**，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类

其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

**（4）自定义类加载器**

除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

**（5）双亲委派机制**

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65579400_1562062008.cn/txdocpic/0/932fe13b12b449c8a97fc42e6029b613/0)

然后，基于这个亲子层级结构，就有一个**双亲委派的机制**

什么意思呢？

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

听完了上面一大堆绕口令，是不是很迷茫？别着急，咱们用一个例子来说明一下。

比如你的JVM现在需要加载“ReplicaManager”类，此时应用程序类加载器会问问自己的爸爸，也就是扩展类加载器，你能加载到这个类吗？

然后扩展类加载器直接问自己的爸爸，启动类加载器，你能加载到这个类吗？

启动类加载器心想，我在Java安装目录下，没找到这个类啊，**自己找去**！

然后，就下推加载权利给扩展类加载器这个儿子，结果扩展类加载器找了半天，也没找到自己负责的目录中有这个类。

这时他很生气，说：明明就是你应用程序加载器自己负责的，你自己找去。

然后应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。

这就是所谓的**双亲委派模型：**先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。

最后，给大家来一张图图，感受一下类加载器的双亲委派模型。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79558100_1562062008.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**6、昨日思考题的解答**

好！今天的文章看完了，相信大家就能大致推测出昨日的思考题的答案了。

我昨天的问题是：如何对“.class”文件处理保证不被人拿到以后反编译获取公司源代码？

其实认真看完今天的文章，就很简单了。

首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理

现在有很多第三方公司，都是专门做商业级的字节码文件加密的，所以可以付费购买他们的产品。

然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人窃取。

**7、今日思考题**

今天再给大家留一个思考题，相信每个做Java的同学，都知道现在一般用Java开发的Web系统，除非是基于Java写中间件，一般都是采用Tomcat之类的Web容器来部署的。

那么大家想想，Tomcat本身就是用Java写的，他自己就是一个JVM。

我们写好的那些系统程序，说白了，就是一堆编译好的.class文件放入一个war包，然后在Tomcat中来运行的。

那么，Tomcat的类加载机制应该怎么设计，才能把我们动态部署进去的war包中的类，加载到Tomcat自身运行的JVM中，然后去执行那些我们写好的代码呢？

大家先思考，明天文末会给大家进行梳理并给出答案。

**End**



# 004、大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的？

2019-06-23 14:34:05

**大厂面试题**

**JVM中有哪些内存区域，分别是用来干嘛的？**



目录：

1. 前文回顾
2. 大厂面试背景引入
3. 到底什么是JVM的内存区域划分？
4. 存放类的方法区
5. 执行代码指令用的程序计数器
6. Java虚拟机栈
7. Java堆内存
8. 核心内存区域的全流程串讲
9. 其他内存区域
10. 本文小结
11. 昨日思考题解答
12. 今日思考题



**1、前文回顾**

上一篇文章我们聊了一下JVM类加载这块的机制，先简单回顾一下。

大家需要搞明白的是，在什么情况下会触发类的加载？加载之后的验证、准备和解析分别是干什么的？

尤为重要的是准备阶段和初始化阶段，是如何为类分配内存空间的？然后类加载器的规则是什么？

来看一下上篇文章的图，简单回顾一下。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51671600_1562174045.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**2、大厂面试背景引入**

很多人想要到阿里、美团、京东等互联网大公司去面试，但是现在互联网大厂面试一般都必定会考核JVM相关的知识积累

所以在了解完了JVM的类加载机制之后，先一起来看看JVM的内存区域划分，这个基本上是互联网公司面试必问。



**3、到底什么是JVM的内存区域划分？**

其实这个问题非常简单，JVM在运行我们写好的代码时，他是必须使用多块内存空间的，不同的内存空间用来放不同的数据，然后配合我们写的代码流程，才能让我们的系统运行起来。

举个最简单的例子，比如咱们现在知道了JVM会加载类到内存里来供后续运行，那么我问问大家，这些类加载到内存以后，放到哪儿去了呢？想过这个问题吗？

所以JVM里就必须有一块内存区域，用来存放我们写的那些类。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68335300_1562174045.cn/txdocpic/0/a36d967a636bd6cba968132fe7d5a2fe/0)

继续来看，我们的代码运行起来时，是不是需要执行我们写的一个一个的方法？

那么运行方法的时候，方法里面有很多变量之类的东西，是不是需要放在某个内存区域里？

接着如果我们写的代码里创建一些对象，这些对象是不是也需要内存空间来存放？

同样的，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87758600_1562174045.cn/txdocpic/0/40ce28b870bb122aedb3d3c9183c9d94/0)

这就是为什么JVM中必须划分出来不同的内存区域，它是为了我们写好的代码在运行过程中根据需要来使用的。

接下来，我们就依次看看JVM中有哪些内存区域。



**4、存放类的方法区**

这个方法区是在JDK 1.8以前的版本里，代表JVM中的一块区域。

主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。

但是在JDK 1.8以后，这块区域的名字改了，叫做“Metaspace”，可以认为是“元数据空间”这样的意思。当然这里主要还是存放我们自己写的各种类相关的信息。

举个例子，还是跟我们之前说的那样，假设我们有一个“Kafka.class”类和“ReplicaManager.class”类，类似下面的代码。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/7691900_1562174046.png)



这两个类加载到JVM后，就会放在这个方法区中，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/30635300_1562174046.cn/txdocpic/0/5ed39984ec95cdb3f63edcf9ff174d6f/0)





**5、执行代码指令用的程序计数器**

继续假设我们的代码是如下所示：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51858600_1562174046.png)



之前给大家讲过，实际上上面那段代码首先会存在于“.java”后缀的文件里，这个文件就是java源代码文件。

但是这个文件是面向我们程序员的，计算机他是看不懂你写的这段代码的。

所以此时就得通过编译器，把“.java”后缀的源代码文件编译为“.class”后缀的字节码文件。

这个“.class”后缀的字节码文件里，存放的就是对你写出来的代码编译好的字节码了。

字节码才是计算器可以理解的一种语言，而不是我们写出来的那一堆代码。

字节码看起来大概是下面这样的，跟上面的代码无关，就是一个示例而已，给大家感受一下。



```
public java.lang.String getName();     descriptor: ()Ljava/lang/String;     flags: ACC_PUBLIC     Code:         stack=1, locals=1, args_size=1             0: aload_0             1: get_field    #2             4: areturn
```



这段字节码就是让大家知道“.java”翻译成的“.class”是大概什么样子的。

比如“0: aload_0”这样的，就是“字节码指令”，他对应了一条一条的机器指令，计算机只有读到这种机器码指令，才知道具体应该要干什么。

比如字节码指令可能会让计算机从内存里读取某个数据，或者把某个数据写入到内存里去，都有可能，各种各样的指令就会指示计算机去干各种各样的事情。

所以现在大家首先明白一点：**我们写好的Java代码会被翻译成字节码，对应各种字节码指令**

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。

所以当JVM加载类信息到内存之后，实际就会使用自己的**字节码执行引擎**，去执行我们写的代码编译出来的代码指令，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70899500_1562174046.cn/txdocpic/0/82f3b71cabd27c3abf8e58509ca117f6/0)

那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”

这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。

我们通过一张图来说明：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95852000_1562174046.cn/txdocpic/0/e735b486fa6a29c189af7d947558e70b/0)

大家都知道JVM是支持多个线程的，所以其实你写好的代码可能会开启多个线程并发执行不同的代码，所以就会有多个线程来并发的执行不同的代码指令

因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了

下图更加清晰的展示出了他们之间的关系。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24349900_1562174047.cn/txdocpic/0/ee845415897bb5b7b8cf888a2a1464d0/0)

**6、Java虚拟机栈**

Java代码在执行的时候，一定是线程来执行某个方法中的代码

哪怕就是下面的代码，也会有一个main线程来执行main()方法里的代码

在main线程执行main()方法的代码指令的时候，就会通过main线程对应的程序计数器记录自己执行的指令位置。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49375500_1562174047.png)

但是在方法里，我们经常会定义一些方法内的局部变量

比如在上面的main()方法里，其实就有一个“replicaManager”局部变量，他是引用一个ReplicaManager实例对象的，关于这个对象我们先别去管他，先来看方法和局部变量。

因此，JVM必须有一块区域是来保存每个方法内的**局部变量**等数据的，这个区域就是Java虚拟机栈

每个线程都有自己的Java虚拟机栈，比如这里的main线程就会有自己的一个Java虚拟机栈，用来存放自己执行的那些方法的局部变量。

如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧

栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西，这里大家先不用全都理解，我们先关注局部变量。

比如main线程执行了main()方法，那么就会给这个main()方法创建一个栈帧，压入main线程的Java虚拟机栈

同时在main()方法的栈帧里，会存放对应的“replicaManager”局部变量

上述过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67197800_1562174047.cn/txdocpic/0/4197da8f1fcfa8b97b97638b6247e5c3/0)

然后假设main线程继续执行ReplicaManager对象里的方法，比如下面这样，就在“loadReplicasFromDisk”方法里定义了一个局部变量：“hasFinishedLoad”

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92921500_1562174047.png)



那么main线程在执行上面的“loadReplicasFromDisk”方法时，就会为“loadReplicasFromDisk”方法创建一个栈帧压入线程自己的Java虚拟机栈里面去。

然后在栈帧的局部变量表里就会有“hasFinishedLoad”这个局部变量。

整个过程如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10232200_1562174048.cn/txdocpic/0/7192f064bdb42017288b83dafa584709/0)

接着如果“loadReplicasFromDisk”方法调用了另外一个“isLocalDataCorrupt()”方法 ，这个方法里也有自己的局部变量

比如下面这样的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20448000_1562174116.png)



那么这个时候会给“isLocalDataCorrupt”方法又创建一个栈帧，压入线程的Java虚拟机栈里。

而且“isLocalDataCorrupt”方法的栈帧的局部变量表里会有一个“isCorrupt”变量，这是“isLocalDataCorrupt”方法的局部变量

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33506800_1562174048.cn/txdocpic/0/457d1c2f6d89903e8e36916dda9ea744/0)

接着如果“isLocalDataCorrupt”方法执行完毕了，就会把“isLocalDataCorrupt”方法对应的栈帧从Java虚拟机栈里给出栈

然后如果“loadReplicasFromDisk”方法也执行完毕了，就会把“loadReplicasFromDisk”方法也从Java虚拟机栈里出栈。

上述就是JVM中的“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈

在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。

咱们再来看一个图，了解一下每个线程在执行代码时，除了程序计数器以外，还搭配了一个Java虚拟机栈内存区域来存放每个方法中的局部变量表。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/58381900_1562174048.cn/txdocpic/0/02705de5b5a6d20bf41b2e37e41c2a1d/0)



**7、Java堆内存**

现在大家都知道了，main线程执行main()方法的时候，会有自己的程序计数器。

此外，还会依次把main()方法，loadReplicasFromDisk()方法，isLocalDataCorrupt()方法的栈帧压入Java虚拟机栈，存放每个方法的局部变量。

那么接着我们就得来看JVM中的另外一个非常关键的区域，就是Java堆内存，这里就是存放我们在代码中创建的各种对象的

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12867100_1562174155.png)



上面的“new ReplicaManager()”这个代码就是创建了一个ReplicaManager类的对象实例，这个对象实例里面会包含一些数据，如下面的代码所示。

这个“ReplicaManager”类里的“replicaCount”就是属于这个对象实例的一个数据。

类似ReplicaManager这样的对象实例，就会存放在Java堆内存里。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40763600_1562174255.png)



Java堆内存区域里会放入类似ReplicaManager的对象，然后我们因为在main方法里创建了ReplicaManager对象的，那么在线程执行main方法代码的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址

相当于你可以认为局部变量表里的“replicaManager”指向了Java堆内存里的ReplicaManager对象

还是给大家来一张图，更加清晰一些：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/84661900_1562174048.cn/txdocpic/0/17d3ff214c6a93034ed5829639dbca23/0)



**8、核心内存区域的全流程串讲**

其实我们把上面的那个图和下面的这个总的大图一起串起来看看，还有配合整体的代码，我们来捋一下整体的流程，大家就会觉得很清晰。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3659300_1562174049.cn/txdocpic/0/a574bfb97766cfa0c041624c117c79ca/0)



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20435800_1562174255.png)



首先，你的JVM进程会启动，就会先加载你的Kafka类到内存里。然后有一个main线程，开始执行你的Kafka中的main()方法。

main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

大家结合上图中的程序计数器来理解一下。

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

看到这里，大家结合上面的两个图理解一下。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

其实大家理解了这个过程，那么JVM中的各个核心内存区域的功能和对应的我们的Java代码之间的关系，就彻底理解了



**9、其他内存区域**

其实在JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的

如果大家去看他内部的源码，会发现很多地方都不是Java代码了，而是走的native方法去调用本地操作系统里面的一些方法，可能调用的都是c语言写的方法，或者一些底层类库

比如下面这样的：public native int hashCode();

在调用这种native方法的时候，就会有线程对应的本地方法栈，这个里面也是跟Java虚拟机栈类似的，也是存放各种native方法的局部变量表之类的信息。

还有一个区域，是不属于JVM的，通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。

其实很多技术都会用这种方式，因为有一些场景下，堆外内存分配可以提升性能。



**10、本文小结**

本文到这里就结束了，基本上把JVM里的核心内存区域的功能解释清楚了

大家需要重点去关注方法区、程序计数器、Java虚拟机栈和Java堆这些内存区域的作用，和我们配套的图以及代码结合起来去理解。



**11、昨日思考题解答**

昨天让大家去思考一下：Tomcat这种Web容器中的类加载器应该如何设计实现？

这里给大家一个简单的思路给回复。

首先Tomcat的 类加载器体系如下图所示，他是自定义了很多类加载器的。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/23933200_1562174049.cn/txdocpic/0/9c56ad956e2c39a693c88472309c961a/0)

Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。

然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类

至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。

而且大家一定要记得，Tomcat是打破了双亲委派机制的

每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。

如果大家感兴趣，可以自己找资料去学习研究Tomcat的类加载机制。



**12、今日思考题**

今天我们学习了JVM中的各个内存区域，那么先留给大家一个思考题：

我们在Java堆内存中分配的那些对象，到底会占用多少内存？一般怎么来计算和估算我们的系统创建的对象对内存占用的一个压力呢？

# 005、JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？

2019-06-23 14:35:28

**JVM的垃圾回收机制是用来干嘛的？**

**为什么要垃圾回收？**



**目录：**

1. 前文回顾
2. 对象的分配与引用
3. 一个方法执行完毕后会怎样？
4. 我们创建的Java对象其实都是占用内存资源的
5. 不再需要的那些对象应该怎么处理？
6. 本文小结





**1、前文回顾**

上一篇文章给大家分析了JVM中的几块内存区域分别都是干什么的，今天的文章就给大家初步介绍一下垃圾回收的概念。

但是今天的文章对垃圾回收不会切入过深，因为很多学习专栏的朋友都是一些初学者。

因此，咱们还是那句话，尽量用最通俗的语言配合大量手绘图，让大家初步了解垃圾回收到底是什么。

先来看一下昨天的一张图，回顾一下JVM中几块内存区域的作用。

![01_总大图.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27918700_1562230843.jpg)

大家脑子里一定要有一个会动的图，你的代码在运行的时候，起码有一个main线程会去执行所有的代码，当然也可能是你启动的别的线程。

然后线程执行时必须通过自己的程序计数器来记录执行到哪一个代码指令了

另外线程在执行方法时，为每个方法都得创建一个栈帧放入自己的Java虚拟机栈里去，里面有方法的局部变量。

最后就是代码运行过程中创建的各种对象，都是放在Java堆内存里的。

结合上面的大图看一看，相信大家一定就明白是怎么回事了，大家对JVM的运行原理也应该都有了一个初步的理解和把握。



**2、对象的分配与引用**

现在我们假设有下面一段代码，大概意思你可以理解为通过“loadReplicasFromDisk”方法的执行，去磁盘上加载需要的副本数据

然后通过“ReplicaManager”对象实例完成了这个操作。

代码如下所示：

![代码1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42627800_1562230843.png)

结合我们之前理解过的JVM运行原理，一起通过动态的图来拆解一下上述代码的运行流程。

首先一个main线程肯定会来执行main()方法里的代码

main线程自己是有一个Java虚拟机栈的，他会把main()方法的栈帧压入Java虚拟机栈

如下图所示：

![02_压入栈帧.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54079800_1562230843.jpg)

接着main()方法里调用了loadReplicasFromDisk()方法

那么就会创建loadReplicasFromDisk()方法的栈帧，压入main线程的Java虚拟机栈里去

这个过程如下图：

![03_继续压入栈帧.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67192600_1562230843.jpg)

此时发现在loadReplicasFromDisk()方法里，有一个“repliaManager”变量，那么就会在loadReplicasFromDisk()方法对应的栈帧里，放入一个“repliaManager”变量。

继续看下图：

![04_局部变量.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92889300_1562230843.jpg)

接着发现在代码里创建了一个“ReplicaManager”类的实例对象，此时就会在Java堆内存中分配这个实例对象的内存空间。

同时，让loadReplicasFromDisk()方法的栈帧内的“replicaManager”局部变量去指向那个Java堆内存里的ReplicaManager实例对象，大家看下图：

![05_分配对象.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4461000_1562230844.jpg)

接下来，就会执行通过“replicaManager”局部变量引用的“ReplicaManager”实例对象去执行他的load()方法，去完成我们实现的业务逻辑。

好，到这里为止，其实都是上篇文章讲解过的知识，我们就是重新串联了一遍，相信大家都很好理解。



**3、一个方法执行完毕之后会怎么样？**

接着大家来回顾一下上面的代码。

![代码2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15050100_1562230844.png)

其实目前的图我们已经表述到了“replicaManager.load()”这行代码这里

那么现在有个问题，如果这行代码执行结束了，此时会怎么样？

大家还记得之前文章说过，一旦方法里的代码执行完毕，那么方法就执行完毕了，也就是说loadReplicasFromDisk()方法就执行完毕了。

一旦你的loadReplicasFromDisk()方法执行完毕，此时就会把loadReplicasFromDisk()方法对应的栈帧从main线程的Java虚拟机栈里出栈

如下图所示：

![06_出栈.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29818700_1562230844.jpg)

此时一旦loadReplicasFromDisk()方法的栈帧出栈，那么大家会发现那个栈帧里的局部变量，“replicaManager”，也就没有了。

也就是说，没有任何一个变量指向Java堆内存里的“ReplicaManager”实例对象了。



**4、我们创建的Java对象其实都是占用内存资源的**

核心点来了，此时大家发现了，Java堆内存里的那个“ReplicaManager”实例对象已经没有人引用他了

这个对象实际上已经没用了，该干的事儿都干完了，现在你还让他留在内存里干啥呢？

大家要知道，内存资源是有限的。

一般来说，我们会在一台机器上启动一个Java系统，机器的内存资源是有限的，比如就4个G的内存

然后我们启动的Java系统本质就是一个JVM进程，他负责运行我们的系统的代码，这个之前都解释过了。

那么这个JVM进程本身也是会占用机器上的部分内存资源，比如占用2G的内存资源。

那么我们在JVM的Java堆内存中创建的对象，其实本质也是会占用JVM的内存资源的，比如“ReplicaManager”实例对象，会占用500字节的内存。

所以大家看到这里，心中应该无比明白的一个核心点：我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

大家看下面的图，感受会深一点。

![07_内存占用.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/43162800_1562230844.jpg)



**5、不再需要的那些对象应该怎么处理？**

继续思考上面的图，既然“ReplicaManager”对象实例是不需要使用的，已经没有任何方法的局部变量在引用这个实例对象了，而且他还空占着内存资源，那么我们应该怎么处理呢？

答案呼之欲出：**JVM的垃圾回收机制**

JVM本身是有垃圾回收机制的，他是一个后台自动运行的线程

你只要启动一个JVM进程，他就会自带这么一个垃圾回收的后台线程。

这个线程会在后台不断检查JVM堆内存中的各个实例对象

还是给大家画一张图，来看看这个过程：

![08_垃圾回收线程.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54743400_1562230844.jpg)

如果某个实例对象没有任何一个方法的局部变量指向他，也没有任何一个类的静态变量，包括常量等地方在指向他。

那么这个垃圾回收线程，就会把这个没人指向的“ReplicaManager”实例对象给回收掉，从内存里清除掉，让他不再占用任何内存资源。

这样的话，这些不再被人指向的对象实例，即JVM中的“**垃圾**”，就会定期的被后台垃圾回收线程清理掉，不断释放内存资源

大家看下图：

![09_垃圾回收.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74706600_1562230844.jpg)

到此为止，相信大家跟上文章思路一路看下来，就很清晰明了。到底什么是JVM中的“垃圾”？什么又是JVM的“垃圾回收”！



**6、本文小结**

不知不觉，第一周的文章都更新完毕了，希望大家温故而知新。

既然是付费来学习知识的，一定要对自己负责，坚持把每篇文章多看几遍，把知识吃透。

这周，我们为了照顾很多JVM的小白同学，从0起步，用最通俗易懂的语言和一步一图的方式，把你写好的Java代码如何通过JVM运行起来的核心原理都讲清楚了。

目前为止，大家应该对JVM的核心运行流程、JVM的类加载机制、JVM的内存区域以及垃圾回收机制都有一个初步的了解。

很多对JVM有一定了解的朋友一定会说：这些内容都很简单，有没有深入点的干货？

**有！**但是请不要着急，我们的专栏是兼顾各种基础的朋友，所以需要循序渐进，从浅入深。

比如JVM垃圾回收机制，就会在第三周详细讲解JVM的各种垃圾回收的细节

所以请大家稍安勿躁，一步一步来，如果有一定基础的同学，就当做复习一遍。

马上周末就是第一周的作业和答疑集锦了，大家周末记得完成作业，同时看一下每周最新的精华答疑集锦，从答疑中也能学习到一些知识。

**7、希望大家多帮忙宣传和推广**

专栏刚上线的时候，是拜托我的好朋友在公众号里宣传的，现在他还在一直坚持帮我们宣传，非常的感谢他。

不过当时刚上线，我们一篇文章都没更新，很多朋友对我们的文章质量是没有了解的，所以可能会犹豫不决要不要购买

不过经过一周文章下来，相信很多一路跟下来的朋友，都对这个专栏质量有了自己的了解和认可。

我和即将发布专栏的几位朋友都长年工作于一线大厂，比如阿里、百度、美团，等等，负责过多个大型系统的架构设计。

之所以聚在狸猫技术窝这个平台开设专栏，初衷就是为了帮助国内广大的java工程师，解决大家在面试中、工作中的一些痛点问题。

现在网上很多技术资料，但是鱼龙混杂，底子薄弱的朋友很难辨别其内容优劣，很容易被带跑偏。

所以我们几个朋友才希望通过自己的思路，来做一些高质量的专栏，将我们多年一线工作经验浓缩精华，传授给大家，也是为国内IT界尽一点绵薄之力。

但是由于刚开始做，很多人不了解我们，所以还是希望购买我们专栏的朋友，如果觉得我们的内容不错，帮忙多宣传一下。

大家可以根据下面步骤生成自己的海报，推荐给朋友，分享技术的同时还能获得一点收益。

最后，感谢大家为我们坚持长期推出更多好的专栏做出的支持！



**8、昨日思考题解答**

我们回到文章中，昨天给了一个思考题：我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？

这个其实很简单，一个对象对内存空间的占用，大致分为两块：

- 一个是对象自己本身的一些信息
- 一个是对象的实例变量作为数据占用的空间

比如对象头，如果在64位的linux操作系统上，会占用16字节，然后如果你的实例对象内部有个int类型的实例变量，他会占用4个字节，如果是long类型的实例变量，会占用8个字节。如果是数组、Map之类的，那么就会占用更多的内存了。

另外JVM对这块有很多优化的地方，比如补齐机制、指针压缩机制，这块东西我们不会单独拿出来讲，因为比较复杂，而且暂时对大家还不是很需要。

其实我信奉的一个道理，就是用案例实战来说话，引出很多技术和知识点的讲解，所以很多类似的知识，我会在后期大量的案例中去分析，需要的时候再学，效果最好。

这里就是先科普一下，让大家有一个基本的概念，如果有兴趣可以百度资料自己查阅。



**8、今日思考题**

既然今天提到了Java堆内存里的对象会被回收掉，那么加载到方法区的类会被垃圾回收吗？什么时候被回收？为什么呢？

大家可以思考一下这个问题，下周一的文章里会给出解答。

**End**

# 006、第1周作业：不借助任何资料，画出JVM整体运行原理图！

**作业内容：**

这是我们的专栏第一周的作业，首先我们来简单回顾一下。

这一周，我们从JVM的整体运行原理开始学习，分析了JVM的类加载机制，JVM的内存区域划分以及对应的工作原理，JVM的垃圾回收到底是什么。

所以第一周的定位，就是从最通俗的语言以及一步一图的方式，兼顾到很多JVM小白初学者，绝对跟着看下来可以快速入门JVM的基本工作原理，整体把握他的脉络。

对于已经对JVM有一定了解的朋友来说，就是快速简单梳理和回顾一下。

那么第一周的作业是什么呢？

很简单，希望大家把第一周的文章反复看几遍，完全做到心里有数

接着在不看任何资料的前提下，自己仿照文章那样，写出来一段代码，然后找一个画图工具，动手画图，把那段代码运行的时候，JVM的整个工作原理画出来。比如：

- 执行多个方法的调用时，如何把方法的栈帧压入线程的Java虚拟机栈？
- 栈帧里如何放局部变量？
- 如何在Java堆里创建实例对象？
- 如何让局部变量引用那个实例对象？
- 方法运行完之后如何出栈？
- 垃圾回收是如何运行的？

希望大家不借助资料，直接根据自己心里对JVM原理的理解，把这个图画出来。

再强调一下，我设计这个专栏的思路，就是每周必须有作业，因为光看不复习，光看不练，看了等于白看。

大家必须跟着完成作业，才能真正把学到的东西吸收成自己的东西，一个专栏跟下来，才能真正积累很多硬核技术。

希望大家周末都抽一点时间，完成本周作业。

# 007、第1周答疑：本周问题统一答疑

2019-06-23 14:39:29

**第一周问题统一答疑**



下面是本周大家的问题汇总，所有同学都可以看看，边看边思考！



**问题一：**

方法走完，引用消失，堆内存还未必消失。好多人在做报表导出的时候，就会在for循环里不断的创建对象，很容易造成堆溢出，请问这种大文件导出怎么破？

**答：**建议不要在for里创建对象，可以在外面搞一个对象，for循环里对一个对象修改数据即可

**问题二**

1.Java支持多线程，每个线程有自己的Java虚拟机栈和本地方法栈，是这样吗？ 

2.新建的实例在堆内存，实例变量也是在堆内存? 是这样吗？

**答：**1、2两点均理解正确

**问题三**

您好，我不太看懂入栈和出栈有什么意义，可以给我解释一下吗？谢谢！

**答：**入栈的时候，就是你执行一个方法的时候，为这个方法创建一个栈帧入栈

出栈，就是你的方法执行完毕了，就会出栈，其实这个不用急，明天的文章会有详细的图解，你会看明白的。

**问题四**

如果是父类子类的情况是下面哪种呢? 加载父类->加载子类->初始化父类->初始化子类, 加载父类->初始化父类->加载子类->初始化子类

**答：**不是的，加载父类就是父类，除非用到子类才会加载子类；但是加载子类要初始化之前，必须先加载父类，初始化父类

**问题五**

类加载器有三层，如果在第二层的类加载器可以加载这些类的话，就没有必要往上去找他的父类加载吗？

既然说类只有用到的时候才加载到内存中，那么new对象的时候肯定用到，但是是不是先经历过类的所有过程才将类实例化？

**答：**没错，必须先加载类，再实例化对象

**问题六**

第一课内容比较详细的讲解了java程序的执行过程，但是感觉提出的问题并不能在文章中找到答案，也许是一个课后需要自己找寻答案的提问？还是希望可以有一个比较全面的回答的

**答：**提出的问题是给大家的思考题，第二天会给出简单的解释，但是其实理解了文章的内容，完全可以自己找资料去理解，这是一个小作业，是一个思考的过程

**问题七**

Object Header（4字节） + Class Pointer（4字节）+ Fields（看存放类型），但是jvm内存占用是8的倍数，所以结果要向上取整到8的倍数

**答：**很好，就是这样

**问题八**

如果我有一个静态的成员变量int,那我多线程更改是否会有线程安全问题，为什么？

**答：**静态成员变量，他在内存里，只有一份，就是属于类的。你多个线程并发修改，一定会有并发问题，可能导致数据出错。

**问题九**

类加载是按需加载，可以一次性加载全部的类吗？

**答：**如果是默认的类加载机制，那么是你的代码运行过程中，遇到什么类加载什么类。如果你要自己加载类，那么需要写自己的类加载器

**问题十**

为什么必须要一级一级类加载器的往上找，直接从顶层类加载器开始找不就行了吗？

**答：**其实关于这个问题，不用过于纠结，每一层类加载器对某个类的加载，上推给父类加载器，到顶层类加载器，如果发现自己加载不到，再下推回子类加载器来加载，这样可以保证绝对不会重复加载某个类。

至于为什么不直接从顶层类加载器开始找，那是因为类加载器本身就是做的父子关系模型

你想一下Java代码实现，他最底下的子类加载器，只能通过自己引用的父类加载器去找。如果直接找顶层类加载器，不合适的，那么顶层类加载器不就必须硬编码规定了吗？

这就是一个代码设计思想，保证代码的可扩展性。

**问题十一**

是在执行new replicamanager()这行代码的时候加载replicamanger类吗？还是说加载cafka的时候就同时加载了呢？

**答：**执行new ReplicaManager的时候加载类

**问题十二**

还是没有明白 jvm和平时运行在机器上的系统之间是什么关系呢

**答：**其实很简单，你运行在机器上的系统，其实就是一个JVM进程，JVM进程会执行你系统里写好的那些代码

**问题十三**

1. class文件分配内存是在准备阶段，那类的class对象是在准备阶段创建的吗？ 
2. 如果实例变量有初始值，那实例变量是和类变量一同在初始化阶段赋值的吗？
3. 初始化之后是不是就有实例了

**答：**

1. 类是在准备阶段分配内存空间的
2. 实例变量得在你创建类的实例对象时才会初始化
3. 类的初始化阶段，仅仅是初始化类而已，跟对象无关，用new关键字才会构造一个对象出来



**问题十四**

双亲委派可以解决类重复加载的问题。按照文章中介绍每个类加载器有不同的类加载路径，这些类加载路径是否可能重叠？

**答：**不同类加载器的路径，一般是不会重叠的

**问题十五**

自定义的类加载器本身是由系统加载器加载的，也就是说其本身是没有加密的，那么我拿到该类反编译就可以看到如果解密class文件了，请问老师是这样么？

**答：**是的，所以说对class文件需要做特殊混淆处理，有商用的产品可以用

**问题十六**

作为一个web容器，既要解决跨应用公共共享问题也要解决独立应用独立问题。tomcat必须支持多层级的自定义类加载器

**答：**很好的推测，明天会给出答案

**问题十七**

用户使用类的时候应该是希望类已经准备好了一些数据，我猜想jvm设计者设计先执行static代码块的机制，是希望开发者在这里把使用类之前需要准备的工作在这里准备好 

1. 为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？
2. 启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要

**答：**

1. 没错，必须有初始化过程，准备好类级别的数据
2. 双亲委派，避免重复加载，评论区里多次回复了这个问题，可以看一看

**问题十八**

其实初始化时机就是对类的主动使用：调用静态方法时对类的主动使用的一种场景，main方法本质上是个static方法，没有调用的main方法和没有调用的static方法没区别！

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

**答：**不会的，你启动一个jar包，需要指定某个main主类，优先就是加载他

**问题十九**

tomcat本身是java程序，那么tomcat的实现程序的class是由应用类加载器加载的，用户自己的java程序war包，放入tomcat的程序的classpath中

这样用户的程序和tomcat的程序都是由应用类加载器加载了，也就是处于一个jvm中了（此问题是003文章底下的评论）

**答：**非常好的回复，明天文章会给出答案

**问题二十**

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

**答：**你启动一个jar包的时候，会指定是走哪个main方法所在的类，是唯一的

**问题二十一**

1. 为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？
2. 启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要

**答：**

1. 没错，类在方法区，他在内存里，所以你必须给他初始化，赋值
2. 还是有必要，比如启动类加载器，可以通过一些方式指定加载其他目录的类，那么你必须得走双亲委派，如果对那些特殊区域的类加载，走双亲委派，才能上推到启动类加载器去执行，不会重复加载

**问题二十二**

老师好请问类加载双亲委派机制 为什么要先找父加载 而不是自己找？这种设计的好处是？

**答：**好处就在于，每个层级的类加载器各司其职，而且不会重复加载一个类。

比如你代码里用两个不同层级的类加载器，都去尝试加载了某个类，如果有双亲委派机制，那么都会先找父类加载器去加载，如果加载到了，那么以后就只会是他去加载这个类。

否则如果没有双亲委派机制，那么岂不是两个不同层级的类加载器可以加载同一个类，造成类的重复加载！

**问题二十三**

自定义类加载器如何实现？

**答：**自己写一个类，继承ClassLoader类，重写类加载的方法，然后在代码里面可以用自己的类加载器去针对某个路径下的类加载到内存里来

**问题二十四**

看到一个词:动态部署，那么是否也有对应的静态部署?如何解释呢？ (谢老师回答)

**答：**假设一个背景在Tomcat部署系统的话，那么动态部署，也成为热部署

就是直接系统放入Tomcat对应目录，他自动就重新加载你最新的代码给你热部署了，不需要对Tomcat进行停机再重启；

反之，则是先停止Tomcat，然后部署最新代码到Tomcat对应目录里，然后重启Tomcat

**问题二十五**

-XX:+TraceClassLoading 可以看加载了哪些类，动手实验了一下，jre\lib\rt.jar下的类全部加载了，其他都是用到时候加载。

**答：**没错，明天更新的第三篇文章里，会讲解类加载机制，rt.jar这属于核心类库，属于支撑我们Java系统运行的底层类库，所以他一定会被加载

我们自己写的代码，一般是你代码运行使用到了哪个类，就会去加载哪个类

**问题二十六**

老师，类加载器是把jar包里的所有类一次性全部加载进去吗？

**答：**不是的，首先加载包含main方法的主类，接着是运行你写的代码的时候，遇到你用了什么类，再加载什么类

**问题二十七**

通过代码混淆机制，加大反编译之后的可读性！ 或者是否可以基于二进制加密呢，学生没用过！

**答：**其实现在对于这个一般都是用商业产品的，有很多第三方公司提供加密产品，可以百度一下，class文件加密，就可以看到，直接用他们的产品即可

**问题二十八**

Class源文件的保护，可以采用代码混淆技术，方式有很多，如回答区中老师提到的商用加密软件

**答：**非常好，就是这样

**问题二十九**

看文中内容，是会加载两次字节码吗，第一次加载进jvm，然后程序执行的时候再加载。有点不解！

**答：**你好，不是加载两次，是JVM先把“.class”字节码文件中的类加载到内存里，然后执行的时候，就直接使用加载好的类极客，不会重复加载

**问题三十**

class文件通过工具可以反编译的，请问有没有方法对class文件进行加密又不影响它的执行。windows桌面程序里一般都是打包成dll文件，java中有没有比较好的方式？

**答：**可以的，比如jvmti小工具就可以实现class文件的加密

另外其实为了保护源代码安全，有很多商业公司推出了专业级别的class加密产品，可以付费使用。

解密的话一般可以基于自定义的类加载器来实现，在加载类的时候把class给解密，这样就可以保护自己的源代码安全了。

最后，附上两张Tomcat类加载如果**按委派模型的加载流程和实际实现的流程**（专栏读者所画）

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45640100_1562430625.png)



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80064300_1562430625.png)



**End**

# 008、聊聊JVM分代模型：年轻代、老年代、永久代

2019-06-23 14:40:22

**聊聊JVM分代模型：年轻代、老年代、永久代**



**目录：**

1. 背景引入
2. 大部分对象其实存活周期极短
3. 少数对象是长期存活的
4. JVM分代模型：年轻代和老年代
5. 为什么要分成年轻代和老年代？
6. 什么是永久代？
7. 上周思考题解答
8. 今日思考题





**1、背景引入**

今天开始，咱们进入第二周的内容，这一周会重点关注JVM内存划分的一些细节。

我会帮助大家更加深入的去理解JVM内存划分的原理细节，以及我们创建的那些对象在JVM中到底是如何分配，如何流动的，这对于大家理解JVM原理有更深一层的帮助。

首先这篇文章作为本周的一个开篇，我们来给大家介绍一下JVM内存的一个分代模型：年轻代、老年代、永久代。

大家现在应该都知道一点，那就是我们在代码里创建的对象，都会进入到Java堆内存中，比如下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/61041000_1562517499.png)



这段代码，我们稍微做了点改动，在main()方法里，会周期新的执行loadReplicasFromDisk()方法，加载副本数据。

首先一旦执行main()方法，那么就会把main()方法的栈帧压入main线程的Java虚拟机栈

如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68813000_1562517499.cn/txdocpic/0/04e1bc7e9b465b7d40b1e46243f08344/0)

然后每次在while循环里，调用loadReplicasFromDisk()方法，就会把loadReplicasFromDisk()方法的栈帧压入自己的Java虚拟机栈

如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80080800_1562517499.cn/txdocpic/0/e3896c4cea154b2422622ec685e74752/0)

接着在执行loadReplicasFromDisk()方法的时候，会在Java堆内存里会创建一个ReplicaManager对象实例

而且loadReplicasFromDisk()方法的栈帧里会有“replicaManager”局部变量去引用Java堆内存里的ReplicaManager对象实例

如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5349600_1562517500.cn/txdocpic/0/8d169c754c01f0340e3b1d9f40654709/0)

然后就会执行ReplicaManager对象的load()方法。



**2、大部分对象都是存活周期极短的**

现在有一个问题，在上面代码中，那个ReplicaManager对象，实际上属于短暂存活的这么一个对象

大家可以观察一下，在loadReplicasFromDisk()方法中创建这个对象，然后执行ReplicaManager对象的load()方法，然后执行完毕之后，loadReplicasFromDisk()方法就会结束。

一旦方法结束，那么loadReplicasFromDisk()方法的栈帧就会出栈，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24039100_1562517500.cn/txdocpic/0/d4436bf7fba6fe0bae6ba1e7f81de053/0)

然后接着上篇文章已经说过，此时一旦没人引用这个ReplicaManager对象了，就会被JVM的垃圾回收线程给回收掉，释放内存空间，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40140000_1562517500.cn/txdocpic/0/5046e4459ba2213095b4699d6f6d38c2/0)

然后在main()方法的while循环里，下一次循环再次执行loadReplicasFromDisk()方法的时候，又会走一遍上面那个过程，把loadReplicasFromDisk()方法的栈帧压入Java虚拟机栈，然后构造一个ReplicaManager实例对象放在Java堆里。

一旦执行完ReplicaManager对象的load()方法之后，loadReplicasFromDisk()方法又会结束，再次出栈，然后垃圾回收释放掉Java堆内存里的ReplicaManager对象。

所以其实这个ReplicaManager对象，在上面的代码中，是一个存活周期极为短暂的对象

可能每次执行loadReplicasFromDisk()方法的时候，被创建出来，然后执行他的load()方法，接着可能1毫秒之后，就被垃圾回收掉了。

所以从这段代码就可以明显看出来，大部分在我们代码里创建的对象，其实都是存活周期很短的。这种对象，其实在我们写的Java代码中，占到绝大部分的比例。



**3、少数对象是长期存活的**

但是我们来看另外一段代码，假如说咱们用下面的这种方式来实现同样的功能：

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/66557000_1562517500.png)



上面那段代码的意思，就是给Kafka这个类定义一个静态变量，也就是“replicaManager”，这个Kafka类是在JVM的方法区里的

然后让“replicaManager”引用了一个在Java堆内存里创建的ReplicaManager实例对象，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/82266400_1562517500.cn/txdocpic/0/b54c781435cdcbb11230945ba6d41d32/0)

接着在main()方法中，就会在一个while循环里，不停的调用ReplicaManager对象的load()方法，做成一个周期性运行的模式。

这个时候，我们就要来思考一下，这个ReplicaManager实例对象，他是会一直被Kafka的静态变量引用的，然后会一直驻留在Java堆内存里，是不会被垃圾回收掉的。

因为这个实例对象他需要长期被使用，周期新的被调用load()方法，所以他就成为了一个长时间存在的对象。

那么类似这种被类的静态变量长期引用的对象，他需要长期停留在Java堆内存里，这这种对象就是生存周期很长的对象，他是轻易不会被垃圾回收的，他需要长期存在，不停的去使用他。



**4、JVM分代模型：年轻代和老年代**

接下来就要进入今天的核心主题了，就是JVM的分代模型，年轻代和老年代。

现在大家已经看到，其实根据你写代码方式的不同，采用不同的方式来创建和使用对象，其实对象的生存周期是不同的。

所以JVM将Java堆内存划分为了两个区域，一个是年轻代，一个是老年代。

其中年轻代，顾名思义，就是把第一种代码示例中的那种，创建和使用完之后立马就要回收的对象放在里面

然后老年代呢，就是把第二种代码示例中的那种，创建之后需要一直长期存在的对象放在里面，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/94531400_1562517500.cn/txdocpic/0/5b65435b96c37267ecbb717150fd21e1/0)

比如下面的代码，我们再次来改造一下，再结合图，大家会看的更加的明确一些。

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4526200_1562517501.png)



上面那段代码稍微复杂了点，我们解释一下

Kafka的静态变量“fetcher”引用了ReplicaFetcher对象，这是长期需要驻留在内存里使用的

这个对象会在年轻代里停留一会儿，但是最终会进入老年代，大家看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/18143000_1562517501.cn/txdocpic/0/2c949e48487721b4f6018daf6fb91cad/0)

进入main()方法之后，会先调用loadReplicasFromDisk()方法，业务含义是系统启动就从磁盘加载一次副本数据，这个方法的栈帧会入栈

然后在这个方法里面创建了一个ReplicaManager对象，这个对象他是用完就会回收，所以是会放在年轻代里的，由栈帧里的局部变量来引用

此时对应着下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/39173000_1562517501.cn/txdocpic/0/9cddbf1f5698d44fcec30cd48c5e7ca5/0)

然后一旦loadReplicasFromDisk()方法执行完毕了，方法的栈帧就会出栈，对应的年轻代里的ReplicaManager对象也会被回收掉，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53703400_1562517501.cn/txdocpic/0/7e4a0ec31f4e69e421c11d7ab874443a/0)

但是接着会执行一段while循环代码，他会周期性的调用ReplicaFetcher的fetch()方法，去从远程加载副本数据。

所以ReplicaFetcher这个对象因为被Kafka类的静态变量fetcher给引用了，所以他会长期存在于老年代里的，持续被使用。



**5、为什么要分成年轻代和老年代？**

相信看完这篇文章，大家就一定看明白了，什么样的对象是短期存活的对象，什么样的对象是长期存在的对象，然后如何分别存在于年轻代和老年代里。

那么为什么需要这么区分呢？

因为这跟垃圾回收有关，对于年轻代里的对象，他们的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法

对于老年代里的对象，他们的特点是需要长期存在，所以需要另外一种垃圾回收算法，所以需要分成两个区域来放不同的对象。

很多人又会问了，你不是说“ReplicaFetcher”这个长期存在的对象，刚开始也在年轻代，后来才会进入老年代么？那他到底什么时候进入老年代？

别急，明天的文章就会分析这块。

然后还有人还会问了，那么年轻代和老年代分别怎么进行垃圾回收呢？

别急，下周的文章会主要分析垃圾回收这块的原理。这周我们主要关注JVM的内存划分的细节，搞明白对象是如何在不同的内存区域里分配的就可以了，学习要循序渐进。



**6、什么是永久代？**

很简单，JVM里的永久代其实就是我们之前说的方法区

上面那个图里的方法区，其实就是所谓的永久代，你可以认为永久代就是放一些类信息的。

这个话题现在不用过多考虑，后续涉及到的时候，我们会讲到的。



**7、上周思考题解答**

上周留了一个思考题，让大家思考**方法区内会不会进行垃圾回收**

其实有同学都回答了，非常的好，在以下几种情况下，方法区里的类会被回收。

- 首先该类的所有实例对象都已经从Java堆内存里被回收
- 其次加载这个类的ClassLoader已经被回收
- 最后，对该类的Class对象没有任何引用

满足上面三个条件就可以回收该类了。



**8、今日思考题**

给大家出一个脑筋急转弯，出题思路有点偏：每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？

# 009、大厂面试题：你的对象在JVM内存中如何分配？如何流转的？

2019-06-23 21:20:27

**大厂面试题：**

**你的对象在JVM内存中如何分配？如何流转的？**



**目录：**

1. 前文回顾
2. 大部分正常对象都优先在新生代分配内存
3. 到底什么情况下会触发新生代的垃圾回收？
4. 长期存活的对象会躲过多次垃圾回收
5. 老年代会垃圾回收吗？
6. 关于新生代和老年代的对象分配，这就完了吗？
7. 昨日思考题解答
8. 今日思考题



**1、前文回顾**

经过昨天的文章铺垫了一些对象分配的基础知识后，想必大家现在都心里非常有数了，咱们平时代码里创建出来的对象，一般就是两种：

- 一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收
- 另外一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用

第一种短期存活的对象，是在Java堆内存的新生代里的。第二种长期存活的对象，是在Java堆内存的老年代里的。这个结论，想必大家都已经理解了

好，那么接下来我们就来聊聊，对象到底什么时候进入新生代？然后什么情况下会进入老年代？

**提示一下：**本文是建立在大家都绝对理解上文的基础上来写的，上文是结合代码示例来阐述的核心原理，包括对象什么情况下短期存活，什么情况下长期存活。

所以本文就直接通过大量图示来给大家分析对象在内存中的分配机制了，大家务必透彻理解上文。

**2、大部分正常对象都优先在新生代分配内存**

首先我们先来看上篇文章中的一段代码，稍微带着大家来理解一个概念：大部分的正常对象，都是优先在新生代分配内存的。

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76237100_1562572322.png)



大家还记得上面那段代码吗？虽然我们看代码知道，类静态变量“fetcher”引用的那个“ReplicaFetcher”对象，是会长期存活在内存里的

但是哪怕是这种对象，其实刚开始你通过“new ReplicaFetcher()”代码来实例化一个对象时，他也是分配在新生代里的。

包括在“loadReplicasFromDisk()”方法中创建的“ReplicaManager”实例对象，也都是一样分配在新生代里的

同样，我们以一张图，来展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10298400_1562572323.cn/txdocpic/0/0e833f156ae7201a3e89d7afb5cd6447/0)



**3、到底什么情况下会触发新生代的垃圾回收？**

现在咱们来假设一个场景，大家应该都知道，一旦“loadReplicasFromDisk()”方法执行完毕之后，这个方法的栈帧出栈，会导致没有任何局部变量引用那个“ReplicaManager”实例对象了。

此时可能会如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36887600_1562572323.cn/txdocpic/0/408a5832f0db1590fc21d80316d7999c/0)

那么此时就一定会立即发生垃圾回收，去回收掉Java堆内存里那个没人使用的“ReplicaManager”实例对象吗？

**NO！**大家别想的那么简单了，实际上垃圾回收他也得有点触发的条件。

其中一个比较常见的场景可能是这样的，假设我们写的代码中创建了N多对象，然后导致Java堆内存里囤积了大量的对象。

然后这些对象都是之前有人引用，比如各种各样的方法中的局部变量，但是现在也都没人引用了。

如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65138200_1562572323.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)

这个时候，如果新生代我们预先分配的内存空间，几乎都被全部对象给占满了！此时假设我们代码继续运行，他需要在新生代里去分配一个对象，怎么办？发现新生代里内存空间都不够了！

这个时候，就会触发一次新生代内存空间的垃圾回收，新生代内存空间的垃圾回收，也称之为“Minor GC”，有的时候我们也叫“Young GC”，他会尝试把新生代里那些没有人引用的垃圾对象，都给回收掉。

比如上图中，那个“ReplicaManager”实例对象，其实就是没有人引用的垃圾对象

此时就会当机立断，把“ReplicaManager”实例对象给回收掉，腾出更多的内存空间，然后放一个新的对象到新生代里去。

包括上图中那大量的实例对象，其实也都没人引用，在这个新生代垃圾回收的过程中，就会把这些垃圾对象也都回收掉。

其实话说回来，大家自己仔细回忆一下，我们在代码中创建的大部分对象，其实都是这种使用之后立马就可以回收掉的生存周期极短的对象，是不是？

可能我们会在新生代里分配大量的对象，但是使用完之后立马就没人引用了，此时新生代差不多满了

然后要分配新的对象的时候，发现新生代内存空间不足，就会触发一次垃圾回收，然后就把所有垃圾对象给干掉，腾出大量的内存空间

如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/97232300_1562572323.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)



**4、长期存活的对象会躲过多次垃圾回收**

接着我们来看下一个问题，上图中大家都注意到了“ReplicaFetcher”实例对象，他是一个长期被“Kafka”类的静态变量“fetcher”引用的长期存活的对象。

所以虽然你的新生代可能随着系统的运行，不停的创建对象，然后让新生代变满，接着垃圾回收一次，大量对象被回收掉

但是你的这个“ReplicaFetcher”对象，他确是一直会存活在新生代里的。

因为他一直被“Kafka”类的静态变量给引用了，所以他不会被回收。那么此时JVM就有一条规定了

如果一个实例对象在新生代中，成功的在15次垃圾回收之后，还是没被回收掉，就说明他已经15岁了。

这是对象的年龄，每垃圾回收一次，如果一个对象没被回收掉，他的年龄就会增加1。

所以如果上图中的那个“ReplicaFetcher”对象在新生代中成功躲过10多次垃圾回收，成为一个“老年人”，那么就会被认为是会长期存活在内存里的对象。

然后他会被转移到Java堆内存的老年代中去，顾名思义，老年代就是放这些年龄很大的对象。

我们再来看一张图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21115900_1562572324.cn/txdocpic/0/4d4ea63678b59270725c2bf57b7005df/0)



**5、老年代会垃圾回收吗？**

接着下一个问题就是，老年代里的那些对象会被垃圾回收吗？

答案是**肯定的**，因为老年代里的对象也有可能随着代码的运行，不再被任何人引用了，就需要被垃圾回收。

大家可以思考一下，如果随着类似上面的情况，越来越多的对象进入老年代，一旦老年代也满了，是不是就要对老年代垃圾回收了？

没错，这是肯定的，但是暂时我们先不用过多的去考虑这里的细节，因为这将是**下周的主题**，下周我们会进行深入剖析。



**6、关于新生代和老年代的对象分配，这就完了吗？**

还有人会说，关于新生代和老年代的对象分配，这就结束了吗？

当然不是，今天这篇文章，仅仅是相较于之前的文章，更进一步给大家分析了一下对象分配的一些机制。

但是其实在对象分配这块，还有很多其他的复杂机制，比如：

- 新生代垃圾回收之后，因为存活对象太多，导致大量对象直接进入老年代
- 特别大的超大对象直接不经过新生代就进入老年代
- 动态对象年龄判断机制
- 空间担保机制

可能一些JVM书籍会在这里一下把这些复杂的东西都写出来给大家，但是我们的专栏不会是这个思路。

还是那句话，我们的专栏写作思路是循序渐进，从浅入深，通俗易懂，一步一图。

很多底层技术细节，不要在前期铺垫太多，会导致很多同学吃了没法消化

**我会****结合后续大量案例，结合真实生产问题，把JVM各种底层细节带出来。****结合实战食用，效果更佳。**

因此第二周，大家对对象内存分配，了解到这个程度就行了，给大家总结一下：

- 先理解对象优先分配在新生代
- 新生代如果对象满了，会触发Minor GC回收掉没有人引用的垃圾对象
- 如果有对象躲过了十多次垃圾回收，就会放入老年代里
- 如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉

大家通过本文，先理解上面几点即可。



**7、昨日思考题解答**

昨天的思考题，是一个脑筋急转弯，说每个线程执行方法的时候，那些方法对应的栈帧出栈了，那么那里的局部变量需要垃圾回收吗？

其实这是一个偏题，JVM里垃圾回收针对的是新生代，老年代，还有方法区（永久代），不会针对方法的栈帧。

方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉了。



**8、今日思考题**

今天想给大家出一个预习类的思考题：理解了今天的对象内存分配，垃圾回收以及老年代转移的机制之后。

大家能否结合短生存周期的对象的特点，以及长生存周期的对象的特点，思考一下，看看你们手头正在负责的系统，梳理梳理里面短生存周期的对象都有什么，长生存周期的对象都有什么。

可以在评论区踊跃回复，让大家开始从JVM的角度去思考自己手头负责的系统中的代码是怎么运行的。

**End**

# 010、动手实验：亲自感受一下线上系统部署时如何设置JVM内存大小？

2019-06-25 02:04:57

**动手实验：****亲自感受一下线上系统部署时如何设置JVM内存大小？**



**目录：**

1. 前文回顾
2. 跟JVM内存相关的几个核心参数图解
3. 如何在启动系统的时候设置JVM参数？
4. 通过案例，学习参数优化设置的预告
5. 昨日思考题解析
6. 今日思考题



**1、前文回顾**

咱们先简单回顾一下目前为止已经学到的内容，现在大家肯定都知道，我们平时代码里创建的对象，都是优先在新生代分配的

然后随着一些方法执行完毕，大部分新生代里的对象就没有人引用了，就成了垃圾对象，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35634000_1562678028.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)

大家可以想象一下，随着代码持续运行，新生代里对象会越来越多，而且里面大部分的对象其实都是那种短生存周期的对象，很快就没有人引用他们了，因此大部分都会是一些垃圾对象。

然后代码继续运行，是不是肯定会创建新的对象分配在新生代里？

肯定是的，所以一旦新生代里内存不够了，就会触发一次Minor GC，把新生代里那些没有人引用的垃圾对象都给回收掉，腾出来内存空间。如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57499700_1562678028.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)

如果是那种在长周期存活的对象，他在新生代里会持续躲过多次垃圾回收，每躲过 一次垃圾回收，年龄会增长1岁

然后当他成为是十多岁的“老年人”的时候，就会被转移到老年代里去，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79177100_1562678028.cn/txdocpic/0/4d4ea63678b59270725c2bf57b7005df/0)

好，到此为止，我们撇开一些特殊情况，至少JVM中基本的内存分配原理，大家就搞清楚了

本周最核心的概念，就是让大家屡清楚短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor GC，然后长生存周期的对象如何转移到老年代里去。



**2、跟JVM内存相关的几个核心参数图解**

本文就不涉及到任何原理性的东西了，直接开始逐步给大家讲解JVM的参数如何设置。

在JVM内存分配中，有几个参数是比较核心的，如下所示。

1. **-Xms**：Java堆内存的大小
2. **-Xmx**：Java堆内存的最大大小
3. **-Xmn**：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了
4. **-XX:PermSize**：永久代大小
5. **-XX:MaxPermSize**：永久代最大大小
6. **-Xss**：每个线程的栈内存大小

下面我们对上述参数来进行一一说明。

-Xms和-Xmx，分别用于设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。

对于这对参数，通常来说，都会设置为完全一样的大小。大家先不用太过于纠结这里的细节，因为其实JVM里的各种技术细节真的太多了，不能一下子全部都搞定，要随着后续几十个案例，层层铺展开来。

但是至少大家需要清楚，这两个参数，是用来**限定Java堆内存的总大小的**，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98941200_1562678028.cn/txdocpic/0/2ec320beb57b6ab3989125446ff8e67f/0)

-Xmn，这个参数也是很常见的，他用来**设置Java堆内存中的新生代的大小**，然后扣除新生代大小之后的剩余内存就是给老年代的内存大小，我们看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/18186900_1562678029.cn/txdocpic/0/6427be1d6cdedecdb553d6e4600580bd/0)

-XX:PermSize和-XX:MaxPermSize，分别**限定了永久代大小和永久代的最大大小**

通常这两个数值也是设置为一样的，至于原因，请看后面结合案例的文章分析。

如果是JDK 1.8以后的版本，那么这俩参数被替换为了-XX:MetaspaceSize和-XX:MaxMetaspaceSize，但是大家至少得知道，这两个参数限定了永久代的大小，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35593600_1562678029.cn/txdocpic/0/58bb148a07b08be2c5dfe56ba1aa0dec/0)

-Xss，这个参数**限定了每个线程的栈内存大小**

大家都很清楚，每个线程都有一个自己的虚拟机栈，然后每次执行一个方法，就会将方法的栈帧压入线程的栈里，方法执行完毕，那么栈帧就会从线程的栈里出栈，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60034100_1562678029.cn/txdocpic/0/f9060eaaabc058f558a2432f924eb3d1/0)



**3、如何在启动系统的时候设置JVM参数？**

那么现在大家结合图示都知道了JVM内存各个区域的大小该使用什么参数来设置，那么到底怎么设置呢？

现在就带着大家来做一些实验

你要是在Eclipse/IntelliJ IDEA里开发代码的话，如果要在这种开发IDE里启动一个程序，然后设置JVM参数，那么就需要对按照下面的步骤来设置：

首先右击你写好的一个带main()方法的类，他有一个菜单栏，里面有一个“**Debug as**”选项，鼠标移动进入，会看到一个“**Debug Configuration**”选项，接着会看到下面的面板。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79304600_1562678029.cn/txdocpic/0/9121baa8cd692145b40650ae03e6711d/0)

这个面板里有一个“**Arguments**”的选项，点击他，会看到下面的图。然后在“VM arguments”中输入你的JVM参数即可

比如你可以按照下面的示例来设置，-Xms之类的参数直接后面跟上你要设置的内存大小，多少M即可。

但是-XX:PermSize这种格式的参数，需要跟一个“=”符号，跟上你要设置的内存大小即可。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/489400_1562678030.cn/txdocpic/0/0eba43af1b132a488e6087f941f8a5c9/0)

那么如果是在线上部署系统应该如何设置JVM参数呢？

其实都很简单，比如说采用“java -jar”的方式启动一个jar包里的系统，那么就可以采用类似下面的格式：

java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar

如果是现在非常流行的那种启动Spring Boot开发的系统呢？

其实都是类似的，大家自行翻阅一下Spring Boot的文档即可。



**4、通过案例，学习参数优化设置的预告**

明天开始，我们会做发布本专栏的第一个案例，就是百万交易的支付系统案例

通过分析一个支付系统的核心业务流程，然后结合我们学习到的JVM相关的知识，来一步步探究，JVM内存相关的这些核心参数，到底在我们上线一个生产系统的时候，针对预估的并发压力，到底应该如何合理的给出一个未经过调优的比较合理的初始值。

另外我们会分析各种参数在设置的时候有哪些考虑的点，Java堆内存到底需要多大？新生代和老年代的内存分别需要多大？永久代和虚拟机栈分别 需要多大？这些我们都结合案例来一步一步的分析。

其实JVM参数到底该如何设置，一定是根据不同的业务系统他具体的一些场景来调整的，不是说有一个通用的配置和模板，照着设就没问题了，那个思路肯定是不对的，也不能干巴巴的告诉你，这个参数应该这样设置，那个参数应该那样设置。

一切都要从案例出发，结合业务场景来分析。



**5、昨日思考题解析**

昨天让大家结合学到的知识，去分析一下自己手头负责的那些业务系统，哪些是短生存周期的对象，哪些是长生存周期的对象

其实就是让大家开始在脑子里建立起来自己负责的系统在JVM中运行时的一个概念图，要有这个意识，才能更好的进行JVM调优。



**6、今日思考题**

给大家留一个思考题，大家都知道平时我们一般部署Java系统，主要以Tomcat部署Web系统居多，现在还更多的是通过Spring Boot来部署系统。

那么大家可以自行去网上查阅一下，Tomcat、Spring Boot部署启动系统的时候，JVM参数如何设置？

然后大家再看看自己公司手头负责的系统，你们部署系统的时候是通过什么方式来设置JVM参数的？

**End**

# 011、案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？

2019-06-25 02:08:29

**案例实战**

**每日百万交易的支付系统，如何设置JVM堆内存大小？**

**目录：**

1. 前文回顾
2. 支付系统背景引入
3. 支付的核心业务流程
4. 每日百万交易的支付系统的压力在哪里？
5. 支付系统每秒钟需要处理多少笔支付订单？
6. 每个支付订单处理要耗时多久？
7. 每个支付订单大概需要多大的内存空间？
8. 每秒发起的支付请求对内存的占用
9. 让支付系统运行起来分析一下
10. 对完整的支付系统内存占用需要进行预估
11. 支付系统的JVM堆内存应该怎么设置？
12. 本文总结
13. 昨日思考题解答
14. 今日思考题



**1、前文回顾**

本文是我们专栏的第一个案例，我将用一个每日百万交易的支付系统作为背景，来给大家分析一下，咱们在上线部署一个系统时，应该如何根据系统的业务量来合理的设置JVM的堆内存大小。

通过之前的文章，大家其实都知道我们写好的代码在JVM中运行的基本原理了，而且也知道通过什么参数可以设置JVM各个内存区域的大小。

但单看之前的文章，大家在自己部署一个线上系统的时候，一定还是会两眼一蒙圈，发现自己压根儿就不知道怎么来设置自己线上系统的JVM内存大小

所以我们通过一个案例来分析一下，教会大家自己负责的线上系统，到底该如何合理设置JVM内存大小。



**2、支付系统背景引入**

先来看看，如果在一个电商系统里，一个支付系统大概应该是一个什么样的位置，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67322600_1562736432.cn/txdocpic/0/f26c652fbdc55848532695111e696e4c/0)

其实只要大家网购过，大概的流程都会非常的清晰，假设我们在一个APP或者一个网站里买东西，大体上都是对一些商品加到购物车里，然后下个订单，接着对订单进行支付，钱从我们的账户划拨到人家网站的账户里去，大致如此。

上面的图就很清晰的展示了这个过程，所谓的支付系统，是一个网站或者APP后台系统中非常核心的一个环节，负责管理公司的资金流

它负责对接用户的支付请求，然后根据用户的付款方式，跟第三方的支付渠道对接起来，比如微信、支付宝，等等。

比如用户通过微信付款88元，那么他的钱在微信钱包里，需要划拨88块到电商公司账户里去，那么此时支付系统就得跟微信支付渠道对接，资金从微信划拨过来，大概的流程就是这个意思。



**3、支付的核心业务流程**

接着我们来讲一下支付的核心业务流程，大家先看下面的图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/78695100_1562736432.cn/txdocpic/0/e3ba379609a9e4b766c3e2fd70ed3e22/0)

通过上图标号序号的步骤，大家可以很清晰的知道这个流程了

首先用户在我们的商城系统提交支付一个订单的请求，接着商城系统把这个请求提交给支付系统，支付系统就会生成一个支付订单，此时订单状态可能是“待支付”的状态。

然后支付系统指引用户跳转到付款页面，选择一个付款方式

然后用户发起实际支付请求，支付系统把实际支付请求转交给第三方支付渠道，比如微信或者支付宝，它们会去处理支付请求进行资金转移。

如果微信或者支付宝处理完支付之后，就会返回支付结果给支付系统，支付系统可以更新自己本地的支付订单的状态变成“已完成”。

当然，其实一个完整的支付系统还包含很多东西。

比如还要负责对账以及跟合作商户之间的资金清算，支付系统得包含应用管理、账户管理、渠道管理、支付交易、对账管理、清算管理、结算管理，等各种功能模块，但是我们这里就关注最核心的支付流程即可。



**4、每日百万交易的支付系统的压力在哪里？**

接着我们来考虑一下，一个每日百万交易的支付系统的压力到底集中在哪里呢？

比如上面的那个核心支付流程，我们的这套系统每日要发生百万次交易。

一般达到百万交易，要不然是国内最大的互联网公司，要不就是一个通用型第三方支付平台，对接各种APP的支付交易。

其实大家通过上图都能明显看到，上述业务流程中，最核心的环节，就是在用户发起支付请求的时候，会生成一个支付订单

这个支付订单需要记录清楚比如是谁发起支付？对哪个商品的支付？通过哪个渠道进行支付？还有发起支付的时间？等等，诸如此类的信息。

如果每日百万交易，那么大家可以想象一下，在我们的JVM的角度来看，就是每天会在JVM中创建上百万个支付订单对象

大家仔细想想，是不是这么回事？如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99498000_1562736432.cn/txdocpic/0/3e67008bf948e409f89ae877a92d6c72/0)

所以我们的支付系统，其实他的压力有很多方面，包括高并发访问、高性能处理请求、大量的支付订单数据需要存储，等等技术难点。

但是抛开这些系统架构层面的东西，单单是在JVM层面，我们的支付系统最大的压力，就是每天JVM内存里会频繁的创建和销毁100万个支付订单，所以这里就牵扯到一个核心的问题。

- 我们的支付系统需要部署多少台机器？
- 每台机器需要多大的内存空间？
- 每台机器上启动的JVM需要分配多大的堆内存空间？
- 给JVM多大的内存空间才能保证可以支撑这么多的支付订单在内存里的创建，而不会导致内存不够直接崩溃？

这就是我们本文要考虑的核心问题。



**5、支付系统每秒钟需要处理多少笔支付订单**

要解决线上系统最核心的一个参数，也就是JVM堆内存大小的合理设置，我们首先第一个要计算的，就是每秒钟我们的系统要处理多少笔支付订单。

假设每天100万个支付订单，那么一般用户交易行为都会发生在每天的高峰期，比如中午或者晚上。

假设每天高峰期大概是几个小时，用100万平均分配到几个小时里，那么大概是每秒100笔订单左右，咱们就以每秒100笔订单来计算一下好了。

假设我们的支付系统部署了3台机器，每台机器实际上每秒大概处理30笔订单。

大家看下面的图，这个图可以反映出来支付系统每秒钟的订单处理压力。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12768400_1562736433.cn/txdocpic/0/6c71e9e4dac98ce455cdb5097f1113d0/0)



**6、每个支付订单处理要耗时多久？**

下一个问题，咱们必须要搞明白的一个事儿，就是每个支付订单大概要处理多长时间？

如果用户发起一次支付请求，那么支付需要在JVM中创建一个支付订单对象，填充进去数据，然后把这个支付订单写入数据库，还可能会处理一些其他的事情

咱们就假设一次支付请求的处理，包含一个支付订单的创建，大概需要1秒钟的时间。

那么大体上你的脑子里可以出现的一个流动的模型，应该是每台机器一秒钟接收到30笔支付订单的请求，然后在JVM的新生代里创建了30个支付订单的对象，做了写入数据库等处理

接着1秒之后，这30个支付订单就处理完毕，然后对这些支付订单对象的引用就回收了，这些订单在JVM的新生代里就是没人引用的垃圾对象了。

接着再是下一秒来30个支付订单，重复这个步骤。



**7、每个支付订单大概需要多大的内存空间？**

接着我们来计算一下，每个支付订单对象大概需要多大的内存空间？

之前的文章里有一个思考题， 已经教过大家这个怎么计算了，其实不考虑别的，你就直接根据支付订单类中的实例变量的类型来计算就可以了。

比如说支付订单类如下所示，你只要记住一个Integer类型的变量数据是4个字节，Long类型的变量数据是8个字节，还有别的类型的变量数据占据多少字节

百度一下都可以查到，然后就可以计算出每个支付订单对象大致占据多少字节。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27154800_1562736433.png)



一般来说，比如支付订单这种核心类，你就按20个实例变量来计算，然后一般大概一个对象也就在几百字节的样子

我们算他大一点好了，就算一个支付订单对象占据500字节的内存空间，不到1kb。



**8、每秒发起的支付请求对内存的占用**

之前说过，假设有3台机器，每秒钟处理30笔支付订单的请求，那么在这1秒内，大家都知道，肯定是有方法里的局部变量在引用这些支付订单的，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/37594500_1562736433.cn/txdocpic/0/c255c9b1f5251dd733c73dd7122e739e/0)

那么30个支付订单，大概占据的内存空间是30 * 500字节 = 15000字节，大概其实也就**15kb**而已。其实是非常非常小的。



**9、让支付系统运行起来分析一下**

现在我们已经把整个系统运行的关键环节的数据都分析清楚了，大家可以大致脑子里思考一下，每秒30个支付请求，创建30个支付订单对象，也就占据kb级别的内存空间而已

然后接着1秒过后，这30个对象就没有人引用了，就成了新生代里的垃圾了。

下一秒请求过来，我们的系统持续的创建支付订单对象，不停在新生代里放入30个支付订单，然后新生代里的对象会持续的累积和增加。

直到有一刻，发现可能新生代里都有几十万个对象了，此时占据了几百MB的空间了，可能新生代空间就快满了。

然后就会触发Minor GC，就把新生代里的垃圾对象都给回收掉了，腾出内存空间，然后继续来在内存里分配新的对象。

这就是这个业务系统的运行模型。



**10、对完整的支付系统内存占用需要进行预估**

之前的分析，全部都是基于一个核心业务流程中的一个支付订单对象来分析的，其实那只是一小部分而已。

真实的支付系统线上运行，肯定每秒会创建大量其他的对象，但是我们结合这个访问压力以及核心对象的内存占据，大致可以来估算一下整个支付系统每秒钟大致会占据多少内存空间。

其实如果你要估算的话，可以把之前的计算结果扩大10倍~20倍。也就是说，每秒钟除了在内存里创建支付订单对象，还会创建其他数十种对象。

那么每秒钟创建出来的被栈内存的局部变量引用的对象大致占据的内存空间就在**几百KB~1MB**之间。

然后下一秒继续来新的请求创建大概1MB的对象放在新生代里，接着变成垃圾，再来下一秒。

循环多次之后，新生代里垃圾太多，就会触发Minor GC回收掉这些垃圾。这就是一个完整系统的大致JVM层面的内存使用模型。



**11、支付系统的JVM堆内存应该怎么设置？**

其实结合支付系统的核心业务流程分析清楚了之后，大家就完全知道这么一个线上系统，每个机器上部署上线的时候，JVM的堆内存应该如何设置了。

其实一般来说这种线上业务系统，常见的机器配置是2核4G，或者是4核8G。

如果我们用2核4G的机器来部署，那么还是有点紧凑的，因为机器有4G内存，但是机器本身也要用一些内存空间，最后你的JVM进程最多就是2G内存

然后这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存可能最多就是个1G多的内存空间。

然后堆内存还分为新生代和老年代，你的老年代总需要放置系统的一些长期存活的对象吧，怎么也得给几百MB的内存空间，那么新生代可能也就几百MB的内存了。

这样的话，大家可以看到，我们上述的核心业务流程，只不过仅仅是针对一个支付订单对象来分析的，但是实际上如果扩大10倍~20倍换成对完整系统的预估之后，我们看到，大致每秒会占据1MB左右的内存空间。

那么如果你新生代就几百MB的内存空间，是不是会导致运行几百秒之后，新生代内存空间就满了？此时是不是就得触发Minor GC了？

其实如果这么频繁的触发Minor GC，会影响线上系统的性能稳定性，具体原因后续再说。

这里大家首先要明白的一点，就是频繁触发GC一定不是什么好事儿。

因此你可以考虑采用4核8G的机器来部署支付系统，那么你的JVM进程至少可以给4G以上内存，新生代在里面至少可以分配到2G内存空间

这样子就可以做到可能新生代每秒多1MB左右的内存，但是需要将近半小时到1小时才会让新生代触发Minor GC，这就大大降低了GC的频率。

举个例子：机器采用4核8G，然后-Xms和-Xmx设置为3G，给整个堆内存3G内存空间，-Xmn设置为2G，给新生代2G内存空间。

而且假设你的业务量如果更大，你可以考虑不只部署3台机器，可以横向扩展部署5台机器，或者10台机器，这样每台机器处理的请求更少，对JVM的压力更小。



**12、本文总结**

本文从一个支付系统案例出发，带着大家一点点计算了这个系统在日百万交易的压力下，部署3台机器的场景下，每秒钟每台机器需要处理多少笔订单，每笔订单要耗时多久处理，每秒钟会对JVM占据多大内存空间，根据这个横向扩展预估整个系统每秒需要占据多大内存空间。

接着根据上述数据模型推算出，在不同的机器配置之下，你的新生代大致会有多大的内存空间，然后在不同的新生代大小之下，多久会触发一次Minor GC

为了避免频繁的GC，那么应该选用什么样的机器配置，部署多少台机器，给JVM堆内存多大的内存空间，新生代多大的内存空间。

根据这套配置，就可以推算出来整个系统的运行模型了，每秒钟创建多少对象在新生代，然后1秒之后成为垃圾，大概系统运行多久，新生代会触发一次GC，频率有多高 。



**13、昨日思考题解答**

昨天让大家思考Spring Boot和Tomcat部署系统怎么设置JVM参数

很多同学都找到了，Spring Boot其实就是启动的时候可以加上JVM参数，Tomcat就是在bin目录下的catalina.sh中可以加入JVM参数

这个题目不难，主要是让大家建立起来一个意识，就是你得关注你部署的系统的JVM参数是怎么来设置的。



**14、今日思考题**

今天开始案例分析环节了，那思考题很简单，大家当然是应该去思考一下自己平时开发的系统：

- 你会去按照本文类似的思路估算系统压力吗？
- 你会去估算系统的JVM内存压力吗？
- 然后会去有针对性的合理设置JVM参数吗？
- 你们之前是这么做的吗？为什么？



上述几个问题，就是今天的思考题。



**End**

# 012、案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？

2019-06-25 02:09:28

**案例实战**

**每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？**

**目录：**

1. 前文回顾
2. 基于案例，说说不合理设置内存的反面示例
3. 大促期间，瞬时访问量增加十倍
4. 少数请求需要几十秒处理，导致老年代内存占用变大
5. 老年代对象越来越多导致频繁垃圾回收
6. 反面案例总结
7. 如何合理设置永久代大小？
8. 如何合理设置栈内存大小
9. 昨日思考题分析
10. 今日思考题



**1、前文回顾**

昨天的文章给大家基于案例分析了一下，如果我们准备上线一个新的系统，如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。

然后基于这个推算出来的JVM内存运转模型，再接着去在系统上线前就选择一个合理的机器配置，要多大内存的机器，另外给JVM堆内存空间一个合理的大小。

其实这是一项非常基础的技能，因为对于大厂工程师，每次上线一个新的系统，他可能上线就会面临很大的访问压力

所以必须要学会合理预估内存压力，然后选择对应的机器配置，并且给出合理的内存大小，希望大家好好掌握。



**2、基于案例，说说不合理设置内存的反面示例**

昨天说的是一个正面的例子，即如何合理的设置内存大小。

今天来说一个反面的不合理设置内存大小导致的问题，也是我们之前线上生产系统真实经历过的一次故障，但是当时不是发生在支付系统中的，是另外一个系统。

不过为了便于大家理解，咱们还是以支付系统作为案例来说明好了，其实思路是一样的。

比如现在我们假设一个前提，就是支付系统因为没有经过合理的内存预估，所以直接选用了1台2核4G的虚拟机来部署了线上系统，而且就只用了一台机器

然后线上JVM给的堆内存大小，仅仅就只有1G，扣除老年代之后，新生代其实就几百MB的内存空间，大家看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42547400_1562852415.cn/txdocpic/0/9b908d3e08623c968b3a82c462515cde/0)

好了，接着我们还是用昨天的那个业务压力，就是每天100万交易，高峰期每秒大概100笔支付交易，对应核心的支付订单对象有100个创建出来，每个支付订单对象占据500左右的字节大小，总共就是50kb左右。

然后一笔交易要1秒来处理，所以这100个对象在新生代中存在1秒的期间会被人引用，是无法被回收的。

而且我们之前说过一个全局预估的思路，从核心的支付订单对象扩展开来，拓展到系统里其他的对象中去，起码可以把内存占用扩大了10倍~20倍

比如我们就扩大个20倍好了，那么说明1秒之内，总共会创建出来大概1MB左右的对象，无法被回收。



**3、大促期间，瞬时访问量增加十倍**

其实按照估算出来的内存压力，你这么小的新生代在系统正常运行的情况下，其实还不算什么大问题

因为每秒新增1MB对象，然后几百秒过后，新生代快满了，自然就会触发Minor GC，回收掉里面99%的垃圾对象。

你要是内存那么小，最多就是发现系统每隔几分钟略微卡顿一下，因为这个时候在进行垃圾回收，会影响系统性能

至于为什么影响系统性能，下周垃圾回收的主题里会分析的。

但是现在我们假设，如果你的电商系统搞大促活动呢？

一般搞大促活动，很可能导致你的压力瞬间增大10倍，因为平时不来你网站的人，今天都来了。

此时可能会发现，每秒钟你的支付系统不是100笔订单了，可能是每秒钟上千笔订单。

这个时候你的系统压力本身就会很大了，不光是内存，尤其是线程资源、CPU资源，都会几乎打满。内存就更是岌岌可危了。



**4、少数请求需要几十秒处理，导致老年代内存占用变大**

咱们就针对内存来分析一下。

现在假设你每秒1000笔交易，那么每秒钟系统对内存的占用增加到10MB以上

我们甚至可以再大胆一点，预估每秒对内存占用达到几十MB，甚至上百MB也可以，因为毕竟大促时流量激增，就一切围绕这来预估。

而且最可怕的一点是，可能你每秒过来的1000笔交易，不再是1秒就可以处理完毕了，因为压力骤增，会导致你的系统性能下降，可能偶尔会出现每个请求处理完毕需要几秒钟，甚至几十秒的时间。

此时我们看下图可能出现什么问题，假设你的新生代里已经积压了很多的数据，都快满了。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54780800_1562852415.cn/txdocpic/0/1bfc18ec1bd17e114db748520933275e/0)

然后呢，此时内存里有比如几十MB的对象都被人引用着，因为少数请求突然处理的特别慢。

为什么会处理特别慢？因为压力太大，导致系统性能太差了，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/64397500_1562852415.cn/txdocpic/0/fe7ea3d9d0fce90a861bf68622234578/0)

这个时候，如果你要再次在新生代里分配对象，那么是不是会导致一次Minor GC去回收新生代？

没错，但是可能回收掉大量的对象之后，那少数几十MB的对象还在，因为少数请求特别的慢。

然后很快新生代继续被填满，再次触发Minor GC，然后少数几十MB的对象还在，此时多次之后后，就会被转移到老年代去，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73571200_1562852415.cn/txdocpic/0/db72be3ab71ce6795ec339ccea8bf7d2/0)



**5、老年代对象越来越多导致频繁垃圾回收**

那么大家思考一下，上述流程如果反复来多次，就是时不时有少数请求特别慢，创建的对象在新生代反复多次没法被回收，然后就会被弄到老年代去

然后后续处理完之后，老年代里的对象就没人引用了，成为了垃圾对象。

经常重复这个流程，老年代里的垃圾对象，是不是就会越来越多？

一旦老年代的垃圾对象越来越多，迟早会满，然后就会触发老年代的垃圾回收，而且这个老年代被占满的频率还很快，可能就会频繁触发老年代的垃圾回收。

大家要知道，老年代的垃圾回收速度是很慢的，这个为什么慢，下周会给大家讲

但是在上述场景下，我们基本可以分析出来，如果你不合理的设置内存，就会导致新生代内存不充足，然后导致很多对象不停的迁移到老年代去，最后导致老年代也要不停的进行垃圾回收。

最后这频繁的垃圾回收，就会极大的影响系统的性能。



**6、反面案例总结**

本文就通过一个支付系统内存设置过小，然后突发巨大的流量压力，突发的性能抖动，最后导致很多对象长期在新生代被人引用，无法被回收，最后持续进入老年代，最后触发老年代内存都频繁占满，然后老年代都频繁被垃圾回收。

这是我们之前另外一个线上系统真实发生的场景，只不过用支付系统作为案例给大家解释了一遍，所以大家更能从反面体会到，不合理的预估 业务系统压力，不合理的设置内存大小，就可能会导致很大的问题。



**7、如何合理设置永久代大小？**

话说回来，如何合理设置永久代大小呢？

其实一般永久代刚开始上线一个系统，没太多可以参考的规范，但是一般你设置个几百MB，大体上都是够用的

因为里面主要就是存放一些类的信息，后面也会用专门的案例给大家分析，什么样的系统容易出现永久代内存溢出。



**8、如何合理设置栈内存大小**

其实这个栈内存大小设置，一般也不会特别的去预估和设置的，一般默认就是比如512KB到1MB，就差不多够了。

这就是每个线程自己的栈内存空间，用来存放线程执行方法期间的各种布局变量的。后面也会用专门的案例演示，栈内存什么时候会发生内存溢出。



**9、昨日思考题分析**

昨天让大家去思考自己平时负责的系统，有没有按照这个思路去预估业务系统压力，然后给一个合理的内存设置

其实就是希望大家以后建立起来一个全面的工程素养，每个合格的工程师，都应该在上线系统的时候，对系统压力做出预估，然后对JVM内存、磁盘空间大小、网络带宽、数据库压力做出预估，然后各方面都给出合理的配置。



**10、今日思考题**

看完今天的文章，我想给大家一个思考题，假设大家手头负责的系统业务量暴增100倍，甚至1000倍，按照我们文章的思路，自己去分析一下，有没有可能出现JVM上的问题？

要是业务真的增长这么多，你应该怎么调整机器配置和JVM内存大小？

# 013、第2周作业：看看你们的线上系统是如何设置JVM内存大小的？

2019-06-25 02:10:10

第2周作业：

看看你们的线上系统是如何设置JVM内存大小的？



本周咱们已经把JVM的工作原理进一步的加深了理解，现在相信大家都知道咱们写好的系统平时运行的时候，都是优先把对象放新生代里，然后新生代满了就垃圾回收

如果有的长期存活的对象，躲过十多次垃圾回收，就进入老年代。

而且我们还结合案例分析了，一个新的系统上线之前，应该怎么去根据系统的线上负载，预估内存使用的压力，然后结合内存使用压力选择合理的机器配置以及JVM堆内存大小。

同时还给了一个反例，如果不合理设置内存，会导致什么样的问题。

**那么本周的作业是什么呢？**

非常简单，希望每个人按照案例里分析的那个过程，把你手头负责的系统的核心业务流程简化、抽象以及梳理出来，看看你们线上的真实负载情况，每秒钟多少请求？

然后根据你们的核心业务流程，看看每秒钟你负责的系统对内存使用的压力有多大？

假如你发现自己负责的系统很Low，没什么压力，那你可以尝试思考一下，如果你系统负载扩大100倍呢？此时对你内存使用压力有多大？

接着你再思考一下，就你的系统内存使用压力之下，目前你们线上机器是多大的堆内存？新生代多大？老年代多大？

如果没设置，可以自行百度默认的内存大小。然后分析一下，目前的这个内存配置，你们的垃圾回收有多频繁？

希望大家对自己手头的系统，严格的去分析一下，这个流程做下来，相信你对JVM的理解，对你负责的系统的理解，对线上系统的内存分配，都会提升一个理解的层次。

# 014、第2周答疑：本周问题答疑，上周作业点评

2019-06-25 02:11:02

**第2周问题答疑**



**问题一：**

既然栈帧存放了方法对应的局部变量的数据也包括了方法执行的其它相关信息，那为什么不把程序计算器那块记录执行的情况，也放在各个方法自己的栈帧里，而是要单独列一个程序计数区去存储呢？请教，谢谢



**答：**

这就是JVM设计者的设计思想了，因为程序计数器针对的是代码指令的执行，Java虚拟栈针对的是放方法的数据，一个是指令，一个是数据，分开设计



**问题二**

对于第二点问题，我理解是在初始化的阶段执行该段代码的，对么？那在执行的时候也是按照jvm执行代码的这套流程来执行的么？ || 老师 1.静态变量是放在什么内存区域呢? 2.然后静态代码块也是会生成一个栈帧然后压栈到当前虚拟机栈中吗,是不是只压栈一次?



**答：**

是在类初始化的时候来执行，但是不是JVM执行代码的流程来执行，他是类初始化，自成一套体系



**问题三**

回答问题：首先该类的所有实例（堆中）都已经被回收；其次该类的ClassLoader已经被回收；最后，对该类对应的Class对象没有任何引用。满足上面三个条件就可以回收该类了。



**答：**

正解



**问题四**

怎么判断离代码的远近？如果是一个mavne聚合工程，两个子工程都定义了这个类，这个时候会加载哪一个？按照classpath的声明顺序吗，先声明先加载？ || 我在使用mybatis时发现有个类不满足要求，于是在项目中新建同包同名类，复制源码然后加上我自己的逻辑，这个时候就会加载我自己写的那个类，而不是mybatis中的类，这是为什么呢？



**答：**

没错，他有一个顺序，你自己的那个代码是最近的，他会优先加载你代码里的那个类



**问题五**

文章很详细，但是对于新手而言还是很抽象。我在学这块的时候都是画了很多内存开辟的流程图。希望老师抽空写一些简单的代码，把内存开辟和初始化，赋值的步骤一步一步画出来。



**答：**

思路很好，同学，但是你是已经有一定了解的，都提到了内存开辟和赋值流程了，其实对新手而言，了解到文章目前的程度就可以了，不能一口气太深，要慢慢来，刚开始浅显易懂一些，接下来逐步深入。



**问题六**

感觉也可以按照回收堆内存对象的思路来思考。方法区的class可以回收，只需要满足任何地方都没有用到该class，即：没有任何实例，没有调用class的静态变量或静态方法，没有利用反射访问class。暂时想到的只有这些，不知道对不对



**答：**

推测基本正确



**问题七**

方法执行完后, 栈帧立马被出栈, 那该栈帧中的变量等数据是立马就被回收掉吗?还是需要等垃圾回收线程扫描到再回收掉?



**答：**

出栈就没了



**问题八**

那如果把public static int flushInterval = Configuration.getInt("xxx");中的static去掉, 那后面的getInt是在什么时候执行的呢 ,我自己测试了一下,好像是在构造方法之前执行的, 不明白这个到底属于什么阶段?



**答：**

这是属于类的对象实例初始化的阶段



**问题九**

双亲委派模型设计的出发点很重要，文章漏了 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

也就是说，，判断2个类是否“相等”，只有在这2个类是由同一个类加载器加载的前提下才有意义，否则即使这2个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这2个类必定不相等。

 基于双亲委派模型设计，那么Java中基础的类，Object类似Object类重复多次的问题就不会存在了，因为经过层层传递，加载请求最终都会被Bootstrap ClassLoader所响应。加载的Object类也会只有一个，否则如果用户自己编写了一个java.lang.Object类，并把它放到了ClassPath中，会出现很多个Object类，这样Java类型体系中最最基础的行为都无法保证，应用程序也将一片混乱



**答：**

这位同学非常不错，对jvm有一定的研究，不过我们第一周的文章，并不是说漏掉你说的这些点，而是我们的写作思路，是循序渐进，这点很重要。

如果在刚开始就给出大段这种说明，那么只有少数人会看懂，回到普通的那种学院派纯理论的知识传递方法了。你说的很好，不过希望耐心跟着继续看，我们会有意把很多细节放在后面讲，循序渐进，保证很多小白同学都轻松学习，这点很重要。



**问题十**

tomcat需要破坏双亲委派模型的原因：

 (1)tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；

 (2)同一个第三方类库的相同版本在不同web应用可以共享

 (3)tomcat自身依赖的类库需要与应用依赖的类库隔离 (3)jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器



**答：**

解答很详细，我们给的一些思考题，其实第二天只会给一些思路，鼓励大家自己查阅资料去思考，给出答案，给一些指引



**问题十一**

老师您好，我想问一下，我们的应用如果关掉，创建在堆中的对象，还有方法区的数据都还在吗



**答：**

应用关了，那么系统对应的JVM进程就没了，那JVM内存区域的数据就全没了



**问题十二**

请问老师：

1、“实例对象都已经从Java堆内存里被回收”和“Class对象没有任何引用”是一个概念么？

2、 “ClassLoader已经被回收”，什么时候会回收？



**答：**

1、不是，Class对象代表类，如果你有变量引用了类的Class对象，那么就是有引用 2、比如你自定义的ClassLoader，本身就是个对象，一旦他没人再使用了，就会被垃圾回收



**问题十三**

引用Class对象的是该类的实例对象？还是其他什么？



**答：**

比如用反射，可以获取一个对象的类的Class对象实例，比如Class clazz = replicaManager.getClass()，就可以通过replicaManager引用的对象，获取到ReplicaManager类的Class对象，那个clazz变量，就可以引用这个Class对象



**问题十四**

栈帧里的数据出栈就没有了，怎么理解？不是垃圾回收线程来回收，那是main线程执行完这个方法就直接将其栈帧里面的数据销毁了吗？



**答：**

没错



**问题十五**

第二周打卡，跟上节奏。今日思考题：项目中托管给Spring管理的对象，带@Configration的配置对象，都是长期存在老年代。自己定义那些pojo对象，如果不被定义为类对象就是朝生夕灭的，所以分配在年轻代里面。



**答：**

非常好，同学



**问题十六**

大多数情况下，方法中的对象都是短生存周期的对象，而实例对象和类对象都是长生存周期的对象。 

猜测一下：spring容器中管理的sington的bean是相对长生存周期的对象，而prototype是短生存周期对象



**答：**

可以多看看你手头负责的系统代码，去分析一下



**问题十八**

public void load(){ A a = new A(); a这个保存地址的变量是存在虚拟机栈的,这个方法执行完成后就销毁了, 那new A()这个对象是需要等待垃圾回收线程扫描后才回收吗?还是和a这个变量同时回收?



**答：**

对象要等待垃圾回收才销毁



**问题十九**

感觉每天篇幅内容太少了，每天都迫不及待期待下一节内容，有点像小时候追看连续剧的感觉



**答：**

要一步一步来，太快内容太多了，不利于消化总结，每周的文章，建议反复看2~3遍，自己配合作业，总结和梳理，学习+复习+作业，才能让你真正消化掉这个知识



**问题二十**

可以自己通过参数设置多大的对象直接放到老年代。 || 对于超大对象直接进入老年代这句话、老师可以给举个栗子吗



**答：**

是的



**问题二十一**

内存不够才会回收软引用对象，内存空间足够的话，不会回收软引用对象。弱引用不管内存空间够不够，只能撑到下次垃圾回收之前，就被会回收。 || gc回收的是软引用，弱应用和虚引用，关于软引用和弱引用傻傻分不清，这两者有何异同，请指教



**答：**

没错



**问题二十二**

大部分是spring容器的对象，spring默认单实例方式加载，这些对象可能会存在老年代中。但是方法内部new出来 对象不会存货太长时间，方法结束，引用消息，对象也会在下一次gc被回收。



**答：**

没错



**问题二十三**

类初始化时，变量引用的是new出来的对象，此时变量引用的对象会被实例化到堆内存吗？



**答：**

会实例化放到堆内存



**问题二十四**

老师好。我今天使用Java VisualVm看了一下，发现了一个问题，我配置的是-Xms4M -Xmx4M -Xmn2M。应该是年轻代2M 老年代2M。

写了一个while循环不断的在方法里创建临时变量对象，但是我发现当内存堆达到3m左右的时候，就发生了Minor GC，堆内存回到了2M，而不是4M的时候，理论上不应该是堆内存满了再Minor GC吗？

然后我老年代里的对象是一个静态的简单对象，这个对象会直接把2M占满嘛？因为每次堆内存都回到2M左右。是我理解的有问题吗？谢谢老师



**答：**

这个很正常的，因为后续第三周会讲新生代的内存结构，就是其实不是新生代全部占满才minor gc，是里面一块主要的内存区域满了，就minor gc



**问题二十五**

堆内存3G,给新生代2G,剩下老年代1G,一般是不是新生代设置得比老年代大？一般比例是多少？如果机器16G,还是这个支付环境，那么老年代还是1G，新生代7G好。还是老年代2G,新生代5G更好？



**答：**

明天会说这个老年代的事儿，别着急



**问题二十六**

打卡。做项目时候没有关注系统压力，主要是考虑功能怎么现实，然后按时交付测试。以后可以按老师今天这个思路去估算一下系统压力了。



**答：**

是的，如果没合理估算内存压力，没合理设置jvm内存大小，那么上线之后，可能会发现频繁gc问题，导致系统卡顿，这是jvm优化的第一步，合理估算业务压力，合理设置内存大小



**问题二十七**

总结: 

\1. 分析系统压力点在哪里？ 

\2. 压力点的每秒请求数？ 

\3. 每个请求耗时？ 

\4. 每个请求消耗的内存？ 

\5. 整个系统的所有请求重复1-4。 

\6. 算出部署多少台机器？每个机器多少内存？ 

思考题: 平时工作中很少这样预估系统压力，一般我的做法都是部署上去后分配一个堆内存，然后测试时再去监控GC的频率做适当调整。这样做确实很被动，很多时候上线后发现和测试的GC频率差太多，以后试试老师这种估算方法。 

这个案例分析的方法很好，虽然很浅，但也能学到东西。希望以后能多多发一些更加全面的案例分析。



**答：**

案例是一步一步来的，每个案例都针对不同的方面和问题，慢慢来，学完几十个案例，你对jvm的内部原理，参数优化，故障解决，就有全面的掌握了



**问题二十八**

上次发生内存溢出，我们搞到凌晨5点多，最后我们老大调大了堆内存解决的，说是由于使用过多的静态内部类，有地方引用到无法释放导致的，不过我现在还没有明白为啥??



**答：**

以后慢慢学习，你也能掌握这种能力



**问题二十九**

这篇文字最重要的收获是分析处理问题的思路，分解然后一步一步分析处理。赞。



**答：**

是的，思路非常的重要，按照这个思路来，你们自己也能做jvm内存压力预估，系统上线前，合理设置一个内存大小



**问题三十**

是不是不应该在高峰期的时候让系统进行垃圾回收，这样会造成STW。老师你们线上系统会考虑在低峰期手动触发垃圾回收么?



**答：**

建议不要手动触发，依托合理的内存设置以及参数优化，让系统自行运转



**问题三十一**

是不是应该通过老师说的估算方式，尽量设大新生代 ，让系统在高峰期不产生gc？



**答：**

是的，尽量是这样



**问题三十二**

老师，那不管三七二十一，在内存大的条件下，多分配给新生代就好了，如果不行就加内存??



**答：**

那你就浪费机器资源，要合理评估，不需要大内存，就用小内存就可以了



**问题三十三**

1、支付系统高分期需要处理的请求是是不是应该这么算：100万 / （24 * 3600） ≈ 12，根据28法则，大部分请求发生在中午12点到13点以及晚上的18点到19点，所以 80万请求 / （2 * 3600） ≈ 111，即算出如果单台每秒大概是100多个请求

 2、还有就是在完整的支付系统内存占用需要进行预估中，你提到“可以把之前的计算结果扩大10倍~20倍。也就是说每秒除了内存里创建的支付订单对象还创建数十种对象” 这里如果要计算的话 之前的计算结果是 30 * 500字节 * 20倍 = 300000字节=300KB 是这么算吗?



**答：**

没错的，这是大致估算的方法



**问题三十四**

老师 您这儿的案例中提到，一个支付请求需要1s中，30个请求也是1s钟，那是不是可以理解为开了30个线程同时并发处理支付请求入库？



**答：**

没错，就是这个意思



**问题三十五**

付订单对象，还创建其他数十种对象。那么计算的方式是不是：30 * 500字节/个 * 放大20倍≈300000字节≈300KB ？ || 

1、支付系统高分期需要处理的请求是是不是应该这么算：100万 / （24 * 3600） ≈ 12，根据28法则，大部分请求发生在中午12点到13点以及晚上的18点到19点，所以 80万请求 / （2 * 3600） ≈ 111，即算出如果单台每秒大概是100多个请求

2、还有就是在完整的支付系统内存占用需要进行预估中，你提到“可以把之前的计算结果扩大10倍~20倍。也就是说每秒除了内存里创建的支付订单对象还创建数十种对象” 这里如果要计算的话 之前的计算结果是 30 * 500字节 * 20倍 = 300000字节=300KB 是这么算吗?



**答**

是的，你学会大致估算系统内存压力的办法了



**问题三十六**

“可能你每秒过来的1000笔交易，不再是1秒就可以处理完毕了，因为压力骤增，会导致你的系统性能下降，可能偶尔会出现每个请求处理完毕需要几秒钟”:老师，这里说的压力骤增是磁盘读写压力吗还是内存CPU压力，出行每个请求处理完毕需要几秒这里是写入压力吗?与网络有关吗?谢谢



**答**

都有可能，主要是CPU负载过高，会导致高并发下每个请求的处理性能直线下降，还有网络问题也会有



**问题三十七**

我们订单一天二百多万，线上正常每秒产生也应该在1M以上，xmn2048，xmx8192,本来半个多小时一次minor gc,扩大一百倍，不到一分钟一次，应该会出现案例中的问题，老年代会频繁gc,不过我们有6g老年代，达到full gc应该时间会稍微长点



**答**

对的，自己分析的非常好，掌握这个方法了



**问题三十八**

我现在的业务遇到的瓶颈是带宽，压测的时候，请求量暴增百倍，上下行带宽瞬间被打满，导致部分业务直接不能用了。。直到慢慢恢复过来



**答**

是的，内存、网络带宽、磁盘IO、数据库，都是系统的瓶颈



**问题三十九**

老师, 可以说下, 为什么并发上来了, 压力就会剧增嘛? 哪些方面的压力.



**答**

并发上来之后，内存、网络带宽、磁盘IO、数据库，都是系统的瓶颈，比如网络带宽打满，你的请求就会排队卡住，磁盘IO变满，数据库性能下降，都会导致请求处理慢几十倍



**问题四十**

您好，我有一个问题，就是main函数中创建了对象，这个对象在堆中开启空间，那么如果这个对象中有成员变量，这个成员变量是存在哪里？成员变量的引用存在哪里



**答**

成员变量也是在堆内存里的



**问题四十一**

看了老师的专栏我觉得讲的非常清晰易懂，学到很多。但是，我这也有一个建议。学习的过程离不开实践，我在想老师能不能提供一个让我们能够模拟出一些问题的方式，然后通过设置jvm的内存分布来解决这个问题，这样会不会更好一些？



**答**

放心，现在你们还学的不够深入，后续大量的案例环节，会给很多示范代码，模拟故障，让你们动手去操作的



**问题四十二**

老师我上网查了一下资料，把问题弄明白了。Test.class是被加载了，但是并没有 执行初始化步骤。 

课程中提到了类加载的时机，但是没有提到类初始化的时机，我把一直理解类的 加载->验证->准备->解析->初始化是一个连续的动作，以为类一旦加载必定 会立即初始化。

补充类初始化的时机如下：

 1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

 2.当调用某个类的静态方法时

 3.当使用某个类或接口的静态字段时

 4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

 5.当初始化某个子类时

 6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)不满足上面6种情况，也就没有做初始化



**答**

对的，就是这样



**问题四十三**

老师 假如Kafka类里面 声明一个实例变量 private ReplicaFetcher = new ... 这个实例变量放在哪个区



**答**

实例变量就在堆内存里



**问题四十四**

很感谢这个平台，这次出去面了3家offer都拿到了，换作以前，是不可能的事情



**答**

加油，坚持学习，每天学习



**问题四十五**

老师 根据示例代码， 我做了以下jvm参数配置：-Xms10m -Xmx10m， 然后在visualVM里跟踪堆栈使用情况。 十分诧异的现象是： 在while true循环中，也就是执行fetchFromRemote的时候， 新生代大小一直在有规律的增长，然后不停的minor GC， 每次GC(而不是等到15次以后)，老年代都会相应的增长一点。 



我的问题是，使新生代增长的到底是什么对象？GC时又是什么对象跑到老年代里去了？ 按我的理解，fetcher对象应该有且只有一份实例，而且while循环中，不会生成新的对象， 最初，新生代里有一份fetcher，然后第16次minor GC的时候，fetcher被转移到老年代， 无论如何，新生代和老年代都不会不断增长。 所以，是不是有什么我不知道的对象混了进去，导致新生代不断增长？



**答**

新生代到老年代转移的机制不只是年龄一种，还有别的，下周会详细说的



**问题四十六**

老师，多谢回复，每个订单处理时间是1秒和10秒，10秒的就要比1秒的要多加内存吗？请问是怎样的逻辑？能否量化？



**答**

那你得计算一下，你的内存每秒被使用的速度，根据这个来规划内存大小，还有你要是10秒一个请求，可能内存里累计起来会有大量对象没法释放，会导致瞬间新生代被打满，而且大量对象没法回收，然后全部去老年代，然后老年代也很快就满了，最后内存不够，很快就内存溢出了



**问题四十七**

生活所迫，比较功利，我这套课程如果能达到老师的预期，我出去找工作要多少合适，我现在20K左右



**答**

跳槽不是一套课程就能搞定的，毕竟这就是一个88的专栏，能帮你搞定面试中的一个技术点而已，如果你要跳槽找好工作，需要系统训练，后续我们会出更多的课程的

# 015、大厂面试题：什么情况下JVM内存中的一个对象会被垃圾回收？

2019-06-25 02:12:45

**大厂面试题**

**什么情况下JVM内存中的一个对象会被垃圾回收？**



**目录：**

1. 什么时候会触发垃圾回收？
2. 被哪些变量引用的对象是不能回收的？
3. Java中对象不同的引用类型
4. finalize()方法的作用
5. 昨日思考题
6. 今日思考题





**1、什么时候会触发垃圾回收？**

通过之前的学习，相信大家都知道一点，平时我们系统运行创建的对象都是优先分配在新生代里的，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76744700_1563092345.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)



然后如果新生代里的对象越来越多，都快满了，此时就会触发垃圾回收，把新生代没有人引用的对象给回收掉，释放内存空间



大家务必注意，这就是新生代一个核心的垃圾回收触发时机，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87752100_1563092345.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)



那么本文就来针对这个过程，再次梳理其中的一些细节，看看触发垃圾回收的时候，到底是按照一个什么样的规则来回收垃圾对象的。



**2、被哪些变量引用的对象是不能回收的？**



首先第一个问题，一旦新生代快满了，那么垃圾回收的时候，到底哪些对象是能回收的，哪些对象是不能回收的呢？



这个问题非常好解释，JVM中使用了一种可达性分析算法来判定哪些对象是可以被回收的，哪些对象是不可以被回收的。



这个算法的意思，就是说对每个对象，都分析一下有谁在引用他，然后一层一层往上去判断，看是否有一个GC Roots。



**这句话相当的抽象，是不是？**



没关系，我们的特点就是一步一图，保证你看明白。



比如最常见的，就是下面的一种情况。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99069400_1563092345.png)



上面的代码其实就是在一个方法中创建了一个对象，然后有一个局部变量引用了这个对象，这种情况是最常见的



此时如下图所示。“main()”方法的栈帧入栈，然后调用“loadReplicasFromDisk()”方法，栈帧入栈，接着让局部变量“replicaManager”引用堆内存里的“ReplicaManager”实例对象。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10438200_1563092346.cn/txdocpic/0/8d169c754c01f0340e3b1d9f40654709/0)

假设现在上图中“ReplicaManager”对象被局部变量给引用了，那么此时一旦新生代快满了，发生垃圾回收，会去分析这个“ReplicaManager”对象的可达性



这时，发现他是不能被回收的，因为他被人引用了，而且是被局部变量“replicaManager”引用的。



在JVM规范中，局部变量就是可以作为GC Roots的



只要一个对象被局部变量引用了，那么就说明他有一个GC Roots，此时就不能被回收了。



另外比较常见的一个情况，其实就是类似下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/25075300_1563092346.png)



大家可以分析一下上面的代码，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36422500_1563092346.cn/txdocpic/0/b54c781435cdcbb11230945ba6d41d32/0)



大家按照上图思考一下，此时垃圾回收的时候一分析，发现这个“ReplicaManager”对象被Kafka类的一个静态变量“replicaManager”给引用了



此时在JVM的规范里，静态变量也可以看做是一种GC Roots，此时只要一个对象被GC Roots引用了，就不会去回收他。



所以说**，一句话总结**：只要你的对象被方法的局部变量、类的静态变量给引用了，就不会回收他们。



**3、Java中对象不同的引用类型**



关于引用和垃圾回收的关系，大家在这里务必有脑子里要引入一个新的概念，那就是Java里有不同的引用类型。



分别是强引用、软引用、弱引用和虚引用。下面分别用代码来示范一下。



强引用，就是类似下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/50919900_1563092346.png)



这个就是最普通的代码，一个变量引用一个对象，只要是强引用的类型，那么垃圾回收的时候绝对不会去回收这个对象的。



接着是软引用，类似下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/61128900_1563092346.png)



就是把“ReplicaManager”实例对象用一个“SoftReference”软引用类型的对象给包裹起来了，此时这个“replicaManager”变量对“ReplicaManager”对象的引用就是软引用了。



正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了



此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。



接着是弱引用，类似下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68680800_1563092345.png)



这个其实非常好解释，你这个弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉。



虚引用，这个大家其实暂时忽略他也行，因为很少用。



其实这里比较常用的，就是**强引用和软引用**，强引用就是代表绝对不能回收的对象，软引用就是说有的对象可有可无，如果内存实在不够了，可以回收他。



**4、finalize()方法的作用**



现在大家理解完了GC Roots和引用类型的概念，基本都知道了，哪些对象可以回收，哪些对象不能回收。



有GC Roots引用的对象不能回收，没有GC Roots引用的对象可以回收，如果有GC Roots引用，但是如果是软引用或者弱引用的，也有可能被回收掉。



接着就是到回收的环节了，假设没有GC Roots引用的对象，是一定立马被回收吗？



其实不是的，这里有一个finalize()方法可以拯救他自己，看下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74343700_1563092346.png)



假设有一个ReplicaManager对象要被垃圾回收了，那么假如这个对象重写了Object类中的finialize()方法



此时会先尝试调用一下他的finalize()方法，看是否把自己这个实例对象给了某个GC Roots变量，比如说代码中就给了ReplicaManager类的静态变量。



如果重新让某个GC Roots变量引用了自己，那么就不用被垃圾回收了。



不过说实话，这个东西没必要过多解读，因为其实平时很少用，就是给大家梳理出来这些细节，让大家清楚而已。



**5、昨日思考题**

上周的思考题和作业是一个意思，就是让大家去思考，自己负责的系统的内存压力，然后就是JVM内存大小是否合理，如果业务暴增100倍，是否会有内存问题。



作业更加详细的提示大家，自己画出核心业务流程图，然后一点点去分析，这是一个非常重要的技能。



其实JVM实战技能里的第一步，就是合理预估系统内存压力，合理设置JVM内存大小。



**6、今日思考题**

思考下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85146400_1563092346.png)

上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？

# 016、大厂面试题：JVM中有哪些垃圾回收算法，每个算法各自的优劣？

2019-06-25 16:37:23

**大厂面试题**

**JVM中有哪些垃圾回收算法，每个算法各自的优劣？**

**目录：**



1、前文回顾

2、复制算法的背景引入

3、一种不太好的垃圾回收思路

4、一个合理的垃圾回收思路

5、复制算法有什么缺点？

6、复制算法的优化：Eden区和Survivor区

7、新生代垃圾回收的各种“万一”怎么处理？

8、昨日思考题解答

9、今日思考题





**1、前文回顾**

上一篇文章我们重新梳理了一下什么时候触发垃圾回收，以及到底哪些对象可以垃圾回收



另外，对新生代填满，GC Roots对象，软引用、弱引用，还有finalize()等概念进行了比较细致的梳理。



那么这篇文章，我们就来看看在对新生代进行垃圾回收的时候，到底是采取一种什么样的算法进行的呢？



**2、复制算法的背景引入**

针对新生代的垃圾回收算法，他叫做复制算法



简单来说，就是如下图所示，首先把新生代的内存分为两块。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75985600_1563166809.cn/txdocpic/0/4dff58baa4fec1b8eb70de41dac17677/0)



接着假设有如下代码，在“loadReplicasFromDisk()”方法中创建了对象，此时对象就就会分配在新生代其中一块内存空间里



而且是由“main线程”的栈内存中的“loadReplicasFromDisk()”方法的栈帧内的局部变量来引用的，如下图所示。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/86348000_1563166809.png)



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96402400_1563166809.cn/txdocpic/0/992fa0baa62cd2989d818aa71cbf0490/0)



接着大家想象一下，假设与此同时，代码在不停的运行，然后大量的对象都分配在了新生代内存的其中一块内存区域里，也只会分配在那块区域里



而且分配过后，很快就失去了局部变量或者类静态变量的引用，成为了垃圾对象



此时如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12270400_1563166810.cn/txdocpic/0/01a079e093b0a75c0eb2b34cc8a340a7/0)



接着这个时候，新生代内存那块被分配对象的内存区域基本都快满了，再次要分配对象的时候，发现里面内存空间不足了。



那么此时就会触发Minor GC去回收掉新生代那块被使用的内存空间的垃圾对象。



那么回收的时候是怎么做的呢？



**3、一种不太好的垃圾回收思路**

假设现在采用的垃圾回收思路，就是直接对上图中被使用的那块内存区域中的垃圾对象进行标记



也就是根据上篇文章讲的那套思路，标记出哪些对象是可以被垃圾回收的，然后就直接对那块内存区域中的对象进行垃圾回收，把内存空出来。



大家想想，这种思路好吗？



这种思路去垃圾回收，可能会在回收完毕之后造成那块内存区域看起来跟下图一样。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26158700_1563166810.cn/txdocpic/0/ce2d7ea98a6c3e8d005955144310c9fe/0)

看上面的图，不知道大家发现什么没有，在那块被使用的内存区域里，回收掉了大量的垃圾对象，但是保留了一些被人引用的存活对象



但是呢，存活对象在内存区域里东一个西一个，非常的凌乱，而且造成了大量的内存碎片。



那么什么是内存碎片呢？



我们再看下面的图我用红线标记出来的区域，那些就是所谓的内存碎片。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38851600_1563166810.cn/txdocpic/0/f7da86e7f0652ee8f0ced04f96bf8a93/0)

看到了吗？在各种凌乱的存活对象的中间，出现了大量的红圈圈出来的内存碎片



这些内存碎片的大小不一样，有的可能很大，有的可能很小。



那么内存碎片太多会造成什么问题呢？



**内存浪费**



啥意思？比如现在打算分配一个新的对象，尝试在上图那块被使用的内存区域里去分配



此时如下图所示，可能因为内存碎片太多的缘故，虽然所有的内存碎片加起来其实有很大的一块内存，但是因为这些内存都是碎片式分散的，所以导致没有一块完整的足够的内存空间来分配新的对象。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51626000_1563166810.cn/txdocpic/0/ae0520de7c821da6ae5023cb0c3c78bb/0)



所以这种直接对一块内存空间回收掉垃圾对象，保留存活对象的方法，绝对是不可取的



因为内存碎片太多，就是他最大的问题，会造成大量的内存浪费，很多内存碎片压根儿是没法使用的。



**4、一个合理的垃圾回收思路**

那么能不能用一种合理的思路来进行垃圾回收呢？



**可以！**这个时候上图中一直没派上用场的另外一块空白的内存区域就出场了。



首先，并不是按照上述思路直接对已经使用的那块内存把垃圾对象全部回收掉，然后保留全部存活对象。



而是先对那块在使用的内存空间标记出里面哪些对象是不能进行垃圾回收的，就是要存活的对象



然后先把那些存活的对象转移到另外一块空白的内存中，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/64122200_1563166810.cn/txdocpic/0/710691fc7149c52eccbeb8bddb9b747c/0)



不知道大家发现这里的玄机没有？



没错，通过把存活对象先转移到另外一块空白内存区域，我们可以把这些对象都比较紧凑的排列在内存里



这样就可以让被转移的那块内存区域几乎没有什么内存碎片，对象都是按顺序排列在这块内存里的。



然后那块被转移的内存区域，是不是多出来一大块连续的可用的内存空间？



此时就可以将新对象分配在那块连续内存空间里了，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83624700_1563166810.cn/txdocpic/0/c79070baf8f1519a0396dfceaff1f267/0)

这个时候，再一次性把原来使用的那块内存区域中的垃圾对象全部一扫而空，全部给回收掉，空出来一块内存区域，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95077100_1563166810.cn/txdocpic/0/b0c24ccd1a57a69e66b76af9a0227eff/0)



这就是所谓的“**复制算法**“，把新生代内存划分为两块内存区域，然后只使用其中一块内存



待那块内存快满的时候，就把里面的存活对象一次性转移到另外一块内存区域，保证没有内存碎片



接着一次性回收原来那块内存区域的垃圾对象，再次空出来一块内存区域。**两块内存区域就这么重复着循环使用。**



**5、复制算法有什么缺点？**

复制算法的缺点其实非常的明显，如果按照上述的思路，大家会发现，假设我们给新生代1G的内存空间，那么只有512MB的内存空间是可以用的



另外512MB的内存空间是一直要放在那里空着的，然后512MB内存空间满了，就把存活对象转移到另外一块512MB的内存空间去



从始至终，就只有一半的内存可以用，这样的算法显然对内存的使用效率太低了。



**6、复制算法的优化：Eden区和Survivor区**

之前我给大家分析过，系统运行时，对JVM内存的使用模型，大体上就是我们的代码不停的创建对象然后分配在新生代里，但是一般很快那个对象就没人引用了，成了垃圾对象。



接着一段时间过后，新生代就满了，此时就会回收掉那些垃圾对象，空出来内存空间，给后续其他的对象来使用。



但是我们之前分析过，其实绝大多数的对象都是存活周期非常短的对象，可能被创建出来1毫秒之后就没人引用了，他就是垃圾对象了。



所以大家可以想象一下，可能一次新生代垃圾回收过后，99%的对象其实都被垃圾回收了，就1%的对象存活了下来，可能就是一些长期存活的对象，或者还没使用完的对象。



所以实际上真正的复制算法会做出如下优化，把新生代内存区域划分为三块：



**1个Eden区，2个Survivor区**，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间，比如说Eden区有800MB内存，每一块Survivor区就100MB内存，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5523900_1563166811.cn/txdocpic/0/c47a4494b5fbdb7431efada0256b42cb/0)



平时可以使用的，就是Eden区和其中一块Survivor区，那么相当于就是有900MB的内存是可以使用的，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29303400_1563166811.cn/txdocpic/0/3448969fb7b050a97dce23f81aaaf4cd/0)



然后如果Eden和一块Survivor都快满了，就会触发垃圾回收



此时就会把Eden区和一块Survivor中的存活对象都一次性转移到另外一块空着的Survivor区。



所以这里大家就能体会到，为啥是这么分配内存空间了。



因为之前分析了，每次垃圾回收可能存活下来的对象就1%，所以在设计的时候就留了一块100MB的内存空间来存放垃圾回收后转移过来的存活对象



比如Eden区+一块Survivor区有900MB的内存空间都占满了，但是垃圾回收之后，可能就10MB的对象是存活的。



此时就把那10MB的存活对象转移到另外一块Survivor区域就可以，然后再一次性把Eden区和之前使用的Survivor区里的垃圾对象全部回收掉，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40603400_1563166811.cn/txdocpic/0/ce048ddd962037a4c3dceae5d0c94b47/0)

接着新对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空着的，就这样一直循环使用这三块内存区域。



这么做**最大的好处**，就是只有10%的内存空间是被闲置的，90%的内存都被使用上了



无论是垃圾回收的性能，内存碎片的控制，还是说内存使用的效率，都非常的好。



**7、新生代垃圾回收的各种“万一”怎么处理？**

这个时候很多人看完了本文之后，一定对这里有可能发生的各种“万一”情况有疑惑了



比如：

- 万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？









- 万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？
- 到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？



别着急，明天就会来分析这些新生代的各种“万一”情况，以及新生代的对象是如何转移到老年代的，然后老年代是如何触发垃圾回收的，垃圾回收的算法又是什么样的。



看完这两篇文章，大家就会对新生代和老年代的对象分配、垃圾回收、对象转移等各种原理，都非常的熟悉了。



**8、昨日思考题解答**

思考下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51144500_1563166811.png)



上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？



明显是不会的，因为ReplicaFetcher对象被ReplicaManager对象中的实例变量引用了，然后ReplicaManager对象被Kafka类的静态变量给引用了



所以垃圾回收的时候，是不会回收掉ReplciaFetcher对象的，否则让存活下来的ReplicaManager对象情何以堪？



**9、今日思考题**

各位还记得之前教给过大家的那个系统对内存使用压力的估算方法么？



可以借助那个方法估算一下，每秒钟系统会使用多少内存空间，然后多长时间会触发一次垃圾回收？



垃圾回收之后，你们系统内大体会有多少对象存活下来？为什么？



然后都有哪些对象会存活下来？存活下来的对象会占多少内存空间？



随着不停的跟着专栏学习，希望大家多结合自己负责的系统来思考，你会养成一个核心能力，能够从JVM的角度去考虑系统运行时的模型



这样在真正发生JVM内存问题的时候，就能有一个非常深入的思考能力去解决问题。

# 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？

2019-06-25 16:38:17

**大厂面试题**

**年轻代和老年代分别适合什么样的垃圾回收算法？**

**目录：**

1. 前文回顾
2. 躲过15次GC之后进入老年代
3. 动态对象年龄判断
4. 大对象直接进入老年代
5. Minor GC后的对象太多，无法放入Survivor区怎么办？
6. 老年代空间分配担保规则
7. 老年代垃圾回收算法
8. 昨日思考题解答
9. 今日思考题





**1、前文回顾**

上篇文章已经给大家讲清楚了新生代的垃圾回收算法，包括跟这个垃圾回收算法搭配的新生代内存区域的划分，大家也都清楚了为什么有一块Eden区域和两块Survivor区域



那么本文就要给大家说说，新生代里的对象一般在什么场景下会进入老年代。



首先我们来看下面的图，我们写好的代码在运行的过程中，就会不断的创建各种各样的对象，这些对象都会优先放到新生代的Eden区和Survivor1区。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24600000_1563288057.cn/txdocpic/0/d9b92f69714c9367d0b164e34a97253b/0)



接着假如新生代的Eden区和Survivor1区都快满了，此时就会触发Minor GC，把存活对象转移到Survivor2区去



如下图所示

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33669500_1563288057.cn/txdocpic/0/01ff42fcc0c2639fa44f5535f5589a56/0)



然后接着就会使用Eden区和Survivor2区，来分配新的对象，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45264400_1563288057.cn/txdocpic/0/d68d168777dc43f832c2dd7ec0dd8995/0)



这个过程上篇文章已经讲的非常的清楚了。那么这篇文章我们就来依次看看各种情况下，对象是如何进入老年代的，以及老年代的垃圾回收算法是什么样的？



**2、躲过15次GC之后进入老年代**



按照上面的图示的那个过程，其实大家可以理解为我们写的系统刚启动的时候，创建的各种各样的对象，都是分配在新生代里的。



然后慢慢系统跑着跑着，新生代就满了，此时就会触发Minor GC，可能就1%的少量存活对象转移到空着的Survivor区中。



然后系统继续运行，继续在Eden区里分配各种对象，大概就是这个过程。



那么之前给大家讲过，我们写的系统中有些对象是长期存在的对象，他是不会轻易的被回收掉的，比如下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56111400_1563288057.png)



只要这个“Kafka”类还存在，那么他的静态变量“replicaManager”就会长期引用“ReplicaManager”对象，所以你无论新生代怎么垃圾回收，类似这种对象都不会被回收掉的。



此时这类对象每次在新生代里躲过一次GC被转移到一块Survivor区域中，此时他的年龄就会增长一岁



默认的设置下，当对象的年龄达到15岁的时候，也就是躲过15次GC的时候，他就会转移到老年代里去。



这个具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67467800_1563288057.cn/txdocpic/0/c6296e51361a1930ec2b6e874213b1e8/0)



**3、动态对象年龄判断**



这里跟这个对象年龄有另外一个规则可以让对象进入老年代，不用等待15次GC过后才可以。



他的大致规则就是，假如说当前放对象的Survivor区域里，相同年龄的一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。



说着有点抽象，具体还是看图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83936800_1563288057.cn/txdocpic/0/8ca1934d51237ac2f84a0359ad1b11e3/0)

假设这个图里的Survivor2区有两个对象，这俩对象的年龄一样，都是2岁



然后俩对象加起来对象超过了50MB，超过了Survivor2区的100MB内存大小的一半了，这个时候，Survivor2区里的大于等于2岁的对象，就要全部进入老年代里去。



这就是所谓的动态年龄判断的规则，这条规则也会让一些新生代的对象进入老年代。



其实说白了，无论是15岁的那个规则，还是动态年龄判断的规则，都是希望那些可能是长期存活的对象，尽早进入老年代



既然你是长期存活的，那么老年代才是属于你的地盘，别赖在新生代里占地方了。





**4、大对象直接进入老年代**



有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。



他的意思就是，如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年代里去。压根儿不会经过新生代。



之所以这么做，就是要避免新生代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入老年代，



那么大的一个对象在内存里来回复制，不是很耗费时间吗？



所以说，这也是一个对象进入老年代的规则。





**5、Minor GC后的对象太多无法放入Survivor区怎么办？**



现在有一个比较大的问题，就是如果在Minor GC之后发现剩余的存活对象太多了，没办法放入另外一块Survivor区怎么办？如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/93224100_1563288057.cn/txdocpic/0/ac4375fb7b1c4adce02b6dcef9b06ba1/0)



比如上面这个图，假设在发生GC的时候，发现Eden区里超过150MB的存活对象，此时没办法放入Survivor区中，此时该怎么办呢？



这个时候就必须得把这些对象直接转移到老年代去，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/2653900_1563288058.cn/txdocpic/0/d1ccf4ed6a79d1de5d38916eb7e5aaea/0)





**6、老年代空间分配担保规则**



这个时候大家又想提一个问题了，如果新生代里有大量对象存活下来，确实是自己的Survivor区放不下了，必须转移到老年代去



那么如果老年代里空间也不够放这些对象呢？这该咋整呢？



别急，一步一图，跟着下面的图来看。



首先，在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。



为啥检查这个呢？因为最极端的情况下，可能新生代Minor GC过后，所有对象都存活下来了，那岂不是新生代所有对象全部要进入老年代？如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11464100_1563288058.cn/txdocpic/0/3269e14f77837ff692fbffda42ab4e76/0)



如果说发现老年代的内存大小是大于新生代所有对象的，此时就可以放心大胆的对新生代发起一次Minor GC了，因为即使Minor GC之后所有对象都存活，Survivor区放不下了，也可以转移到老年代去。



但是假如执行Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了



那么这个时候是不是有可能在Minor GC之后新生代的对象全部存活下来，然后全部需要转移到老年代去，但是老年代空间又不够？



理论上，是有这种可能的。



所以假如Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:-HandlePromotionFailure”的参数是否设置了



如果有这个参数，那么就会继续尝试进行下一步判断。



下一步判断，就是看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。



举个例子，之前每次Minor GC后，平均都有10MB左右的对象会进入老年代，那么此时老年代可用内存大于10MB。



这就说明，很可能这次Minor GC过后也是差不多10MB左右的对象会进入老年代，此时老年代空间是够的，看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21312700_1563288058.cn/txdocpic/0/44fe84f8b3d6913c4f85a181dba0396f/0)



如果上面那个步骤判断失败了，或者是“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“Full GC”，就是对老年代进行垃圾回收，尽量腾出来一些内存空间，然后再执行Minor GC。



如果上面两个步骤都判断成功了，那么就是说可以冒点风险尝试一下Minor GC。此时进行Minor GC有几种可能。



第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor区域即可。



第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小的，此时就直接进入老年代即可。



第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触发一次“Full GC”。



Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。



因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代里面。



如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了



因为内存实在是不够了，你还是要不停的往里面放对象，当然就崩溃了。



这段规则有点烧脑，但是我觉得如果大家仔细对这段文字多看两遍，然后结合我们的图，脑子里想一想，基本都能看懂这个规则。





**7、老年代垃圾回收算法**



其实把上面的内容都看懂之后，大家现在基本就知道了Minor GC的触发时机，然后就是Minor GC之前要对老年代空间大小做的检查



包括检查失败的时候要提前触发Full GC给老年代腾一些空间出来，或者是Minor GC过后剩余对象太多放入老年代内存都不够，也要触发Full GC。包括这套规则，还有触发老年代垃圾回收的Full GC时机，都给大家讲清楚了。



简单来说，一句话总结，对老年代触发垃圾回收的时机，一般就是两个：



要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；



要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。



那么对老年代进行垃圾回收采用的是什么算法呢？



简单来说，老年代采取的是**标记整理算法**，这个过程说起来比较简单



大家看下图，首先标记出来老年代当前存活的对象，这些对象可能是东一个西一个的。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/31260500_1563288058.cn/txdocpic/0/1db631782af595970dd54ce31f156bf5/0)



接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片



然后再一次性把垃圾对象都回收掉，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41766300_1563288058.cn/txdocpic/0/1398e6a418987cb83e383a31bcf9ae68/0)



大家一定要注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。



如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。



所以后面用各种案例给大家展现出来的，就是在各种业务系统的生产故障下，怎么去一步一步分析到底为什么频繁的Full GC，然后怎么来调整JVM的各种参数进行优化。



其实大家如果透彻理解了最近的几篇文章涵盖的JVM的运行原理，就会知道，所谓JVM优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。



关于如何优化JVM，后续会有大量的案例带着大家去实战，而且会给出模拟生产的代码，让大家运行起来看到模拟出来的案发现场是如何导致JVM频繁GC的，对性能是如何影响的，然后再一步一步来优化JVM参数解决性能问题。





**8、昨日思考题**



各位同学还记得之前教给过大家的那个系统对内存使用压力的估算方法么？可以借助那个方法估算一下，每秒钟系统会使用多少内存空间，然后多长时间会触发一次垃圾回收，垃圾回收之后，你们系统内大体会有多少对象存活下来？为什么？都有哪些对象会存活下来？存活下来的对象会占多少内存空间？



昨天留了这个思考题，希望大家跟着文章的思路去好好分析自己手头写的代码，从JVM角度去理解你的代码是如何运行的。



**9、今日思考题**

今天的思考题算是一个小作业，今天的文章稍微有点难，有点烧脑，但是我觉得顺着文章思路和大量的图示，每个人是可以看懂的。



只不过消化起来需要点时间，希望大家今天能够花点时间，梳理出来GC的全流程。



- 到底什么时候会尝试触发Minor GC？
- 触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？
- 什么时候在Minor GC之前就会提前触发一次Full GC？
- Full GC的算法是什么？
- Minor GC过后可能对应哪几种情况？
- 哪些情况下Minor GC后的对象会进入老年代？



希望大家自己通过画图的形式，把这个过程完整的梳理出来，**对这个过程的透彻理解，会成为我们后续进行JVM优化实战的核心基石。**

# 018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？

2019-06-25 16:42:30

**大厂面试题**

**JVM中都有哪些常见的垃圾回收器，各自的特点是什么？**





**1、前文回顾**



上一篇文章我们给大家分析了一下到底什么时候会触发Minor GC，什么时候会让对象从新生代转移到老年代，包括为了新生代转移到老年代的内存足够安全，Minor GC之前要如何检查老年代的内存空间，在什么情况下会触发老年代的Full GC，老年代的垃圾回收算法是什么，这些问题都已经给大家分析清楚了。



这篇文章，我们先接着上篇文章，给大家来一个真实的我们之前一个生产系统的老年代频繁Full GC的案例，让大家更加透彻的理解整个对象分配以及转移到老年代，以及Minor GC和Full GC的全过程。





**2、一个日处理上亿数据的计算系统**



先给大家说一下这个系统的案例背景，大概来说是当时我们团队里自己研发的一个数据计算系统，日处理数据量在上亿的规模。



为了方便大家集中注意力理解这个系统的生产环境的JVM相关的东西，所以对系统本身就简化说明了。



简单来说，这个系统就是会不停的从MySQL数据库以及其他数据源里提取大量的数据，加载到自己的JVM内存里来进行计算处理，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41194200_1563362991.cn/txdocpic/0/a2a44346a04ac9e835c45bc763f5fbe2/0)



这个数据计算系统会不停的通过SQL语句和其他方式从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。



但是这是一套分布式运行的系统，所以生产环境部署了多台机器，每台机器大概每分钟负责执行100次数据提取和计算的任务。



每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间



然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60965600_1563362991.cn/txdocpic/0/0f1c80d13cc35c5a59e006c125ab6471/0)



**3、这个系统到底多块会塞满新生代？**



现在明确了一些核心数据，接着我们来看看这个系统到底多快会塞满新生代的内存空间？



既然这个系统每台机器上部署的实例，每分钟会执行100次数据计算任务，每次是1万条数据需要计算10秒的时间，那么我们来看看每次1万条数据大概会占用多大的内存空间？



这里每条数据都是比较大的，大概每条数据包含了平均20个字段，可以认为平均每条数据在1KB左右的大小。那么每次计算任务的1万条数据就对应了10MB的大小。



所以大家此时可以思考一下，如果新生代是按照8:1:1的比例来分配Eden和两块Survivor的区域，那么大体上来说，Eden区就是1.2GB，每块Survivor区域在100MB左右，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80778800_1563362991.cn/txdocpic/0/27013616e76c608d90f90c4aa8839ad0/0)



基本上按照这个内存大小而言，大家会发现，每次执行一个计算任务，就会在Eden区里分配10MB左右的对象，那么一分钟大概对应100次计算任务



其实基本上一分钟过后，Eden区里就全是对象，基本就全满了。



所以说，回答这个小节的问题，新生代里的Eden区，基本上1分钟左右就迅速填满了。



**4、触发Minor GC的时候会有多少对象进入老年代？**



此时假设新生代的Eden区在1分钟过后都塞满对象了，然后在接着继续执行计算任务的时候，势必会导致需要进行Minor GC回收一部分的垃圾对象。



那么上篇文章给大家讲过这里在执行Minor GC之前会先进行的检查。



首先第一步，先看看老年代的可用内存空间是否大于新生代全部对象？



看下图，此时老年代是空的，大概有1.5G的可用内存空间，新生代的Eden区大概算他有1.2G的对象好了。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21041100_1563362992.cn/txdocpic/0/0c9b3fef4480068f6596d7e497b69f43/0)



此时会发现老年代的可用内存空间有1.5GB，新生代的对象总共有1.2GB，即使一次Minor GC过后，全部对象都存活，老年代也能放的下的，那么此时就会直接执行Minor GC了。



那么此时Eden区里有多少对象还是存活的，无法被垃圾回收呢？



大家可以考虑一下之前说的那个点，每个计算任务1万条数据需要计算10秒钟，假设此时80个计算任务都执行结束了，但是还有20个计算任务共计200MB的数据还在计算中，此时就是200MB的对象是存活的，不能被垃圾回收掉，然后有1GB的对象是可以垃圾回收的



大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41986600_1563362992.cn/txdocpic/0/2c9dd6de204132c1782abb9befc0108f/0)



此时一次Minor GC就会回收掉1GB的对象，然后200MB的对象能放入Survivor区吗？



**不能！**因为任何一块Survivor区实际上就100MB的空间，此时就会通过空间担保机制，让这200MB对象直接进入老年代去，占用里面200MB内存空间，然后Eden区就清空了



大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/55667700_1563362992.cn/txdocpic/0/595cc6ef34ae543070f7c2a199041ada/0)



**5、系统运行多久，老年代大概就会填满？**



那么大家想一下，这个系统大概运行多久，老年代会填满呢？



按照上述计算，每分钟都是一个轮回，大概算下来是每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，然后大概都会有200MB左右的数据进入老年代。



那么大家可以想一下，假设现在2分钟运行过去了，此时老年代已经有400MB内存被占用了，只有1.1GB的内存可用，此时如果第3分钟运行完毕，又要进行Minor GC，会做什么检查呢？如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76842100_1563362992.cn/txdocpic/0/5b5b675f627b6e4079b5a25c51fd7489/0)



此时会先检查老年代可用空间是否大于新生代全部对象？



此时老年代可用空间1.1GB，新生代对象有1.2GB，那么此时假设一次Minor GC过后新生代对象全部存活，老年代是放不下的，那么此时就得看看一个参数是否打开了 。



如果“-XX:-HandlePromotionFailure”参数被打开了，当然一般都会打开，此时会进入第二步检查，就是看看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。



我们已经计算过了，大概每分钟会执行一次Minor GC，每次大概200MB对象会进入老年代。



那么此时发现老年代的1.1GB空间，是大于每次Minor GC后平均200MB对象进入老年代的大小的



所以基本可以推测，本次Minor GC后大概率还是有200MB对象进入老年代，1.1G可用空间是足够的。



所以此时就会放心执行一次Minor GC，然后又是200MB对象进入老年代。



转折点大概在运行了7分钟过后，7次Minor GC执行过后，大概1.4G对象进入老年代，老年代剩余空间就不到100MB了，几乎快满了



如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99420900_1563362992.cn/txdocpic/0/4858e3f283323859740672320cd34233/0)





**6、这个系统运行多久，老年代会触发1次Full GC？**



大概在第8分钟运行结束的时候，新生代又满了，执行Minor GC之前进行检查，此时发现老年代只有100MB内存空间了，比之前每次Minor GC后进入老年代的200MB对象要小，此时就会直接触发一次Full GC。



Full GC会把老年代的垃圾对象都给回收了，假设此时老年代被占据的1.4G空间里，全部都是可以回收的对象，那么此时一次性就会把这些对象都给回收了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/22846400_1563362993.cn/txdocpic/0/dfa1aa67d11adc2344b6eaf6b8f0afe5/0)



然后接着就会执行Minor GC，此时Eden区情况，200MB对象再次进入老年代，之前的Full GC就是为这些新生代本次Minor GC要进入老年代的对象准备的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45332900_1563362993.cn/txdocpic/0/ff8e4614f20b8854780172685c53ea1c/0)



按照这个运行模型，基本上平均就是七八分钟一次Full GC，这个频率就相当高了。因为每次Full GC速度都是很慢的，性能很差，而且明天的文章会告诉大家，为什么Full GC的时候会严重影响系统性能。





**7、该案例应该如何进行JVM优化？**



相信通过这个案例，大家结合图一路看下来，对新生代和老年代如何配合使用，然后什么情况下触发Minor GC和Full GC，什么情况下会导致频繁的Minor GC和Full GC，大家都有了更加深层次和透彻的理解了。



对这个系统，其实要优化也是很简单的，因为这个系统是数据计算系统，每次Minor GC的时候，必然会有一批数据没计算完毕



但是按照现有的内存模型，最大的问题，其实就是每次Survivor区域放不下存活对象。



所以当时我们就是对生产系统进行了调整，增加了新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代



这样Survivor区大概就是200MB，每次刚好能放得下Minor GC过后存活的对象了，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56883800_1563362993.cn/txdocpic/0/c6dd4fa67166c92a852d81497602b4bd/0)



只要每次Minor GC过后200MB存活对象可以放Survivor区域，那么等下一次Minor GC的时候，这个Survivor区的对象对应的计算任务早就结束了，都是可以回收的了



此时比如Eden区里1.6GB空间被占满了，然后Survivor1区里有200MB上一轮 Minor GC后存活的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70308800_1563362993.cn/txdocpic/0/1529a0eb09d15c59499ee08fdaf539a7/0)



然后此时执行Minor GC，就会把Eden区里1.6GB对象回收掉，Survivor1区里的200MB对象也会回收掉，然后Eden区里剩余的200MB存活对象会放入Survivor2区里，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89497000_1563362993.cn/txdocpic/0/6ea6749024c342adef6918b21d3751f6/0)



以此类推，基本上就很少对象会进入老年代中，老年代里的对象也不会太多的。



通过这个分析和优化，定时我们成功的把生产系统的老年代Full GC的频率从几分钟一次降低到了几个小时一次，大幅度提升了系统的性能，避免了频繁Full GC对系统运行的影响。



**8、垃圾回收器简介**



在新生代和老年代进行垃圾回收的时候，都是要用垃圾回收器进行回收的，不同的区域用不同的垃圾回收器。



垃圾回收器是下周和下下周的重点内容，到时候会深入分析我们常用的ParNew、CMS和G1三种垃圾回收器的工作原理和优缺点。



这篇文章先简单给大家介绍一下：



**Serial和Serial Old垃圾回收器：**分别用来回收新生代和老年代的垃圾对象



工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。



**ParNew和CMS垃圾回收器：**ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。下周会着重分析这两个垃圾回收器。



**G1垃圾回收器：**统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，是下下周的重点，一周都会来分析G1垃圾回收器的工作原理和优缺点。



大家本周的重点，就是透彻理解新生代和老年代的对象分配以及垃圾回收的触发时机和运行机制，然后简单了解有哪些垃圾回收器即可。



明天会给大家讲垃圾回收最让人讨厌的**Stop The World**是怎么回事。



经过本周的学习，相信大家从原理层面对JVM有一个更加深入的认识。



**9、昨日思考题**



- 到底什么时候会尝试触发Minor GC？
- 触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？
- 什么时候在Minor GC之前就会提前触发一次Full GC？
- Full GC的算法是什么？
- Minor GC过后可能对应哪几种情况？
- 哪些情况下Minor GC后的对象会进入老年代？



昨天让大家把这个过程自己详细的梳理出来，相信看了今天的文章，理解的就更加透彻了。



**10、今日小作业**



本文是一个非常经典的真实生产案例和优化实践经验，建议大家不要光看，自己把今天的案例，从背景到分析到解决，一步一步自己画图来推演一遍，彻底吃透这个案例。



这对大家以后分析更多的JVM案例和优化，有非常好的作用

# 019、“Stop the World”问题分析：JVM最让人无奈的痛点！

2019-07-19 07:00:00



**1、前文回顾**



上一篇文章已经通过一个真实的案例分析了新生代的对象分配以及如何转移到老年代，如何频繁触发Full GC的一个场景，同时给出了优化的说明



相信大家通过上一篇文章就已经非常深刻的理解了JVM的核心运行原理了。



这篇文章我们就来讨论一下基于JVM运行的Java系统，最让我们Java工程师内心痛苦的到底是个什么问题？





**2、先来回顾一个新生代GC的场景**



大家先来看下面的图，新生代的内存大家都知道是分为Eden和两个Survivor的。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8865200_1563439787.cn/txdocpic/0/1128cbe6782d0e9dac8777de1bb38935/0)

那么此时如果系统不停的运行，然后把Eden给塞满了呢？如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26042500_1563439787.cn/txdocpic/0/a41ddcf0c02216216d04e62ec01cd07f/0)

这个时候势必就会触发Minor GC了，好，那么之前给大家说过，进行垃圾回收是有专门的垃圾回收线程的，而且对不同的内存区域会有不同的垃圾回收器，大家还记得这个事儿吗？



相当于垃圾回收线程和垃圾回收器配合起来，使用自己的垃圾回收算法，对指定的内存区域进行垃圾回收，大家看看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52156700_1563439787.cn/txdocpic/0/5b2a2c74597f3bb4f81c21ef23d0a16b/0)



通过上面这个图，大家对垃圾回收线程、垃圾回收器以及垃圾回收算法，是不是就有了一个非常清晰的关系的认识了？



没错，垃圾回收一定会通过一个后台运行的垃圾回收线程来执行他具体的一个逻辑



比如针对新生代我们会用ParNew垃圾回收器来进行回收，然后ParNew垃圾回收器针对新生代采用的就是复制算法来垃圾回收。



这个时候垃圾回收器，就会把Eden区中的存活对象都标记出来，然后全部转移到Survivor1去，接着一次性清空掉Eden中的垃圾对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/77248100_1563439787.cn/txdocpic/0/64d6b42ffb7e996605660a7d550794d3/0)



接着系统继续运行，新的对象继续分配在Eden中，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/94319600_1563439787.cn/txdocpic/0/3a674f6f57a2c2ab8a4ce5f4443511e9/0)



当Eden再次塞满的时候，就又要触发Minor GC了，此时已然是垃圾回收线程运行垃圾回收器中的算法逻辑，也就是采用复制算法逻辑，去标记出来Eden和Survivor1中的存活对象



然后一次性把存活对象转移到Survivor2中去，接着把Eden和Survivor1中的垃圾对象都回收掉，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11657100_1563439788.cn/txdocpic/0/193a23eef2b80e99108694d4973e6a49/0)

**3、GC的时候还能继续创建新的对象吗？**



不知道大家有没有考虑过一个问题，之前我们一直都是说GC的原理和JVM整体运行的机制



但是从来没说过在GC的时候，到底我们写好的Java系统在运行期间还能不能继续在新生代里创建新的对象了？



大家可以自己思考一下，假设允许在GC期间，然后还可以继续让系统在新生代的Eden区里创建新的对象，会是一个什么样的场景？



大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33767300_1563439788.cn/txdocpic/0/3f5c8776b548b08b6cadde7dcd62fc49/0)



根据上图所示，如果一边垃圾回收器在想办法把Eden和Survivor2里的存活对象标记出来转移到Survivor1去，然后还在想办法把Eden和Survivor2里的垃圾对象都清理掉，结果这个时候系统程序还在不停的在Eden里创建新的对象。



这些新的对象有的很快就成了垃圾对象，有的还有人引用是存活对象，那现在咋办？



全部乱套了，对于程序新创建的这些对象，你怎么让垃圾回收器去持续追踪这些新对象的状态？



怎么想办法在这次垃圾回收的过程中把新对象中的那些存活对象转移到Survivor2中去？



怎么想办法把新创建的对象中的垃圾都给回收了？



有的同学可能会想当然的说，那就想办法让垃圾回收器来做到啊！



我只能说，大家可以去搞清楚JVM的运行原理，但是不要随意去质疑人家JVM的垃圾回收机制为什么不去那么设计。



因为有些事情想着很简单，但是一旦你要在JVM中去实现的时候，会发现务必的复杂，成本极高，而且很难做到。



所以说，在垃圾回收的过程中，同时还允许我们写的Java系统继续不停的运行在Eden里持续创建新的对象，目前来看是非常不合适的一个事情。



**4、JVM的痛点：Stop the World**



所以现在大家就好理解了，我们平时使用JVM最大的痛点，其实就是在垃圾回收的这个过程



因为在垃圾回收的时候，尽可能要让垃圾回收器专心致志的干工作，不能随便让我们写的Java系统继续对象了，所以此时JVM会在后台直接进入“Stop the World”状态。



也就是说，他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！



然后让垃圾回收线程可以专心致志的进行垃圾回收的工作，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52177800_1563439788.cn/txdocpic/0/4d5ef76c8ce392f50e4156d2774c718c/0)

这样的话，就可以让我们的系统暂停运行，然后不再创建新的对象，同时让垃圾回收线程尽快完成垃圾回收的工作，就是标记和转移Eden以及Survivor2的存活对象到Survivor1中去，然后尽快一次性回收掉Eden和Survivor2中的垃圾对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79799200_1563439788.cn/txdocpic/0/3ced8eda6d01e98200b95d5c8c1210f3/0)



接着一旦垃圾回收完毕，就可以继续恢复我们写的Java系统的工作线程的运行了，然后我们的那些代码就可以继续运行，继续在Eden中创建新的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/358600_1563439789.cn/txdocpic/0/898af1ab808606ae42691e17edd13386/0)



**5、Stop the World造成的系统停顿**



现在大家就很清晰“Stop the World”会对系统造成的影响了， 假设我们的Minor GC要运行100ms，那么可能就会导致我们的系统直接停顿100ms不能处理任何请求



在这100ms期间用户发起的所有请求都会出现短暂的卡顿，因为系统的工作线程不在运行，不能处理请求。



假设你开发的是一个Web系统，那么可能导致你的用户从网页或者APP上点击一个按钮，然后平时只要几十ms就可以返回响应了



现在因为你的Web系统的JVM正在执行Minor GC，暂停了所有的工作线程，导致你的请求过来到响应返回，这次需要等待几百毫秒。



那么大家可以思考一下，回忆一下上篇文章讲到的案例，因为内存分配不合理，导致对象频繁进入老年代，平均七八分钟一次Full GC，而Full GC是最慢的，有的时候弄不好一次回收要进行几秒钟，甚至几十秒，有的极端场景几分钟都是有可能的。



那么此时一旦你频繁的Full GC，难道你希望你的系统每隔七八分钟就卡死个30秒吗？



在30秒内任何用户的请求全部卡死无法处理，然后用户看到的都是系统超时之类的提示，这会让用户体验极差



所以说，无论是新生代GC还是老年代GC，都尽量不要让频率过高，也避免持续时间过长，避免影响系统正常运行，这也是使用JVM过程中一个最需要优化的地方，也是最大的一个痛点。



**6、不同的垃圾回收器的不同的影响**



接着今天的话题，再来延伸说一下昨天提到的那些垃圾回收器



比如对新生代的回收，Serial垃圾回收器就是用一个线程进行垃圾回收，然后此时暂停系统工作线程，所以一般我们在服务器程序中很少用这种方式。



但是我们平时常用的新生代垃圾回收器是ParNew，他针对服务器一般都是多核CPU做了优化，他是支持多线程个垃圾回收的，可以大幅度提升回收的性能，缩短回收的时间



所以下周我们深入分析这块的时候，会告诉大家他的很多参数该如何优化



大致原理图如下

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20663800_1563439789.cn/txdocpic/0/b489262a7939856e34fdff6019fac936/0)



大家可以看到，不同的垃圾回收器他会有不同的机制和原理，使用多线程或者单线程，都是有区别的。



然后包括之前给大家提到的CMS垃圾回收器，专门负责老年代的垃圾回收，他也有自己特殊的一套机制和原理，非常的复杂



下周会深入讲CMS垃圾回收器的原理和参数优化，他也是基于多线程的，而且可以使用一套独特的机制尽可能的在垃圾回收的过程中减少“Stop the World”的时间，避免长时间卡死我们的系统。



包括下下周要深入剖析的现在很多公司都在使用的最新的G1垃圾回收器，他更是将采用复杂的回收机制将回收性能优化到机制，尽可能更多的降低“Stop the World”的时间。



其实JVM本身的迭代演进，就是不断的在优化垃圾回收器的机制和算法，尽可能的降低垃圾回收的过程对我们的系统运行的影响。



而我们作为一个合格的Java工程师，我们的责任就是尽可能搞懂这些垃圾回收器的运行机制和算法



然后合理的对线程系统优化内存分配和垃圾回收，尽可能减少垃圾回收的频率，降低垃圾回收的时间，减少垃圾回收对系统运行的影响。



所谓的JVM优化，其实指的就是这个。后续我们会结合大量的案例展开



相信大家一旦坚持3个多月学习完这个专栏，一定会从此脱胎换骨，对JVM的运行原理，垃圾回收机制，然后各种生产故障的监控、排查、定位、分析和解决，都有一个本质的能力提升，在公司里绝对可以搞定自己负责的生产系统的JVM故障。



**7、昨日思考题**

昨天给大家分析了一个经典的案例，是一个非常经典的真实生产案例和优化实践经验



建议大家不要光看，自己把今天的案例，从背景到分析到解决，一步一步自己画图来推演一遍，彻底吃透这个案例。



这对大家以后分析更多的JVM案例和优化，有非常好的作用。



**8、今日思考题**

给大家一个小小思考题：到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？



大家想想，明天给出答案。

**End**

# 020、第3周作业：自己动手画出各种垃圾回收算法和垃圾回收器的原理图

 2019-07-20 07:00:00





第3周作业：

自己动手画出各种垃圾回收算法和垃圾回收器的原理图



本周的作业非常重要，大家务必认真去做，因为这决定了大家是否吃透本周的内容，也决定了大家是否有足够扎实的基础去研究后续大量的优化案例。



本周希望大家自己画一幅非常完整的图，把以下流程全部画清楚：



- 对象在新生代的分配
- 什么时候会触发Minor GC
- 触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小
- 如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小
- 什么情况下Minor GC之前会提前触发Full GC
- 什么情况下会直接触发Minor GC
- Minor GC之后有哪几种情况对象会进入老年代



大家可以画一幅完整的图，然后配合大量的文字说明，一点一点条理清晰的把JVM的核心运行流程全部梳理清晰，这将成为后续研究JVM优化的坚实基础。

#   021、第3周答疑：本周问题答疑，上周作业点评

 2019-07-21 07:00:00





**第3周答疑问题汇总**





**问题**

一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



我的回答: 

1)加大分代年龄，比如默认15加到30; 



2)修改新生代老年代比例，比如新生代老年代比例改成2:1 



3)修改e区和s区比例，比如改成6:2:2 面试官说他们内部服务已经做到fullgc次数为0，只做ygc



想听听老师的意见



**答：**其实对这个面试题，非常的简单，需要深度结合线上系统的实际运行来看，你如果把本周文章全部看懂了，那么可以轻易回答这个问题。



首先上线系统之后，要借助一些工具（后面会讲）观察每秒钟会新增多少对象在新生代里，然后多长时间触发一次Minor GC，平均每次MInor GC之后会有多少对象存活，Survivor区是否可以放的下。



这里的关键点就是必须让Survivor区放下，而且不能因为动态年龄判定规则直接升入老年代。然后只要Survivor区可以放下，那么下次Minor GC后还是存活这么多对象，依然可以在另外一块Survivor区放下，基本就不会有对象升入老年代里去。



我们的案例其实也是做了类似的优化，几乎消灭了Full GC。包括一些检查参数如何设置





**问题：**

老师，我们公司的项目是一个数据采集解析的系统。对于每一条采集的数据都会封装成一个对象放到缓存中，然后继续走后续的流程。



假设一个对象（包含原始日志，扩展信息）有1kb大小。一秒一万数据量的话就是一秒将近10mb。然后如果一台给的4g内存给新生代内存。



那么400秒就会触发gc。请问这样算对吗？有什么优化的手段吗？之前开发重来没有考虑过gc问题



**答：**是的，还得考虑你每条消息需要处理多长时间，如果发生GC，最多可能有多少数据是被引用的，无法回收





**问题**

我总结了本周所学的知识，得出一套演算过程和公式，请看一下是这样吗？



每台机器可以提供给JVM的最大内存： each_m，比如2核4G机器，可提供JVM最大内存2G 栈占用：stack_m = QPS估值 * 1M * 20倍数，估值30QPS，栈约为600M 



新生代以30分钟一次GC计算总内存：30(Monitor GC间隔) * 60 * QPS估值 * 接口内存估值,young_m 所需机器数量，假设等于N 



方法区：200M，一般够用，method_m 老年代：500M，一般不大，300M也行，像我们结算服务，100M都够用



old_m 演算公式: JVM最大内存*N = stack_m + young_m + old_m + method_m * N 机器数N，也同时估算出来，是这样吗



**答：**是这样，总结的非常好





**问题**

老师，在上面看到一句，gc回收的是软引用，弱应用和虚引用，对吗？



还有我记得jvm是自动去垃圾回收的，程序员没法指定，现在加上弱引用，是去指定回收吗



**答：**不是的，软引用，弱引用之类的，只不过是指定哪些对象可以回收而已





**问题**

当初始化静态变量replicaManager的时候，replicaManager成员变量也会初始化，按今天课程的理解，有静态变量引用，所以不会回收。不知道我的理解是否正确。



**答：**理解正确





**学员思考题回答：**

**思考题：**

**![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/78545800_1563545979.png)**



上述代码下，如果垃圾回收，会回收ReplicaFetcher对象吗？为什么？



**学员回答：**不会回收，ReplicaFecher对象被replicaFetcher强引用，而ReplicaManager对象又被可作为GC ROOT的replicaManager强引用



所以ReplicaFetcher对象可以向上找到GCROOT，因此不会回收





**学员思考题回答：**

对于新生代内存清理，首先是栈桢出栈，新生代的引用对象消失，然后就是minoc gc 垃圾回收



**问题**

老师您好！有个问题想不明白！



比如在方法里有个局部变量A a= new A()，变量a存储在当前方法的栈帧的局部变量表，实例对象存储在堆里！ 在执行到该方法时创建了实例对象



当方法结束后，虚拟机栈都会清空，刚刚执行方法时创建的对象在gc时不会清除？为啥呢，留着还有用吗！那下次再调用这个方法时还会new新的对象啊！想不太明白！



**答：**此时不会，此时仅仅是对象没人引用而已，要等待垃圾回收的时候给回收掉



**问题**

打卡。今天内容很简单，不过有一个疑问，就是存活对象在移动的时候内存地址不会发生改变吗？句柄引用的内存地址到底是不是一个固定的值？



**答：**内存地址会改变



**问题**

在给新建对象分配内存的时候，被利用的survivor区和Eden区这90%可以看做一个整体，新建对象可以分配到被利用的survivor区，也可以分配到Eden区，只有垃圾回收进行复制的时候才会明显区分出survivor区的作用，这样理解对吗？



**答：**

对的，理解正确





**问题**

您好，关于内存大小估算这块，您说可以把之前的计算结果扩大10倍~20倍。



也就是说，每秒钟除了在内存里创建支付订单对象，还会创建其他数十种对象。



为什么是10倍~20倍，为什么您不估算5倍，不估算50倍，每秒中除了在内存里创建支付订单对象，还会创建其他数十种对象这个思路是怎么来的?



望回复，谢谢，如果我们出去面试的话，可能有些面试官会这么问的



**答：**这是一个经验值，是根据那个支付案例来说的，其实核心含义不是让大家记住这个10~20倍的数字，而是应该你自己根据自己的系统来考虑



不同的系统都是不一样的，你只要把你负责的系统大致看看，就知道他每秒请求过来，会连带创建多少种对象，大致其实就估算出来了



**问题**

老师讲的思路很清晰，从优缺点分析，有浅入深，能否解答一下：eden区和survivor区 对象是通过什么规则被分配到这两个区的呢？还是说是随机分配



**答：**优先分配到Eden区，Survivor区是用来放每次GC过后的那些存活对象的



**问题**

有个地方描述不够严谨吧。比如：接着新对象继续分配在Eden区和另外那块开始被使用的survivor区，然后始终始终保持一块survivor区是空着的。



这个应该没有survivor区是空的吧，之前垃圾回收后不是剩余的存活的对象已经被移动到另一块survivor区了吗？它里面并不是空的啊?是不是这样呢老师



**答：**假设Eden区和Survivor1区里有对象，一次Minor GC过后，存活对象全部进入Survivor2区域



接着新对象继续在Eden区里分配，Survivor2里放之前Minor GC后存活的对象，然后Survivor1区是空的。



下一次Minor GC过后，剩余存活对象进入Survivor1区里，然后Survivor2区就是空的了。





**问题**

"接着新的对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空的"



那么老师，程序在刚刚启动的时候，第一次创建对象时也会分配到Eden区和其中一个Survivror区吗？ 



还是说只分配到Eden区，此时发现Eden区满了，其他两个survivor区还是空的情况下，触发第一次小GC？



**答：**只分配到Eden区的，然后第一次Minor GC后会转移存活对象到一块Survivor去





**问题**

问个问题，为什么老年代不采用复制算法，像新生代那样一个E两个S呢，或者说为什么新生代不采用标记整理算法呢？还有就是标记清除算法会产生内存碎片，那jvm中是在哪里用到了



**答：**老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。





**问题**

今天的内容比起之前的逻辑性强很多，需要好好思考和梳理一下，感谢老师一步一步带着我们由浅入深。



**答：**加油，继续坚持



**问题**

两个问题：

1. 假设MinorGC之前老年代空间担保成功，但是实际不幸的是MinorGC之后老年代放不下而触发了FullGC，之后马上又会伴随一次MinorGC是吗，相当于短时间内进行了两次MinorGC，有这个必要吗？ 

   

   

2. 老年代为什么用标记整理算法？优势在哪里



**答：**

1、多一次Minor GC没什么，他速度很快 



2、老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。





**问题**

大神，默认情况下，新生代占整个堆的3/8，实际情况我们新生代大小占多少合适，我看你在这个支付系统给的是2/3，我们系统在压测的时候，yong gc明显，我把新生代调整为一半了



**答：**这个新生代设置为多少，其实没有固定的大小，需要自己根据实际系统运行情况来调节





**学员的思考题作答：**

**1、到底什么时候会尝试触发Minor GC？**

 新生代剩余内存空间放不下新对象，此时需要触发GC。



触发MinorGC情况有: 

1- 新生代现有存活对象小于老年代剩余内存 ，即老年空间代足以支撑可能晋升的对象 

2- 情况1不成立，查看设置了空间担保且可以担保成功 



**2、触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？** 

1、判断新生代存活是否大于老年代剩余 

2、条件1成立且设置空间担保的情况下，判断老年代剩余是否大于之前进入老年代平均存活大小 



**3、什么时候在Minor GC之前就会提前触发一次Full GC？** 

新生代现有存活对象>老年代剩余内存情况下，未设置空间担保 或 空间担保失败



**4、Full GC的算法是什么？** 

标记整理算法，速度很慢 



**5、Minor GC过后可能对应哪几种情况？** 

放入新对象前进行判断，新对象大小+存活对象是否可以分配在新生代。可以则放入，否则判断是否可以放入老年代。可以则放入，否则 OOM



**6、哪些情况下Minor GC后的对象会进入老年代？** 

新生代放不下，老年代可以放下的情况下





**问题**

先说一下问题： 

1、MinorGC后，存活对象大于survivor区域，小于老年代可用空间，是所有对象都进入老年代，还是一部分



如果所有的对象都进入，是不是会有一些浑水摸鱼？



比如新建的对象，刚好一次MinorGC后还存活，也就是说年龄只有1岁的对象进入老年代，这些对象可能在第二次MinorGC就可以回收，只是正好赶上了这趟车，这样进入老年代没一会就成为垃圾对象了



2、记得之前讲的说设置堆内存，新生代一般是比老年代大的。新生代如果触发MinorGC，表示这新生代满了



一般情况下，新生代满了，对象占用内存肯定是大于老年代可用空间的



所以不明白MinorGC前检查老年代可用空间是否大于新生代所有对象内存，大部分情况下，这个检查的结果都为true呀。难道只是为了文中所说的，规避极端情况吗？



那我直接进行-XX:-HandlePromotionFailure，之后进行FullGC，或MinorGC，如果是极端情况，再抛出OOM，这样不也很好吗。 请老师指点一下 



**下面是我的今日思考题回答：**

1、

Eden区和存对象的Survivor区满的时候触发MinorGC 



2、

检查新生对所有对象所占空间是否大于老年代可用空间， 如果小于，进行MinorGC。 



如果大于，查看"-XX:-HandlePromotionFailure"是否设置。



如果没设置，进行FullGC。如果设置如果没设置，进行FullGC。



如果设置，判断老年代空间是否大于之前MinorGC后进入老年代对象的平均大小。 如果大于，进行MinorGC。 如果小于，进行FullGC。 



3、

(1)新生代对象大小大于老年代空间，且没有设置"-XX:-HandlePromotionFailure" 



(2)设置了"-XX:-HandlePromotionFailure"，老年代可用空间小于之前每次MinorGC后进入老年代的平均大小



 4、

标记整理算法，老年代对象存活时间较长，赋值算法不太适合，标记-清理算法会产生内存碎片。标记整理可以规避。 



5、

(1)小于Survivor区域，进入Survivor区域



(2)大于survivor区域，小于老年代可用空间，进入老年代 



(3)大于survivor区域，大于老年代可用空间，进行FullGC，如果FullGC后，老年代可用空间仍小于存活对象，抛出OOM 



6、 

(1)经过15次(默认，可以设置)MinorGC的 



(2)某个年龄的对象大于survivor区域的



**答：**

1、所有对象都进入老年代 



2、不见得，新生代和老年代谁大谁小，看具体场景怎么设置，老年代更大其实很正常，所以一般要设置那个参数，突破第一重检查的限制



**问题**

是每次Minor GC之前都会去检查是否老年代的大小大于新生代所有内存的大小？还是每次Minor GC之前如果预估到Survivor区域不够了，才会去做这个检查？ 



如果第一种情况，那么假如Survivor能存的下回收后的对象，每次检查一下老年到貌似不必要。



如果第二种情况，到底是怎么预估的回收后的对象Survivor能放得下？难道遍历一次GCROOT然后计算他们的内存大小。感觉不太靠谱，遍历GC root是垃圾回收器做的事情，发生在“垃圾回收过程中”而不是“垃圾回收之前”



**答：**每次Minor GC前直接检查新生代全部对象的大小是否小于老年代可用内存大小，不是检查新生代的存活对象的大小，所以这个比较成本是很低的





**问题**

请教下，我们写好等代码在运行等过程中，对于创建的各种各样的对象，放入新生代的内存顺序一定首先是eden区，然后survivor1区吗？还是也可能是eden区和survivor2区？谢谢老师



**答：**仅仅放在Eden区里，Survivor是用来放每一次Minor GC后存活的对象的





**非常棒的学员思考题回答**

到底什么时候会尝试触发Minor GC？ 

答：当新生代的Eden区和其中一个Survivor区空间不足时。 



触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？ 

答：

1、先判断新生代中所有对象的大小是否 小于 老年代的可用区域 true 则 触发Minor GC，false则继续进行下面2中的判断 



2、如果设置了-XX:HandlePromotionFailure这个参数，那么进入第3步 如果没有设置-XX:HandlePromotionFailure参数，那么触发Full GC 



3、判断Minor GC历次进入老年代的平均大小是否 小于 老年代的可用区域 true 则触发Minor GC，false则会触发Full GC 什么时候在Minor GC之前就会提前触发一次Full GC？ 

答：当判断 新生代历次进入老年代对象的平均大小 大于 老年代的可用区域就会触发一次Full GC，让老年代腾出一些空间，腾出空间后再进行Minor GC。 



FullGC的算法是什么？ 

答：标记整理算法。 



Minor GC过后可能对应哪几种情况？ 

答： 

**情况1：**Minor GC前先判断：存活的对象所占的内存空间 < Survivor区域内存空间的大小，那么存活的对象进入Survivor区。 



**情况2：**Minor GC前先判断：Survivor区域内存空间的大小 < 存活的对象所占的内存空间 < 老年代的可用空间大小。那么存活的对象，直接进入老年代。 



**情况3：**Minor GC前先判断： (存活的对象所占的内存空间 > Survivor区域内存空间的大小) && (存活的对象所占的内存空间 > 老年代的可用空间大小)。那么会触发Full GC，老年代腾出空间后，再进行Minor GC。如果腾出空间后还不能存放存活的对象，那么会导致OOM即堆内存空间不足、堆内存溢出。 



哪些情况下Minor GC后的对象会进入老年代？ 

答：

1、 Survivor区 < 存活对象占用的空间 && 老年代可用区域 < 存活对象占用的空间 

2、经过XX:MaxTenuringThreshold次M





**问题**

老师，诚心求教，希望能帮忙解释清楚，反复看了几次，确实文章开头说的也是我们写好的代码在运行过程中，会不断的创建各种各样的对象



这些对象会优先存放在新生代的Eden和survivor1区，接着假如新生代的Eden和s1都快满了，就发生minor gc，存活对象移动到s2.



然后接着就会使用Eden和s2区来分配新的对象



那文章下面为什么又提到系统继续运行，继续在Eden区里分配各种对象？难道不该是系统继续运行，继续在Eden区和s2区里分配各种对象，发生minor gc后，再移动到s1吗？这里的描述前后理解困惑



**答：**同学，你可能理解错一点了，对象都是在Eden区分配的，然后一次Minor GC过后，存活对象转移到S1区，此时Eden区就清空了，对吧？



然后接着系统继续运行，对象继续分配在Eden区，下一次Minor GC过后，看看Eden + S1里的存活对象有哪些，都转移到S2区。



接着系统继续运行，对象继续分配在Eden区，下一次Minor GC过后，看看Eden + S2里的存活对象有哪些，都转移到S1区。S1和S2就是用来放存活对象的，Eden区用来让系统分配新的对象进去。





**问题**

非常感激老师的耐心解答，那是不是可以理解为minor gc触发条件是Eden区放不下新的对象为触发条件？



然后追问一个关于full gc，是不是存在minor gc检查历次的放入老年代的对象大小小于本次实际要挪移的对象大小情况，从而才会说有minor gc发生后，再次full gc再minor gc的情况？感谢，感谢



**答：**

1、对的 

2、不对，是历次进入老年代的对象大小小于当前老年代的内存大小，才会触发minor gc；否则先是full gc给老年代腾空间，再minor gc





**问题**

忍不住再追加一个确认，会不会存在minor gc前检查历次进入老年代的对象均值是10M，然后当前老年代剩余50M，明显大于历次的10M这个值，于是触发minor gc正常执行，但执行后发现本次实际要放入老年代的对象大小大于均值且大于50M的情况，从而再来一次fullgc和minor gc这样的情况？感恩分享



**答：**会的，如果是这种情况，就是会先执行minor gc，然后发现老年代内存不足，触发full gc







**问题**

老师，每次Minor GC后剩余的是200MB是根据2 8法则推测的吗，我们平时做优化假设也是按照这个法则来吗？那如果我想知道实际中真正剩余多少内存的对象有什么办法吗？



**答：**不是的，这个数字是根据线上生产日志判断出来的，后续会教大家看gc日志，很清晰可以看到每分钟minor gc的时候多少对象进入老年代





**问题**

打卡。今天这个案例很好的结合估算内存压力大小和新老代回收机制进行了产线问题排查，这个思路在以后的工作中也很重要，学习了。



**答：**是的，建议直接按照这个案例背景从头到尾画一下整个内存分析的全流程和优化过程







**问题**

老师，评估每次任务或者每秒系统产生的数据大小是不是有专门的工具可以结合起来看。



**答：**是的，后续会带着动手操作一些工具的使用，这里就是先讲原理，结合案例说明原理





**问题**

每个计算计算任务1万条数据需要计算10秒钟，假设此时计算出80个计算任务都执行成功了。。。卡在这里了



后来想明白了：假设1分钟100个计算任务，每个计算任务是10秒钟，在60秒到来的那一刻，只有50-60秒开始执行的计算任务是没有执行完毕的，占比1/6,100 / 6 = 16.66 。 所以可以大致估算还有20个计算任务还在计算中。



**答：**是的，线上生产系统大致就是这个比例



**问题**

关于空间分配担保有一点疑问 当老年代的可用内存空间小于新生代所有对象的总大小时, 无论有没有空间分配担保, 最坏的情况都是一次minor GC + Full Gc 



那为什么还需要这个分配担保?? 直接minor GC, 之后再进行那三种可能的判断不就行了, HandlePromotionFail的意义何在?



**答：**不是的，如果说没有开启一个检查，此时可能提前Full GC，那么这样就太频繁了；但是如果经过文章里说的检查机制，发现不需要Full GC那么就直接Minor GC；差别在于不需要频繁Full GC





**问题**

按照每一次Minor GC之前JVM都会检测老年代空间是否大于新生代对象的总大小。一般上线的环境下，控制Minor GC的频率后，如果资源是不是是尽量为老年代分配更大的空间。如果不行，就需要设置参数HandlePromationFail。



这样理解可以吗？老师



**答：**理解正确的，但是其实具体一个系统要如何分配Eden、Survivor、老年代的内存，其实是很有讲究的，主要得看系统运行的特点



# 022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！

 2019-07-22 07:00:0





**一步一图**

**深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！**



**1、前文回顾**



上周的文章已经给大家把整个JVM的核心运行原理全部梳理清楚了，大家现在应该对以下问题非常的清晰明了：



1. 对象在新生代分配，然后什么时候会触发Minor GC

   

2. 触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小，如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小

3. 什么情况下Minor GC之前会提前触发Full GC，什么情况下会直接触发Minor GC

4. Minor GC之后有哪几种情况对象会进入老年代



而且大家也大概知道了垃圾回收器、垃圾回收线程、垃圾回收算法之间的关系，包括垃圾回收的过程中的“Stop the World”现象和场景对系统运行性能的影响。



这周我们就要来相对深入的研究一下常见的新生代和老年代的垃圾回收器的运行原理了，同时看看常见的垃圾回收参数一般会怎么来设置。



同时结合案例来研究一下在你上线一个新系统的时候，如何通过预估的手段和方法提前对系统的垃圾回收参数进行合理的设置。



**2、最常用的新生代垃圾回收器：ParNew**



一般来说，在之前多年里，假设没有最新的G1垃圾回收器的话，通常大家线上系统都是ParNew垃圾回收器作为新生代的垃圾回收器



当然现在即使有了G1，其实很多线上系统还是用的ParNew。



通常运行在服务器上的Java系统，都可以充分利用服务器的多核CPU的优势，所以大家可以想一下，假设你的服务器是4核CPU，如果对新生代垃圾回收的时候，仅仅使用单线程进行垃圾回收，是不是会导致没法充分利用CPU资源？



如下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76102200_1563502885.cn/txdocpic/0/78d07e79a2613879f51d7c5506b196ae/0)



比如上图，现在你在垃圾回收的时候，都把系统程序所有的工作线程全部停掉了，就一个垃圾回收线程在运行



那么此时4核CPU的资源根本没法充分利用，理论上4核CPU就可以支持4个垃圾回收线程并行执行，可以提升4倍的性能！



所以说，新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。



大家看下图，ParNew垃圾回收器如果一旦在合适的时机执行Minor GC的时候，就会把系统程序的工作线程全部停掉，禁止程序继续运行创建新的对象，然后自己就用多个垃圾回收线程去进行垃圾回收，回收的机制和算法就跟之前说的是一样的。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98227500_1563502885.cn/txdocpic/0/2101a5af1ad707d3174c3c22320150e7/0)



**3、如何为线上系统指定使用ParNew垃圾回收器？**

一般来说，对于线上系统部署启动的时候，我们之前都看过多种方式来设置JVM参数了，在Eclipse/IntelliJ IDEA中可以设置Debug JVM Arguments，使用“java -jar”命令启动时直接在后面跟上JVM参数即可



部署到Tomcat时可以在Tomcat的catalina.sh中设置Tomcat的JVM参数，使用Spring Boot也可以在启动时指定JVM参数。



那么在启动系统的时候如果要指定使用ParNew垃圾回收器，是用什么参数呢？



很简单，使用“-XX:+UseParNewGC”选项，只要加入这个选项，JVM启动之后对新生代进行垃圾回收的，就是ParNew垃圾回收器了。



那么Minor GC的时机，检查机制，包括垃圾回收的具体过程，以及对象升入老年代的机制，都是我们之前说过的那套原理了，只不过大家要知道，ParNew会使用多个线程来进行垃圾回收。



**4、ParNew垃圾回收器默认情况下的线程数量**

因为现在一般我们部署系统的服务器都是多核CPU的，所以为了在垃圾回收的时候充分利用多核CPU的资源，一旦我们指定了使用ParNew垃圾回收器之后，他默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的。



比如我们线上机器假设用的是4核CPU，或者8核CPU，或者16核CPU，那么此时ParNew的垃圾回收线程数就会分别是4个线程、8个线程、16个线程



这个东西一般不用我们手动去调节，因为跟CPU核数一样的线程数量，是可以充分进行并行处理的。



比如下图，大家可以看到，每个线程都通过一个CPU在运行。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11681600_1563502886.cn/txdocpic/0/8a237f1723e379efa239fdb1e261c4c2/0)



但是如果你一定要自己调节ParNew的垃圾回收线程数量，也是可以的，使用“-XX:ParallelGCThreads”参数即可，通过他可以设置线程的数量



但是建议一般不要随意动这个参数，如果要优化，具体结合后续的案例我们给大家展开。



**5、本文总结**

这篇文章篇幅不长，主要介绍一下ParNew垃圾回收器，其实垃圾回收器的工作原理之前上周就全部介绍过了



这周的第一篇文章，主要就是对ParNew垃圾回收器本身的多线程原理和相关的参数做一些说明。



**6、昨日思考题**

上篇文章让大家思考了一个问题，其实反而在这篇文章里要多花点时间来说明。



之前让大家思考的问题就是：



- 到底是用单线程垃圾回收好，还是多线程垃圾回收好？
- 到底是Serial垃圾回收器好还是ParNew垃圾回收器好？



对这个问题要给大家略微展开做点解释。



启动系统的时候是可以区分服务器模式和客户端模式的，如果你启动系统的时候加入“-server”就是服务器模式，如果加入“-cilent”就是客户端模式。



他们俩的**区别**就是，如果你的系统部署在比如4核8G的Linux服务器上，那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式。



那么服务器模式和客户端模式的区别是啥呢？



服务器模式通常运行我们的网站系统、电商系统、业务系统、APP后台系统之类的大型系统，一般都是多核CPU



所以此时如果要垃圾回收，那么肯定是用ParNew更好，因为多线程并行垃圾回收，充分利用多核CPU资源，可以提升性能。如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38639500_1563502886.cn/txdocpic/0/8a237f1723e379efa239fdb1e261c4c2/0)



反之如果你部署在服务器上，但是你用了单线程垃圾回收，那么就有一些CPU是被浪费了，根本没用上



比如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/62351800_1563502886.cn/txdocpic/0/a8f06e044c5639c4b8807137e2a657e1/0)



那么如果你的Java程序是一个客户端程序，比如类似百度云网盘的Windows客户端，或者是印象笔记的Windows客户端，运行在Windows个人操作系统上呢？



这种操作系统很多都是单核CPU，此时你如果要是还是用ParNew来进行垃圾回收，就会导致一个CPU运行多个线程，反而加重了性能开销，可能效率还不如单线程好



因为单CPU运行多线程会导致频繁的线上上下文切换，有效率开销，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/86104900_1563502886.cn/txdocpic/0/262513a5e0cd2dc1b3568e5b1d136352/0)



所以如果是类似于那种运行在Windows上的客户端程序，建议采用Serial垃圾回收器，单CPU单线程垃圾回收即可，反而效率更高，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5675600_1563502887.cn/txdocpic/0/064051b3f80a807a9e844ae7d08c6ae3/0)

但是其实现在一般很少有用Java写客户端程序的，几乎很少见，Java现在主要是用来构建复杂的大规模后端业务系统的，所以常见的还是用“-server”指定为服务器模式，然后配合ParNew多线程垃圾回收器。



但是大家还是应该清楚单线程和多线程对垃圾回收的适用场景。



**7、今日思考题**

其实我们一直是鼓励大家在评论区提出有价值的提问的，有自己的思考在里面



昨天有个同学提了一个自己经历过的JVM的面试题，我觉得非常好，给出来让大家思考一下：



“一个面试题，parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



我的回答（这里指该同学回答）: 

1. 加大分代年龄，比如默认15加到30; 
2. 修改新生代老年代比例，比如新生代老年代比例改成2:1 
3. 修改e区和s区比例，比如改成6:2:2



面试官说他们内部服务已经做到fullgc次数为0，只做ygc，想听听老师的意见



对于这个面试题，如果大家吃透了咱们这个专栏前三周的JVM原理和案例，完全可以把这个面试题回答的滴水不漏



结合案例和画图给面试官说明，而不是干巴巴的简单给几个方法，可以回答的有血有肉，让面试官无话可说。



其实要做到仅仅young gc，而几乎没有full gc是不难的，只要结合自己系统的运行，根据他的内存占用情况，GC后的对象存活情况，合理分配Eden、Survivor、老年代的内存大小，合理设置一些参数，即可做到。



**End**

# 023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？

2019-07-23 07:20:35

**1、前文回顾**



本文我们就要进入最核心的老年代垃圾回收环节了，之前的文章大家看过之后对JVM的核心原理都有一定的了解了，年轻代的垃圾回收机制也都很清楚了，其实年轻代的垃圾回收通过复制算法来，还是比较简单的。



大家心里最希望的，就是对象都分配在新生代的Eden区，然后每次垃圾回收之后，存活对象都进入Survivor区，然后下一次垃圾回收后的存活对象都进入另外一个Survivor区。



这样几乎很少很少的对象会进入老年代里去，也就几乎不太会触发老年代的垃圾回收了。



但是理想很丰满，现实很骨干。其实大家想想，你们在写代码的时候，有谁会考虑垃圾回收啥的？不会有人考虑这个吧，就是不停的狂写代码，然后直接上线部署，根本没多少人会考虑自己的代码对垃圾回收的影响。



最多有经验的工程师上线之前，通过我们之前的案例讲解的方法估算一下系统的内存压力以及垃圾回收的运行模型，然后合理设置一下内存各个区域的大小，尽量避免太多对象进行老年代里去。



但是真实情况是，线上系统很可能就会因为各种各样的情况，导致很多对象进入老年代，然后甚至频繁触发老年代的Full GC。



之前我们用案例给大家演示过很多这种情况，比如说Survivor区太小，容纳不了每次Minor GC后的存活对象，导致对象频繁进入老年代，频繁触发老年代Full GC。



类似的情况其实很多，所以，咱们不能过于理想化的期待永远没有老年代GC，还是要对老年代的垃圾回收器是如何回收的，有一个了解和认识。



**2、CMS垃圾回收的基本原理**

一般老年代我们选择的垃圾回收器是CMS，他采用的是标记清理算法，其实非常简单，就是先用之前文章里讲过的标记方法去标记出哪些对象是垃圾对象，然后就把这些垃圾对象清理掉，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27951000_1563838359.cn/txdocpic/0/e64448b93c84a54644aec30be5c7e38c/0)



上面图里是一个老年代内存区域的对象分布情况，现在假设因为老年代内存空间小于了历次Minor GC后升入老年代对象的平均大小，判断Minor GC有风险，可能就会提前触发Full GC回收老年代的垃圾对象。



或者是一次Minor GC后的对象太多了，都要升入老年代，发现空间不足，出发了一次老年代的Full GC。



总之就是要进行Full GC了，此时所谓的标记-清理算法，其实就是我们之前给大家讲过的一个算法，先通过追踪GC Roots的方法，看看各个对象是否被GC Roots给引用了，如果是的话，那就是存活对象，否则就是垃圾对象。



先将垃圾对象都标记出来，然后一次性把垃圾对象都回收掉，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38850200_1563838359.cn/txdocpic/0/5393937869fd98892422643e55740510/0)



这种方法其实最大的问题，就是会造成很多内存碎片



大家看下图的红圈处就是所谓的内存碎片，这种碎片不大不小的，可能放不小 任何一个对象，那么这个内存就被浪费了，之前我们聊过这个问题。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49393000_1563838359.cn/txdocpic/0/ea251f968c885067b86fba7624aa1653/0)



这就是CMS采取的“标记-清理”算法。





**3、如果Stop the World然后垃圾回收会如何？**

现在大家思考一个问题，假设要先“Stop the World”，然后再采用“标记-清理”算法去回收垃圾，那么会有什么问题？



之前文章也说过了，如果停止一切工作线程，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长，很多响应无法处理。



所以CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。



**4、CMS如何实现系统一边工作的同时进行垃圾回收？**

CMS在执行一次垃圾回收的过程一共分为4个阶段：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清理



我们一点一点来看。



首先，CMS要进行垃圾回收时，会先执行初始标记阶段，这个阶段会让系统的工作线程全部停止，进入“Stop the World”状态，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57926200_1563838359.cn/txdocpic/0/7b4b94700deabfe69dee1e5e121960d2/0)



所谓的“初始标记”，他是说标记出来所有GC Roots直接引用的对象，这是啥意思呢？



比如下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/69169300_1563838359.png)



在初始标记阶段，仅仅会通过“replicaManager”这个类的静态变量代表的GC Roots，去标记出来他直接引用的ReplicaManager对象，这就是初始标记的过程。



他不会去管ReplicaFetcher这种对象，因为ReplicaFetcher对象是被ReplicaManager类的“replicaFetcher”实例变量引用的



之前说过，方法的局部变量和类的静态变量是GC Roots。但是类的实例变量不是GC Roots。



如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80271100_1563838359.cn/txdocpic/0/566ee7ab4279ab1af92d5aeda6935adc/0)



所以第一个阶段，初始标记，虽然说要造成“Stop the World”暂停一切工作线程，但是其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象罢了。



接着第二个阶段，是并发标记，这个阶段会让系统线程可以随意创建各种新对象，继续运行



在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行GC Roots追踪。



所谓进行GC Roots追踪，意思就是对类似“ReplicaFetcher”之类的全部老年代里的对象，他会去看他被谁引用了？



比如这里是被“ReplicaManager”对象的实例变量引用了，接着会看，“ReplicaManager”对象被谁引用了？会发现被“Kafka”类的静态变量引用了。



那么此时可以认定“ReplicaFetcher”对象是被GC Roots间接引用的，所以此时就不需要回收他。如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/88544800_1563838359.cn/txdocpic/0/0ba5aed67a0c066939c5c5d44751daac/0)



但是这个过程中，在进行并发标记的时候，系统程序会不停的工作，他可能会各种创建出来新的对象，部分对象可能成为垃圾，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98069600_1563838359.cn/txdocpic/0/30a65b913e1e3e71ae10b9020e15ee3f/0)



第二个阶段，就是对老年代所有对象进行GC Roots追踪，其实是最耗时的



他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响的。



接着会进入第三个阶段，重新标记阶段



因为第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾



所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/7863600_1563838360.cn/txdocpic/0/a35cde5bee7ccb9b91eb76104422bb00/0)



所以此时进入第三阶段，要继续让系统程序停下来，再次进入“Stop the World”阶段。



然后重新标记下在第二阶段里新创建的一些对象，还有一些已有对象可能失去引用变成垃圾的情况，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/17323800_1563838360.cn/txdocpic/0/41036b424d0e3a5284f8436bfccb8d53/0)



这个重新标记的阶段，是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。



接着重新恢复系统程序的运行，进入第四阶段：**并发清理**



这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。



这个阶段其实是很耗时的，因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26374900_1563838360.cn/txdocpic/0/0d832fc8cc9c572bbe12e593431c3667/0)



**5、对CMS的垃圾回收机制进行性能分析**

其实大家看完CMS的垃圾回收机制之后，就会发现，他已经尽可能的进行了性能优化了



因为最耗时的，其实就是对老年代全部对相关进行GC Roots追踪，标记出来到底哪些可以回收，然后就是对各种垃圾对象从内存里清理掉，这是最耗时的。



但是他的第二阶段和第四阶段，都是和系统程序并发执行的，所以基本这两个最耗时的阶段对性能影响不大。



只有 第一个阶段和第三个阶段是需要“Stop the World”的，但是这两个阶段都是简单的标记而已，速度非常的快，所以基本上对系统运行响应也不大。



明天的文章，我们就继续深入来看看CMS垃圾回收机制的各种细节以及一些参数一般如何设置。



**6、昨日思考题**

昨天的思考题，是一个学员真实面试中遇到的一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



该学员的回答: 

1. 加大分代年龄，比如默认15加到30; 
2. 修改新生代老年代比例，比如新生代老年代比例改成2:1 
3. 修改e区和s区比例，比如改成6:2:2



其实让大家去梳理这个思路，就是希望大家多一些思考，多一些梳理和总结。答案就在我们之前讲过的案例里，大家只要结合那个案例分析，就知道解答这面试题的思路。



大家可以尝试着作答，将自己的答案发至评论区。



**7、今日思考题**

看完了新生代和老年代的垃圾回收机制之后，大家来思考一下：为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？



明天的文章我们会深入探讨CMS垃圾回收机制和对应的参数，同时解答这个问题。

# 024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？

2019-07-24 07:00:00

**目录：**

1. 前文回顾
2. 并发回收垃圾导致CPU资源紧张
3. Concurrent Mode Failure问题
4. 内存碎片问题
5. 昨日思考题解答
6. 今日思考题





**1、前文回顾**

上篇文章用一步一图的方式给大家讲清楚了CMS垃圾回收的运行机制



简单来说，为了避免长时间“Stop the World”，CMS采用了4个阶段来垃圾回收，其中初始标记和重新标记，耗时很短，虽然会导致“Stop the World”，但是影响不大。



然后并发标记和并发清理，两个阶段耗时最长，但是是可以跟系统的工作线程并发运行的，所以对系统没太大影响。



这就是CMS的基本工作原理。



但是本文要更加深入的去说一说CMS垃圾回收期间的一些细节问题，同时给出CMS常见的JVM参数应该如何设置。



**2、并发回收垃圾导致CPU资源紧张**

首先大家回顾一下这个图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73362100_1563871849.cn/txdocpic/0/20ceb2b12462f65eda7f98d7d1011ae8/0)

CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分。



并发标记的时候，需要对GC Roots进行深度追踪，看所有对象里面到底有多少人是存活的



但是因为老年代里存活对象是比较多的，这个过程会追踪大量的对象，所以耗时较高。并发清理，又需要把垃圾对象从各种随机的内存位置清理掉，也是比较耗时的。



所以在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4。



我们用最普通的2核4G机器和4核8G机器来计算一下，假设是2核CPU，本来CPU资源就有限，结果此时CMS还会有个“(2 + 3) / 4” = 1个垃圾回收线程，去占用宝贵的一个CPU。



所以其实CMS这个并发垃圾回收的机制，第一个问题就是会消耗CPU资源。



**3、Concurrent Mode Failure问题**

第二个问题，是很多同学都很关注的一个问题，就是如下图



在并发清理阶段，CMS只不过是回收之前标记好的垃圾对象



但是这个阶段系统一直在运行，可能会随着系统运行让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“**浮动垃圾**”。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/86853700_1563871849.cn/txdocpic/0/5bd81858c4051cbd855c33926990d883/0)



大家看上图那个红圈画的地方，那个对象就是在并发清理期间，系统程序可能先把某些对象分配在新生代，然后可能触发了一次Minor GC，一些对象进入了老年代，然后短时间内又没人引用这些对象了。



这种对象，就是老年代的“**浮动垃圾**”。



因为他虽然成为了垃圾，但是CMS只能回收之前标记出来的垃圾对象，不会回收他们，需要等到下一次GC的时候才会回收他们。



所以为了保证在CMS垃圾回收期间，还有一定的内存空间让一些对象可以进入老年代，一般会预留一些空间。



CMS垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就自动执行GC。



“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。



也就是说，老年代占用了92%空间了，就自动进行CMS垃圾回收，预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。



那么如果CMS垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，此时会如何？



这个时候，会发生Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。



此时就会自动用“Serial Old”垃圾回收器替代CMS，就是直接强行把系统程序“Stop the World”，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生



然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。



所以在生产实践中，这个自动触发CMS垃圾回收的比例需要合理优化一下，避免“Concurrent Mode Failure”问题



**接下来我们会用两篇文章结合案例来分析垃圾回收参数的设置。**



**4、内存碎片问题**

之前给大家说过内存碎片的问题，就是老年代的CMS采用“标记-清理”算法，每次都是标记出来垃圾对象，然后一次性回收掉，这样会导致大量的内存碎片产生。



如果内存碎片太多，会导致后续对象进入老年代找不到可用的连续内存空间了，然后触发Full GC。



所以CMS不是完全就仅仅用“标记-清理”算法的，因为**太多的内存碎片实际上会导致更加频繁的Full GC。**



CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了



他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。



还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次Full GC之后都会进行一次内存整理。



如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96968400_1563871849.cn/txdocpic/0/e6acda9b7607ff721594ebb1483a2c4b/0)



上图有一个画红圈的地方，就是说在垃圾回收之后，有一些内存碎片，接着会停止工作线程进行碎片整理，如下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/6757300_1563871850.cn/txdocpic/0/dd350808f7139e4034a0c9a7c872ecdb/0)



大家可以看到，内存碎片整理完之后，存活对象都放在一起，然后空出来大片连续内存空间可供使用。



**5、昨日思考题解答**

昨天给大家出来一个思考题，意思是说，为啥老年代的Full GC要比新生代的Minor GC慢很多倍，一般在10倍以上？



其实原因很简单，大家分析一下他们俩的执行过程。



新生代执行速度其实很快，因为直接从GC Roots出发就追踪哪些对象是活的就行了，新生代存活对象是很少的，这个速度是极快的，不需要追踪多少对象。



然后直接把存活对象放入Survivor中，就一次性直接回收Eden和之前使用的Survivor了。



但是CMS的Full GC呢？



在并发标记阶段，他需要去追踪所有存活对象，老年代存活对象很多，这个过程就会很慢；



其次并发清理阶段，他不是一次性回收一大片内存，而是找到零零散散在各个地方的垃圾对象，速度也很慢；



最后完事儿了，还得执行一次内存碎片整理，把大量的存活对象给挪在一起，空出来连续内存空间，这个过程还得“Stop the World”，那就更慢了。



万一并发清理期间，剩余内存空间不足以存放要进入老年代的对象了，引发了“Concurrent Mode Failure”问题，那更是麻烦，还得立马用“Serial Old”垃圾回收器，“Stop the World”之后慢慢重新来一遍回收的过程，这更是耗时了。



所以综上所述，老年代的垃圾回收，就是一个字：慢



**6、今日思考题**

今天是一个小问题，让大家复习梳理一下，还记得说过几个触发老年代GC的时机吗？



**第一**是老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；



**第二**是老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；



**第三**是新生代Minor GC后的存活对象大于Survivor，那么就会进入老年代，此时老年代内存不足。



上述情况都会导致老年代Full GC。



今天加了一个触发时机，就是“-XX:CMSInitiatingOccupancyFaction”参数



刨除掉上述几种情况，如果老年代可用内存大于历次新生代GC后进入老年代的对象平均大小，但是老年代已经使用的内存空间超过了这个参数指定的比例，也会自动触发Full GC。



希望大家认真回顾一下上述过程，把老年代Full GC的几个时机都仔细梳理一下

# 025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化？

2019-07-25 07:00:00

**1、案例背景引入**

按照惯例，我们接下来会用案例驱动来带着大家分析到底该如何在特定场景下，预估系统的内存使用模型



然后合理优化新生代、老年代、Eden和Survivor各个区域的内存大小，接着再尽量优化参数避免新生代的对象进入老年代，尽量让对象留在新生代里被回收掉。



我们这里的背景是电商系统，电商系统其实一般会拆分为很多的子系统独立部署，比如商品系统、订单系统、促销系统、库存系统、仓储系统、会员系统，等等



我们这里就以比较核心的订单系统作为例子来说明。



我们的**案例背景**是每日上亿请求量的电商系统，那么大家可以来推算一下每日上亿请求量的电商系统，他会每日有多少活跃用户？



一般按每个用户平均访问20次来计算，那么上亿请求量，大致需要有500万日活用户。



那么继续来推算一下，这500万的日活用户都是会进来进行大量的浏览，那么多少人会下订单？



这里可以按照10%的付费转化率来计算，每天大概有50万人会下订单，那么大致就是每天会有50万订单。



这50万订单算他集中在每天4小时的高峰期内，那么其实平均下来每秒钟大概也就几十个订单，大家是不是觉得根本没啥可说的？



因为几十个订单的压力下，根本就不需要对JVM多关注，基本上就是每秒钟占用一些新生代内存，隔很久新生代才会满，然后一次Minor GC后垃圾对象清理掉，内存就空出来了，几乎无压力。



**2、特殊的电商大促场景**

但是如果你要是考虑到特殊的电商大促场景，就不会这么想了



因为很多中小型的电商平台，确实平时系统压力其实没那么大，也没太大的高并发，每秒几千并发压力就算是高峰压力了。



但是如果遇到一些大促场景，比如双11什么的，情况就不同了。



假设在类似双11的节日里，零点的时候，很多人等着大促开始就要剁手购物，这个时候，可能在大促开始的短短10分钟内，瞬间就会有50万订单。



那么此时每秒就会有接近1000的下单请求，我们就针对这种大促场景来对订单系统的内存使用模型分析一下。



**3、抗住大促的瞬时压力需要几台机器？**

那么要抗住大促期间的瞬时下单压力，订单系统需要部署几台机器呢？



基本上可以按3台来算，就是每台机器每秒需要抗300个下单请求。这个也是非常合理的，而且需要假设订单系统部署的就是最普通的标配4核8G机器。



从机器本身的CPU资源和内存资源角度，抗住每秒300个下单请求是没问题的。



但是问题就在于需要对JVM有限的内存资源进行合理的分配和优化，包括对垃圾回收进行合理的优化，让JVM的GC次数尽可能最少，而且尽量避免Full GC，这样可以尽可能减少JVM的GC对高峰期的系统新更难的影响。





**4、大促高峰期订单系统的内存使用模型估算**



背景已经全部说完了，接下来咱们就得来预估订单系统的内存使用模型了.



基本上可以按照每秒钟处理300个下单请求来估算，其实无论是订单处理性能还是并发情况，都跟生产很接近



因为处理下单请求是比较耗时的，涉及很多接口的调用，基本上每秒处理100~300个下单请求是差不多的。



那么每个订单咱们就按1kb的大小来估算，单单是300个订单就会有300kb的内存开销



然后算上订单对象连带的订单条目对象、库存、促销、优惠券等等一系列的其他业务对象，一般需要对单个对象开销放大10倍~20倍。



此外，除了下单之外，这个订单系统还会有很多订单相关的其他操作，比如订单查询之类的，所以连带算起来，可以往大了估算，再扩大10倍的量。



那么每秒钟会有大概300kb * 20 * 10 = 60mb的内存开销。但是一秒过后，可以认为这60mb的对象就是垃圾了，因为300个订单处理完了，所有相关对象都失去了引用，可以回收的状态。



大家看下图

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57897900_1563968637.cn/txdocpic/0/e91a8081686c199caff5d29cf115039c/0)



**5、内存到底该如何分配？**



假设我们有4核8G的机器，那么给JVM的内存一般会到4G，剩下几个G会留点空余给操作系统之类的来使用，不要想着把机器内存一下子都耗尽，其中堆内存我们可以给3G，新生代我们可以给到1.5G，老年代也是1.5G。



然后每个线程的Java虚拟机栈有1M，那么JVM里如果有几百个线程大概会有几百M



然后再给永久代256M内存，基本上这4G内存就差不多了。



同时还要记得设置一些必要的参数，比如说打开“-XX:HandlePromotionFailure”选项，JVM参数如下所示：（**不熟悉这个参数的，可以回头复习一下专栏之前的文章**）



“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure”



此时JVM内存入下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83101300_1563968637.cn/txdocpic/0/504965c0282fa452ef721de1939e2fd2/0)

接着就很明确了，订单系统的系统程序在大促期间不停的运行，每秒处理300个订单，都会占据新生代60MB的内存空间



但是1秒过后这60MB对象都会变成垃圾，那么新生代1.5G的内存空间大概需要25秒就会占满，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/9858900_1563968638.cn/txdocpic/0/cbe653478949e2ca88c8580c69cbdc4a/0)

25秒过后就会要进行Minor GC了，此时因为有“-XX:HandlePromotionFailure”选项，所以你可以认为需要进行的检查，主要就是比较 “老年代可用空间大小”和“历次Minor GC后进入老年代对象的平均大小”，刚开始肯定这个检查是可以通过的。



所以Minor GC直接运行，一下子可以回收掉99%的新生代对象，因为除了最近一秒的订单请求还在处理，大部分订单早就处理完了，所以此时可能存活对象就100MB左右。



但是这里问题来了，如果“-XX:SurvivorRatio”参数默认值为8，那么此时新生代里Eden区大概占据了1.2GB内存，每个Survivor区是150MB的内存，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/32386900_1563968638.cn/txdocpic/0/96db2d2d503736d394249286b5ad9601/0)

所以Eden区1.2GB满了就要进行Minor GC了，因此大概只需要20秒，就会把Eden区塞满，就要进行Minor GC了。



然后GC后存活对象在100MB左右，会放入S1区域内。如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52810900_1563968638.cn/txdocpic/0/69af51522556e6c9fccc3e3e3915a5fa/0)



然后再次运行20秒，把Eden区占满，再次垃圾回收Eden和S1中的对象，存活对象可能还是在100MB左右会进入S2区，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/69575800_1563968638.cn/txdocpic/0/524be07e39784fbe670f1e2cbeaf4e33/0)



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8”



**6、新生代垃圾回收优化之一：Survivor空间够不够**



首先在进行JVM优化的时候，第一个要考虑的问题，就是你通过估算，你的新生代的Survivor区到底够不够



按照上述逻辑，首先每次新生代垃圾回收在100MB左右，有可能会突破150MB，那么岂不是经常会出现Minor GC过后的对象无法放入Survivor中？然后岂不是频繁会让对象进入老年代？



还有，即使Minor GC后的对象少于150MB，但是即使是100MB的对象进入Survivor区，因为这是一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代。

（**关于jvm的垃圾回收规则，如果忘记了的同学，请参加专栏之前的文章**）



所以其实按照我们这个模型来说，Survivor区域是明显不足的。



这里其实建议的是调整新生代和老年代的大小，因为这种普通业务系统，明显大部分对象都是短生存周期的，根本不应该频繁进入老年代，也没必要给老年代维持过大的内存空间，首先得先让对象尽量留在新生代里。



所以此时可以考虑把新生代调整为2G，老年代为1G，那么此时Eden为1.6G，每个Survivor为200MB，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89940600_1563968638.cn/txdocpic/0/b3309cff7a4dcf9f150623d0edea5432/0)



这个时候，Survivor区域变大，就大大降低了新生代GC过后存活对象在Survivor里放不下的问题，或者是同龄对象超过Survivor 50%的问题。



这样就大大降低了新生代对象进入老年代的概率。



此时JVM的参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8”



其实对任何系统，首先类似上文的内存使用模型预估以及合理的分配内存，尽量让每次Minor GC后的对象都留在Survivor里，不要进入老年代，这是你首先要进行优化的一个地方。



**7、新生代对象躲过多少次垃圾回收后进入老年代？**



大家都知道，除了Minor GC后对象无法放入Survivor会导致一批对象进入老年代之外，还有就是有些对象连续躲过15次垃圾回收后会自动升入老年代。



其实按照上述内存运行模型，基本上20多秒触发一次Minor GC，那么如果按照“-XX:MaxTenuringThreshold”参数的默认值15次来说，你要是连续躲过15次GC，就是一个对象在新生代停留超过了几分钟了，此时他进入老年代也是应该的。



有些博客会说，应该提高这个参数，比如增加到20次，或者30次，其实那种说法根本是不对的



因为你对这个参数考虑必须结合系统的运行模型来说，如果躲过15次GC都几分钟了，一个对象几分钟都不能被回收，说明肯定是系统里类似用@Service、@Controller之类的注解标注的那种需要长期存活的核心业务逻辑组件。



那么他就应该进入老年代，何况这种对象一般很少，一个系统累计起来最多也就几十MB而已。



所以你说你提高“-XX:MaxTenuringThreshold”参数的值，有啥用呢？让这些对象在新生代里多停留几分钟？



所以说，考虑问题，一定不要人云亦云，要结合运行原理，自己推演和思考，不同的业务系统还都是不一样的。



其实这个参数甚至你都可以降低他的值，比如降低到5次，也就是说一个对象如果躲过5次Minor GC，在新生代里停留超过1分钟了，尽快就让他进入老年代，别在新生代里占着内存了。



总之，对于这个参数务必是结合你的系统具体运行的模型来考虑。



要记住，JVM没有万能的最佳参数，但是有一套通用的分析和优化的方法。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5”



**8、多大的对象直接进入老年代？**



另外有一个逻辑是说，大对象可以直接进入老年代 ，因为大对象说明是要长期存活和使用的



比如在JVM里可能会缓存一些数据，这个一般可以结合自己系统中到底有没有创建大对象来决定。



但是一般来说，给他设置个1MB足以，因为一般很少有超过1MB的大对象。如果有，可能是你提前分配了一个大数组、大List之类的东西用来放缓存的数据。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M”



**9、别忘了指定垃圾回收器**



同时大家别忘了要指定垃圾回收器，新生代使用ParNew，老年代使用CMS，如下JVM参数 ：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:HandlePromotionFailure -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”



ParNew垃圾回收器的核心参数，其实就是配套的新生代内存大小、Eden和Survivor的比例，只要你设置合理，避免Minor GC后对象放不下Survivor进入老年代，或者是动态年龄判定之后进入老年代，给新生代里的Survivor充足的空间，那么Minor GC一般就没什么问题。



同时记得把“XX:HandlePromotionFailure”打开，允许老年代空间担保，避免老年代空间小于新生代全部对象大小就触发Full GC。



然后根据你的系统运行模型，合理设置“-XX:MaxTenuringThreshold”，让那些长期存活的对象，抓紧尽快进入老年代，别在新生代里一直待着。



这样基本上一个初步的优化好的JVM参数就结合你的业务出来了。明天我们继续结合案例来分析 老年代的垃圾回收和参数优化方式。



**10、昨日思考题**



上次让大家梳理了一下**触发Full GC的几个时机**，大家一定要好好梳理一下。



**11、今日思考题**



大家看完这个案例，可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小



然后去估算一下你的系统运行模型：



- 每秒占用多少内存？
- 多长时间触发一次Minor GC？
- 一般Minor GC后有多少存活对象？
- Survivor能放的下吗？
- 会不会频繁因为Survivor放不下导致对象进入老年代？
- 会不会因动态年龄判断规则进入老年代？



# 026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参数又该如何优化呢？

2019-07-26 07:00:00

**1、前文回顾**



上一篇文章我们已经给大家介绍了一个每日百万日活以及上亿请求量的电商系统的案例背景，同时采用这个中型电商系统在大促期间的瞬时高峰下单场景，作为我们的JVM优化分析的一个场景，推测出来在大促高峰期，每秒每台机器会有300个下单请求。



进而推测出每秒钟会使用60MB的内存，然后根据这个背景推算出来了我们一台4核8G的机器上，应该如何合理的给JVM各个区域分配内存



进而可以保证每隔20多秒一次新生代GC后的100MB左右的存活对象，会进入200MB的Survivor区域内，一般不会因为Survivor塞不下或者是动态年龄判定规则让对象进入老年代中。



同时还根据Minor GC的频率，合理降低了大龄对象进入老年代的年龄，尽快让一些长期存活的对象赶紧进入老年代，不要停留在新生代里，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56510800_1564059685.cn/txdocpic/0/85fcb4db20b84da5d73133db6eb1d23d/0)



此时的JVM参数如下所示：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”



**2、在案例背景下什么时候对象会进入老年代？**



接着我们来分析一个问题，在目前优化好的背景下，一般什么情况下会让一些对象进入老年代呢？



首先第一种情况，那绝对就是“-XX:MaxTenuringThreshold=5”这个参数会让在一两分钟内连续躲过5次Minor GC的对象迅速进入老年代中。



这种对象一般就是一些@Service、@Controller之类的注解标注的那种系统业务逻辑组件，这种对象实例一般全局就有一个实例就可以了，要一直使用的



所以一般会长期被GC Roots引用，这种对象一般不会太多，大概最多一个系统就几十MB这种对象。



所以此时类似这样的长期存活的对象就会进入老年代中，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74684000_1564059685.cn/txdocpic/0/ec81e44bc63aa7026267de3628582132/0)

此外，按照我们的JVM参数，如果分配一个超过1MB的大对象，比如说你创建一个大数组或者是大List之类的，就会直接进入老年代。



但是这种大对象我们假设在这个案例里是没有的，所以可以忽略不计。



此外就是Minor GC过后可能存活的对象超过200MB放不下Survivor了，或者是一下子占到超过Surviovr的50%，此时会有一些对象进入老年代中。



但是我们之前对新生代的JVM参数进行优化，就是为了避免这种情况，经过我们的测算，这种概率应该是很低的。



但是虽说是很低，也不能完全是是没有这种情况，比如某一次GC过后可能刚好机缘巧合有超过200MB对象，就会进入老年代里。



我们可以做一个假设，大概就是这个订单系统在大促期间，每隔5分钟会在Minor GC之后有一小批对象进入老年代，大概200MB左右的大小，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99821100_1564059685.cn/txdocpic/0/7f5c4c49a7f38cf63684a0bd0ac73246/0)



**3、大促期间多久会触发一次Full GC？**

接着我们来研究一下，那么按照Full GC的触发条件，多久会触发一次Full GC？



首先来看看，Full GC的触发条件目前我们学习到的有以下4种：



（1）没有打开“ -XX:HandlePromotionFailure”选项，结果老年代可用内存最多也就1G，新生代对象总大小最多可以有1.8G



那么会导致每次Minor GC前一检查，都发现“老年代可用内存” < “新生代总对象大小”，这会导致每次Minor GC前都触发Full GC。



当然，上篇文章提到过了，现在JDK 1.6以后的版本废弃了这个参数，其实只要满足下面第二个条件就可以直接触发Minor GC，不需要触发Full GC。



（2）每次Minor GC之前，都检查一下“老年代可用内存空间” < “历次Minor GC后升入老年代的平均对象大小”



其实按照我们目前设定的背景，要很多次Minor GC之后才可能有一两次碰巧会有200MB对象升入老年代，所以这个“历次Minor GC后升入老年代的平均对象大小”，基本是很小的。



（3）可能某次Minor GC后要升入老年代的对象有几百MB，但是老年代可用空间不足了



（4）设置了“-XX:CMSInitiatingOccupancyFaction”参数，比如设定值为92%，那么此时可能前面几个条件都没满足，但是刚好发现这个条件满足了，比如就是老年代空间使用超过92%了，此时就会自行触发Full GC



其实在真正的系统运行期间，可能会慢慢的有对象进入老年代，但是因为新生代我们优化过了内存分配，所以对象进入老年代的速度是很慢的。



所以很可能是在系统运行半小时~1小时之后，才会有接近 1GB的对象进入老年代。



此时可能会因为上述的条件234中任何一个满足了，就触发Full GC。



但是这三个条件一般都需要老年代近乎占满的时候，才有可能会触发。



大家可以思考一下，我们假设在大促期间，订单系统运行1小时之后，大促下单高峰期几乎都快过了，此时才可能会触发一次Full GC。



注意，**这个推论很重要**，因为按照大促开始10分钟就有50万订单来计算，其实大促开始后一堆用户等着下单剁手购物



那么1小时候就可能有两三百万订单了，这是一年难得罕见的节日大促才会有的，然后这个高峰期过后，基本订单系统访问压力就很小了，那么GC的问题几乎就更不算什么了。



所以经过新生代的优化，可以推算出，基本上大促高峰期内，也就可能1小时才1次Full GC，然后高峰期一过，随着订单系统慢慢运行，可能就要几个小时才有一次Full GC。



**4、老年代GC的时候会发生“Concurrent Mode Failure”吗？**

经过前面的推算，我们基本可知道，假设就是订单系统运行1小时之后，老年代大概有900MB的对象了，剩余可用空间仅仅只有100MB了，此时就会触发一次Full GC，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21588300_1564059686.cn/txdocpic/0/22e96a4c676b738628bc2f7008e1367a/0)

但是有一个很大的问题，就是CMS在垃圾回收的时候，尤其是并发清理期间，系统程序是可以并发运行的，所以此时老年代空闲空间仅剩100MB了



然后此时系统程序还在不停的创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代，此时会如何？



如下图

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47901200_1564059686.cn/txdocpic/0/ccedf85c20a35383a69442daea74afe3/0)

这个时候就会触发“**Concurrent Mode Failure**”问题，因为此时老年代没有足够内存来放这200MB对象，此时就会导致立马进入Stop the World，然后切换CMS为Serial Old，直接禁止程序运行，然后单线程进行老年代垃圾回收，回收掉900MB对象过后，再让系统继续运行，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/77713000_1564059686.cn/txdocpic/0/1f36c8ae27b01d5e2c405cc83b4f7c41/0)



所以可以想一下，这种情况可能发生吗？



概率是挺小的，因为必须是CMS触发Full GC的时候，系统运行期间还让200MB对象进入老年代，这个概率其实本身就很小，但是理论上是有可能的。



大家此时需要思考一下，相对于这种小概率的事件而言，有必要去调整参数吗？



暂时看来是没有必要的，不需要针对小概率事件特意优化参数。



此时JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92”



**5、CMS垃圾回收之后进行内存碎片整理的频率应该多高？**

接着来看最后一个问题，在CMS完成Full GC之后，一般需要执行内存碎片的整理，可以设置多少次Full GC之后执行一次内存碎片整理，但是我们有必要修改这些参数吗？



其实没必要，因为通过前面的分析，在大促高峰期，Full GC可能也就1小时执行一次，然后大促高峰期过去之后，就没那么多的订单了，此时可能几个小时才会有一次Full GC。



所以就保持默认的设置，每次Full GC之后都执行一次内存碎片整理就可以，目前JVM参数如下：



“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”



其实从本文可以看到，Full GC优化的前提是Minor GC的优化，Minor GC的优化的前提是合理分配内存空间，合理分配内存空间的前提是对系统运行期间的内存使用模型进行预估。



其实对很多普通的Java系统而言，只要对系统运行期间的内存使用模型做好预估，然后分配好合理的内存空间，尽量让Minor GC之后的存活对象留在Survivor里不要去老年代，然后其余的GC参数不做太多优化，系统性能基本上就不会太差。



**6、昨日思考题**

昨天让大家可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小



然后去估算一下你的系统运行模型，每秒占用多少内存，多长时间触发一次Minor GC，一般Minor GC后有多少存活对象，Survivor能放的下吗？会不会频繁因为Survivor放不下导致对象进入老年代？会不会因动态年龄判断规则进入老年代？



希望大家好好吸收这里的精华，真正能够从业务系统运行的层面以及内存使用模型的层面去看你的各种JVM参数在系统运行期间起到的作用。



**7、今日思考题**

今天的思考题跟昨天是一样的，大家去思考一下，对你的系统运行模型做出预估，看一般多久会塞满老年代触发Full GC？触发Full GC的时候是否需要优化CMS相关的各种参数？

# 027、第4周作业：看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？

2019-07-27 07:00:00

第4周作业：

看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？



本周作业就是让大家可以直接去看看自己生产系统的JVM参数了，看看你的新生代、老年代、Eden和Survivor的大小，然后去估算一下你的系统运行模型，每秒占用多少内存，多长时间触发一次Minor GC。



一般Minor GC后有多少存活对象，Survivor能放的下吗？会不会频繁因为Survivor放不下导致对象进入老年代？会不会因动态年龄判断规则进入老年代？



根据案例的思路看看，你的各个内存区域应该给多大的大小，保证新生代gc后的存活对象尽量都留在Survivor里。



另外，对你的系统运行模型做出预估，看一般多久会塞满老年代触发Full GC？触发Full GC的时候是否需要优化CMS相关的各种参数？



结合案例学到的知识，自己动手画图，把你们系统的运行模型和内存分配，gc触发，全流程和模型都画出来，一定要自己去分析、自己思考、自己画图，这样才真正把知识给吸收了。

# 028、第4周答疑：本周问题统一答疑

2019-07-28 07:00:00

**第4周答疑：本周问题统一答疑**



**学员评论：**

看了看线上一个服务，24天，FGC 121次，真恐怖。参数使用的默认的，没有进行设置。新生代的最大容量为66m左右,老年代133m，YGC 79000多次,FGC 121次。好可怕。



**答：**对的，你们的系统应该用户不太介意性能问题，不然这个系统早就不行了



**问题**

分配担保这里捋了一下有点疑问，如果没有设置分配担保失败的话，那么老年代可用内存小于新生代所有对象内存大小时直接full gc吗？



那这样如果新生代很大，老年代还剩余很大的内存就进行fullgc，是不是有点过于着急？感觉太浪费了。这个【允许分配担保失败】jvm默认是不允许的吗？



**答：**没错，没有老年代担保失败的设置，就会频繁触发Full GC，所以一般都要打开





**问题**

老师，请教一下，一个机器能开多少线程？取决于什么？



**答：**给你一个大致的数字：如果是4核CPU，本身JVM就有一些后台线程，还有你使用的一些框架可能也会有后台线程。



所以你自己的系统一般开启线程数量在几十个，比如50左右的一个数量，基本就差不多了。



大概系统所有线程加起来有100+，此时高峰期这么多线程同时工作，CPU负载基本就满负荷了



**学员总结**

个人感觉单线程和多线程各有优缺点，单线程是占用cpu资源少，对于单核的服务器来讲是不错的



而多线程对于多核cpu更好，与之带来的优势也很明显，就是多线程显然处理起来效率更高，使得stop the world 问题恢复的更快





**问题**

我想到一个问题：文章说的新老年代内存划分应该是在jvm中是一种类似“规范”的原理。



但是那个minor gc之前会检查老年代大小，然后后续等一系列判断。这些原理是所有版本的jvm都一致的吗。跟垃圾回收器的选择是否有关系？



比如如果选择了g1 作为收集器，是否在minor  gc的过程也是一样？



**答：**基本上在g1之前都是这套原理，但是g1开始就变化了，从内存分配模型和垃圾回收机制，全部会变，所以后续有一周会专门剖析g1的原理



**问题**

老师，这个案例怎么也得16到17个线程同时并发处理，才能达到一分钟单台机器处理100个任务吧！



**答：**对的，生产系统单机开启了30+工作线程



**问题**

如果我在tomcat部署多个服务，JVM启动个数是根据服务来算的，还是根据tomcat来算的？我好像只能调试tomcat的堆栈分配情况。麻烦前辈解答下。



**答：**一个Tomcat启动多个Web应用，那JVM只有一个，就是Tomccat自己，你的Web应用都是一堆代码，由Tomcat根据 配置文件来对指定的请求调用你的代码



**问题**

看了今天文章，感觉和自己认知有点冲突，我之前一直的认知：minor gc是新生代的gc，major gc是老年代的gc，fullgc是新生代老年代和永久代的gc



marjor gc是包含在fullgc中的，然后stop the world会在full gc的时候发生,minor gc不会发生。这是我的认知。



但是文中说minor gc也会stop the world。这就有点冲突了。请老师指正，到底什么时候发生STW



**答：**看来你可能之前的认识是没有从本质认识垃圾回收和Stop the World



不管是老年代回收还是新生代回收，都要Stop the World，因为必须让程序别创建新对象，才能回收垃圾对象。



Full GC和Major GC其实是一个概念，都是指的老年代的GC，只不过一般会带着一次Minor GC，也就是Young GC，他们是一个概念多种名词



**学员回答思考题**

思考题，采用parnew+cms垃圾回收器如何只做ygc？



回答:和垃圾收集器没有什么关系，不同垃圾收集器，差别只在于性能和吞吐量的区别。并不影响垃圾回收时机。



根据堆中对象生存周期特点，合理分配eden s0 s1 大小，尽量让对象在新生代就被回收，需要注意的是要开启内存担保



**答：**是的，回答正确



**问题**

之前提到minor  gc是很快的，这么多文章看下来没有特别明确说为什么快



我的理解是:新生代垃圾回收存活很少 且采用了复制算法，比标记整理效率高。 老师还有其他原因？



**答：**其实就这个原因，存活对象少，迁移内存很快，然后一次性清理垃圾对象，这个速度就是快。



老年代要先挪动对象压在一起，存活对象那么多，这里涉及到漫长的对象移动的过程，所以速度慢



**问题**

思考题： 一个面试题，parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？



学员回答：我觉的应该考虑两个方向：避免FullGC和避免年轻代对象进入老年代 



避免FullGC 

1、保证老年代可用空间大于新生代所有对象，避免MinorGC前进行FullGC 



2、如果1可以保证，那后面-XX：HandlePromotionFailure、进入老年代的对象平均大小等比较就不需要考虑了 



3、保证MinorGC后存活对象不大于Survivor空间 



避免年轻代对象进入老年代 

1、根据实际情况查看每次MinorGC后存活对象的大小，设置合适的Survivor区域大小，保证存活对象进入survivor区，而不是进入老年代 



2、根据对象存活的时间以及MinorGC的间隔时间，确定年龄。比如：3分钟一次MinorGC，而对象可以存活1个小时，那就把对象年龄设置到20，避免对象15岁进入老年代 



3、大对象如果偶尔创建一个，可以设置-XX:PretenureSizeThreshold，使其分配至年轻代。如果创建销毁频繁，就让其直接进入老年代，利用对象池避免频繁创建销毁



**答：**你思考的非常好，其实在我们的那个案例里就说明了思路



**问题**

为什么新生代用的是复制算法?老年代用的是标记整理算法？既然复制算法比较快，为什么老年代不采用新生代的这种优化版的复制算法呢？



**答：**因为老年代的存活对象太多了，采用复制算法来回挪动大量的对象，效率更差





**问题**

我觉得老年代垃圾回收慢，是在并发标记阶段对所有老年代对象进行GC Roots追踪慢，要追踪到根源,而新生代的对象可能90%以上都不会存活,所以新生代gc快



补充，cms回收过程有4个阶段，会进入两次STW,这个也是影响速度的很大原因吧



**答：**是的，老年代垃圾回收，这个GC Roots追踪所有对象，因为老年代存活对象太多，所以耗时更长。还有考虑一下垃圾回收和整理这个环节，明天会分析



**问题**

这种每周总结一次答疑非常好，这样我们就不用每篇文章都去看评论了。老师已经把精华的问题总结出来了 ，非常好 点赞，爱你 么么哒



**答：**是的，每周的作业是一定要做的，认真做每周的作业，绝对可以把一周的内容吃透，消化成自己肚子里的东西，看答疑可以拓宽思路，看别人怎么提问的





**问题**

老师有一个问题，都已经full gc了，程序还并行运行，创建出来的对象放那？会一直触发full gc吗？



如果对象太多堆放不下，会等着full gc完成吗？这个时候也是世界停止吗？



**答：**对的，会继续放老年代，还可能会同步触发Minor GC，也可能有新的对象进入老年代，还可能有些老年代的对象失去了引用，啥都会发生，所以并发标记环节，很多是不准确的



为什么老年代垃圾回收比年轻代慢很多？学员自己的回答：

年轻代一般存活对象少，采用复制算法，从GC root出发标记存活对象，直接把存活对象复制到另一块内存，其余直接清除。



对于老年代，对象存活量大，每次遍历堆分别去标记存活对象和垃圾对象，再遍历把垃圾对象清除了，最后还要移动存活对象，防止太多内存碎片。



因为存活量大，耗时的地方我觉得在gc root引用的追踪还有存活对象的移动



**答：**对的，理解很好





**问题**

老师今天讲的cms垃圾回收器 初始标记 并发标记 重新标记 并发清理 



其中重新标记老师说只会对并发标记改动的对象进行标记，是由什么结构存储了并发标记改动的对象吗？ 不然它这么快找到并发标记改动的对象



**答：**对的，他会内置记录在并发标记期间，被新建的对象，被变动的对象，有数据结构记录，所以这个阶段很快





**问题**

老师，当发生GC的时候，做标记的阶段，回收器是从Gc root出发去搜索吗？还是遍历堆里的所有对象，如果这样的话，该对象自身怎么知道谁在引用它呢？



还有第二阶段，它是怎么做到一边标记存活对象一边标记垃圾对象的？



**答：**

1、从GC Roots出发，去标记所有对象 

2、他只要让垃圾回收线程工作的同时，让系统的工作线程也同时工作不就可以了



**为啥老年代垃圾回收慢很多？学员自己的回答：**

老年代的垃圾回收慢主要是因为剩余的存活对象很多，可能达到90%，这样子就不得不采用标记整理法



标记的过程中，并发标记是很慢的，因为对象变量要不断往上追踪看有没有gc root引用，不像方法局部变量和类变量那样直接被gc root引用，查找对象gc roots引用可能要向上追踪的次数比较多，所以耗时间



另外一个耗时间的地方就是并发清理，这个过程慢的原因是为了使得内存紧凑些，尽量不要出现内存碎片，是个边清理变移动的过程。



以上是我的分析，老师看我理解的对吗？



**答：**对的，理解的非常好



**问题**

eden区内存大小超过old，如果没有开启允许担保失败参数的话，岂不是young gc之前都会full gc了?



**答：**对的，所以开启那个担保机制



**问题**

通过GC Roots查找，直接或间接引用到的对象，就是存活的，进行标记。剩下的就是垃圾对象。在并发清除阶段就会清除了。 是这样吗？



**答：是的**





**问题**

针对web服务，POJO类一般都是在新生代，而通过@service @controller @component 等注解创建的对象一般都是在老年代。



针对一些纯java代码的后台跑批服务，基本都是新生代，除了一些通过静态变量或者常量引用的类，或者通过单例创建的类（本质也是通过静态变量引用）。



**答：**是的，总结的很好



**问题**

初始标记从GC Roots开始查找直接引用的对象。 并发标记是从对象出发，查看对象是否直接或间接有GC Roots引用 由于并发标记会查看所有对象，且大多数对象都是存活的，所以过程会很耗时。 是这样吗？



**答：**其实并发标记也是从GC Roots出发的，通过每个对象的引用地址查看哪些对象是存活的，确实因为存活对象一般较多，所以很耗时



**问题**

full gc同时一般会伴随着一次minor GC，如果第一次full GC过程中，因为新创建的对象原因又达到了触发fullGC的条件，首先还是会先minorGC，然后尝试放入新生代



但此时老年代还没有回收完成，再触发一次MajorGC没什么意义，因为重新标记会干了这个事情。 



如果minorGC后，新创建的对象仍然放不进内存，需要等待MajorGC结束，如果MajorGC结束后仍然放不进去，就会OOM了



**答：**总结的很好





**问题**

老师 有点没明白1 eden + 2 survivor的设计 为了优化空间利用 一定得是三块吗？为什么不能是两块？9:1不是也行吗



**答：**你看，如果一个eden一个survivor，那么回收的时候把两块区域的存活对象标记出来，放哪儿去？必须有另外一个survivor来存放，然后一次性回收之前的那个eden和survivor



**问题**

问一哈，之前课程新生代复制算法，老年代采用标记整理算法，为何CMS作为老年代垃圾回收，是采用标记清除算法呀



**答：**仔细看看今天的文章就明白了，CMS其实在标记-清理之后，会加入一个整理的过程，他是两个算法都用了



**问题**

新生代只需要一次"stop the world"的时间，在此期间完成标记清除并把存活对象转到survivor或老年代吗？



**答：**没错



**问题**

老师，有个问题要问您，因为CMS在“初始标记阶段”只标记直接引用。那么在“并发标记阶段”是不是是在初始标记阶段的基础上进行的



比如初始标记 标记了一个直接引用为A类，那么在并发标记阶段就不用再从A类的GC Roots开始了，直接从A类继续往下找就可以了。然后没有被遍历过的GC Roots接着被遍历就好了。



还有就是老师 CMS是标记-清除算法的话，那要是有个大对象进入到老年代没因为内存碎片问题放不下，那还得进行一次Full GC，如果GC后还是放不下，是不是就OOM了？



**答：**对的，可以节约时间。



明天的文章会讲解这个情况，这种对象是浮动垃圾，如果在cms gc期间进入老年代发现没有内存了，会引发concurrent mode failure问题，然后直接用serial old垃圾回收器进行回收，如果回收过后还会没地方放，那么才会oom





老年代的垃圾回收之所以比新生代慢很多，我觉得有以下几个原因： 



\1. ygc的把存活的对象直接复制到s区，而e区直接清空，不存在内存碎片化问题。



\2. 从老年代的CMS而言，虽然它做到了尽可能的优化，但是其存在繁复的4步才能实现清理。



\3. 本文介绍了老年代的垃圾回收机制，但是通过前面的文章我们知道，做了清理之后，是存在碎片化的问题，故而还需要搬运工把这些七零八落的存活对象重新排列，紧密的靠在一起，而老年代中存活的对象可能还是比较大的，那么就需要更多的搬运时间，这个过程也是比较耗时的。 



另外还想请教老师一个问题：当解决碎片化问题后，那么这些对象的引用地址都会发生变化，那么该引用该对象的变量是如何修订引用地址的呢？



**答：**这个修改引用地址是全透明的，其实内存地址变了，引用的地址也修改就可以了



**学员总结**

判断对象是否存活通过遍历GC Roots，遍历过程中可能会发现，能被GC Roots 关联到的对象中，新生代可能占到了1% ，老年代占到了99%，然后从被关联到的对象出发追踪存活对象。



所以1%对象的追踪时间和99%的对象追踪时间是不一样的，也就是说老年代追踪时间大概是新生代的99倍。再加上老年代需要碎片整理。所以老年代垃圾回收时间比新生代长的多





**问题**

老师，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况？



若有，jvm是怎么处理的，若没有，jvm是如何保证的呢？



**答：**新生代垃圾回收会直接Stop the World，系统不能运行了，所以必须等垃圾回收完了，才能再次gc；



老年代垃圾回收是有可能的，因为采用了并发收集的机制，一边回收，系统一边运行，也许没回收完就再次触发full gc，此时会进入stop the world，用serial old来回收



**问题**

看了昨天的评论，老师说了MinorGC其实也会Stop the World。我理解应该就是在跟踪复制阶段是不是？



如果真要用Stop，那么用时间来计算，是不是可以忽略不计，一般情况下。比如10ms，或者5ms就能完成这个步骤？烦请老师解惑下。



**答：**对的，新生代要stop the world，但是他速度很快，就是从gc roots出发标记出来少量存活对象，转移到空的survivor里，然后直接清空所有垃圾对象



**问题**

老师，我有个疑问，新生代我估算出来后，老年代该怎么设置。如果老年代过小了，也会有问题的吧。老年代和新生代有没有比较合适的分配比例。



**答：****没有通用比例，其实一切说通用的jvm优化参数，全都是瞎说的**



因为通过目前20多篇文章的学习，大家就应该知道了，jvm参数优化，全部得基于每个不同系统的运行模型来分析，每个系统的jvm参数都应该是不同的，从看问题的本质，而不是找一个什么通用的比例



**问题**

请问在初始标记的时候是从GC Root出发找对象还是从老年代的每个对象开始看有没有被GC Root引用, 在并发标记的时候是从GC Root 出发还是第一次被标记过的对象开始, 在标记的过程中采用的是深度优先算法还是广度优先算法?



**答：**初始标记从GC Roots出发，仅仅标记直接引用的对象，但是并发标记也是从GC Roots追踪，只不过要一直顺着引用链条追踪看哪些对象是存活的



**问题**

我想请问一个问题就是通过什么方式可以得知系统进行了MinirGC或者FullGC？



**答：**有gc日志，还有很多的工具可以干这些事儿，后续我们会介绍的





**学员评论**

打卡，昨天又漏打卡了。跟着老师走，讲的言简意赅，比看深入理解虚拟机容易懂，配图好理解。看后自己绘图加深理解，基本JVM就容易回答面试题了。



结合实际项目考虑这些因素进去，事倍功半。老师辛苦了。



**答：**是的，接下来有两个案例解析，全程通过案例分析，教你们新生代和老年代的gc相关jvm参数如何根据系统去优化设置



**问题**

老师好，如果在垃圾回收时程序停止运行，那垃圾回收器用多线程回收还有什么意义呢，一样还是出现卡顿的现象



**答：**垃圾回收用多线程可以加快垃圾回收的速度啊，进而减少Stop the World的时间



**问题**

请问一下在Eden和Survivor区GC时也是从GC Root开始标记和跟踪对象, 在新生代的对象数量更多为什么在新生代就不耗时而在老年代GC的时候第二步并发清理的GC Root跟踪就很耗时?





**答**对的，GC Roots开始追踪，但是新生代存活对象极少，很快就追踪完毕了 ，老年代存活对象太多，追踪很耗时



**学员评价**

看过《深入JVM》一书和一些面试资料，再看本系列，还是有很大收获。 



主要是老师讲的很有思路条理，能让读的人深入理解。 



例如三区的分区思想，为啥分区，分区比例。 然后复制算法在三区里面怎么用的等等。 不止是理解这个技术点，还领会到了思路。



**答**多谢支持，继续加油学习



**问题**

标记清理后进行整理，不就是标记整理算法吗？为什么说两个算法都使用了呢？ 难道是我理解错了标记整理算法？标记整理算法不会有清理的过程？



**答**标记清理是先标记再清理，cms是这种算法，然后事后再整理；标记整理是先标记然后整理，最后才清理



**问题**

新创建的对象，到底是往Eden区放，还是Suivivor区域放？ 



我的理解是新的对象只会放入Eden中，而Survivor区只是用于存放每次Minor GC后的对象而已，新创建的对象是不会往Suivivor存放的



**答**没错，只放eden，survivor只放存活对象



**问题**

老师刚才的讲解解答了困扰我很久的疑惑，谢谢老师，那就是说，如果我需要控制对象不进入到老年代，那就必须保证s区存活对象不能超过50%，不然根据累加来看，年龄>（占比50%中的最大年龄）的对象就会进入到老年代。



**答**对的，所以要尽可能让每次gc后存活对象在survivor区的50%以内



**问题**

年轻代标记存活对象，那老年代的CMS回收器标记存活对象还是标记垃圾对象，如果只标记存活对象 ，那并发清理阶段，会有新的对象晋升到老年代，这些对象CMS可是没有做标记存活的，那清理的时候不就把这些对象也一起清理了吗？



**答**对的，所以文章里也说了，清理的时候仅仅清理标记的垃圾对象，然后并发清理的时候，新进入老年代的对象就是浮动垃圾，不会清理，所以可能会触发concurrent mode failure



**问题**

1. CMS设置的的空间占比1.6是92%，这之后就一直没有变化吗 
2. 发生ConcurrentModeFailure，启用 SerialOld 后，是只有SerialOld在工作，还是SerialOld和CMS一起工作
3. 只有“老年代可用空间大于历次新生代GC进入老年代的对象平均大小”这种情况会考虑老年代-XX:CMSInitiatingOccupancyFaction设置的占比吗，其他两种FullGC情况不需要考虑吗，还是说所有的FullGC都会考虑这个占比



**答**

1. 后面通过工具会让大家看到这些参数的值 
2. 那肯定只有Serial Old了，因为并发回收，人家一直创建对象，搞的老年代都不下了，赶紧要stop the world，让系统程序别运行了，然后Serial Old单线程直接回收，完事儿了，空出来了空间再让系统继续运行 
3. 条件独立，触发任何一个都会有Full GC



**问题**

老师，如果是通过动态年龄进入到老年代的对象，这一批对象的年龄最多也就是1吧，不可能熬了几轮才根据动态年龄进入到老年代（这一批对象第一次进入到s区时是1，第二次minorgc发现对象占用内存超过S区一半，直接进入老年代），麻烦老师对这个详细解惑下。



**答**对的，其实是这个年龄以及低于这个年龄的对象占据超过Survivor 50%，比如1岁，2岁，3岁的对象加起来占据了50%了，此时超过3岁的就会直接进老年代



**问题**

Handlerpromotionfailure参数是jdk8默认开启的吗。看完文章，我忍不住想调优一下了



**答**对的，默认开启的，可以的，就是要鼓励你们按照文章思路去分析自己的系统运行的内存使用模型，然后去尝试合理分配内存大小



前期要学会的优化就是一定要减少对象进入老年代，避免进行Full GC，尽量保证就是Minor GC，做到这一点，基本JVM就没什么大问题





**问题**

总结一下自己看完的感悟，目前看到老师案例的调优思路主要是两点。



第一，让常驻对象尽快进入老年代，以免留在新生代占用空间。



第二，避免让使用一次或者两次的对象(比如订单对象)进入老年代，从而可以避免漫长的full gc。



**答**是的，其实核心的JVM优化就是这个思路，前期把原理都学通了，悟透了，后续的案例会动手实操，结合更多案例来体验不同的场景优化





**学员总结**

感觉CMS就像一个手脚勤快的小伙子，在合适的时机进行并行工作，提高效率，但总有漏网之鱼（浮游垃圾）。



在小伙子顶不住的时候（没足够空间了，Concurrent Mode Failure），在背后注视着一切的老者（Serial Old）走了出来，大喊一声：Stop the world！有条不紊的把所有垃圾都清理掉，深藏功与名。



但是，但老者也顶不住的时候，就会发生灾难性的OOM。但据说，学了这门课的同学，都不曾见过这样的灾难。（如有不当之处，请老师指正）





**答**这个文采写的相当好，描述的很准确



**学员总结**

老师，我的一些总结和问题，请大家指正，谢谢！



*对象进入触发 -->哪些情况下有对象进入老年代？*



我知道的在下面 



1. 大对象直接分配到老年代 ---> 直接分配那如果一旦大于老年代可用也要触发fgc吧？ 

2. minorgc的年龄到了15（有参数设置） 

3. 存活对象大于s区 --->这个存活对象包括年龄到了的对象吗？ 

4. 动态年龄挤出对象 规则触发 

5. - Minor Gc前没有配置空间担保参数 
   - Minor Gc前有配置空间担保参数，但老年代可用内存小于历次平均分配内存 
   - minor Gc回收后的存活对象大于S区，大于老年代可用内存 
   - 老年代已用空间达到CMSInitiatingOccupancyFaction 设置比例自动触发。



**答：总结的非常好**





**学员总结**

首先，计算系统高峰的qps，每秒内存开销=qps*单个对象大小*扩大20倍*其他操作10倍。 根据系统可用内存分配堆大小。分配年轻代大小根据每秒产生的内存开销来计算。 

比如每秒60mb,2g给年轻代,默认eden:s1:s2为8:1:1,eden区有1.6g空间,26s左右会被占满，会进行minor gc。 

此时存活的对象大概会有百分之10,160mb，这些存活的对象进入s1。有可能新生代回收的对象存活的可能在200mb以上， 那这样就会造成这些对象会直接进入老年代。这样就可以继续往上调新生代空间的大小,也可以调节eden区和s1 s2的比例。 

空间担保参数也要打开，避免判断小于直接fullgc。系统中可能会有在内存中缓存大的对象,大的集合,这种对象一般都是要频繁使用或者要一直缓存的 ，这时候要设置直接晋升到老年代对象的大小。

还有在s1s2区设置晋升老年代年龄的设置，这个一般默认的我觉得目前就够用，要根据实际项目来设置. 垃圾回收器设置为parnew 还有cms。充分发挥多核处理器的优势。 

整体来说，我觉得就是优化尽量避免频繁fullgc，降低系统STW的次数还有时间。



**答** 非常好



**问题**

老师，有几个问题请教一下： 

*1、Minor GC前，年轻代中对象的总大小与老年代中可用内存比较，其中，可用内存是指剩余内存空间还是连续可用内存空间* 



*2、文章中说，老年代会默认预留8%的空间给并发回收期间，进入老年代的对象使用，若进入老年代的对象大于8%的空间，是否会触发Full GC* 



*3、若CMS在并发标记和并发回收时，进入老年代的对象又触发了Full GC，后一次的Full GC会立即执行还是等待前一次Full GC执行完毕*



**答**

1、连续可用空间 

2、其实之前说过，这种情况会触发concurrent mode failure，用serial old进行垃圾回收，直接stop the world 

3、同上





**问题**

*目前系统16G内存，jvm6G的内存，新生代5.5G，永久代设置128我M，老年代就是512减去128 等于384 M* 



minor gc大概450秒运行一次也就是8分钟 每次在eden区12M左右的对象 一个supervisor区 560M内存 每次回收之后大概占比空间的 百分之40到百分之60之间，supervisor空间是够的 第二占比 在百分之60一下 同年对象占比超过50的概率很低 



之前晋升次数为31我 改成4了 一次minor gc8分钟，4次半小时，肯定需要进入老年代了 



目前系统运行离更新 半个月 full gc 3次，所以我觉得堆内存就是合理优化minor gc 让对象不会那么快进入老年代 做出合理的预估 其实也不是堆越大越好 是需要根据系统整体运行情况预估 如果预估不准确 就用工具检测 然后合理优化



**答：****这个作业分析是我目前见过最好的一个，分析的非常好，看来你是彻底吃透我们目前讲解的内容了**



**问题**

堆内存的调整 我觉得应该是观察 supervisor区 是不是 minor gc后占比过多 超过百分之70 可能就需要加大堆内存 或者说 业务高峰期 非常快就占满eden区 也需要加大堆内存 具体还有什么情况 请老师指正！



**答**

你理解没错，其实jvm优化的第一步，就是分析系统运行的内存使用模型，然后合理预估，合理分配内存，保证对象都在新生代里，进入老年代的速度要很慢很慢，做到这一点，jvm就是很完美的一个状态



**问题**

*最后那个设置多少次FullGC之后进行碎片整理，我是否可以这样理解：*



如果Full GC相对频繁一些，那就设置多次FullGC再碎片整理。



如果Full GC不是很频繁，可以设置每次FullGC都碎片整理，反正也占用不了多少时间。



这里先不考虑Full GC频繁是否调优，只是单纯以碎片整理这个参数怎么设置来考虑



**答：**是的，你说的很对，其实我觉得你基本都理解了

# 029、大厂面试题：最新的G1垃圾回收器的工作原理，你能聊聊吗？

2019-07-29 07:00:00

**目录：**



1、ParNew + CMS的组合让我们有哪些痛点？



2、G1垃圾回收器



3、G1是如何做到对垃圾回收导致的系统停顿可控的？



4、Region可能属于新生代也可能属于老年代



5、本文总结

6、今日思考题







**1、ParNew + CMS的组合让我们有哪些痛点？**

上周我们已经彻底把垃圾回收机制给讲清楚了，包括ParNew和CMS两个垃圾回收器对新生代和老年代进行垃圾回收的运行原理，大家都了解的很清楚了。



那么我们先来分析一下目前ParNew + CMS带给我们的痛点是什么？



Stop the World，这个是大家最痛的一个点！



无论是新生代垃圾回收，还是老年代垃圾回收，都会或多或少产生“Stop the World”现象，对系统的运行是有一定影响的。



所以其实之后对垃圾回收器的优化，都是朝着减少“Stop the World”的目标去做的。



在这个基础之上，G1垃圾回收器就应运而生了，他可以提供比“ParNew + CMS”组合更好的垃圾回收的性能。



**2、G1垃圾回收器**

G1垃圾回收器是可以同时回收新生代和老年代的对象的，不需要两个垃圾回收器配合起来运作，他一个人就可以搞定所有的垃圾回收。



**他最大的一个特点，就是****把Java堆内存拆分为多个大小相等的Region**，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76117700_1564333462.cn/txdocpic/0/df4b9e1402611bb109733c47e6cc7e8e/0)



然后G1也会有新生代和老年代的概念，但是只不过是**逻辑上的概念**



也就是说，新生代可能包含了某些Region，老年代可能包含了某些Reigon，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/91644300_1564333462.cn/txdocpic/0/f71f92006437d1cbcb4635092067fe21/0)



而且G1最大的一个特点，就是可以让我们**设置一个垃圾回收的预期停顿时间**



也就是说比如我们可以指定：希望G1同志在垃圾回收的时候，可以保证，在1小时内由G1垃圾回收导致的“Stop the World”时间，也就是系统停顿的时间，不能超过1分钟。



这个就很厉害了，大家如果看明白了之前我们的很多JVM优化的思路，都明白一点，其实我们对内存合理分配，优化一些参数，就是为了尽可能减少Minor GC和Full GC，尽量减少GC带来的系统停顿，避免影响系统处理请求。



但是现在我们直接可以给G1指定，在一个时间内，垃圾回收导致的系统停顿时间不能超过多久，G1全权给你负责，保证达到这个目标。



这样相当于我们就可以直接控制垃圾回收对系统性能的影响了。



***3、G1是如何做到对垃圾回收导致的系统停顿可控的？***

其实G1如果要做到这一点，他就必须要追踪每个Region里的回收价值，啥叫做回收价值呢？



他必须搞清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以回收掉多少垃圾？



大家看下图，G1通过追踪发现，1个Region中的垃圾对象有10MB，回收他们需要耗费1秒钟，另外一个Region中的垃圾对象有20MB，回收他们需要耗费200毫秒。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/6423300_1564333463.cn/txdocpic/0/5d25c2f6a367594830b65def6421def3/0)

然后在垃圾回收的时候，G1会发现在最近一个时间段内，比如1小时内，垃圾回收已经导致了几百毫秒的系统停顿了，现在又要执行一次垃圾回收，那么必须是回收上图中那个只需要200ms就能回收掉20MB垃圾的Region啊！



于是G1触发一次垃圾回收，虽然可能导致系统停顿了200ms，但是一下子回收了更多的垃圾，就是200MB的垃圾，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/17355100_1564333463.cn/txdocpic/0/b74a4f4cbbfa79db935272e8ab7e061e/0)

所以简单来说，G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。



这就是G1的**核心设计思路**。



**4、Region可能属于新生代也可能属于老年代**

另外在G1中，每一个Region时可能属于新生代，但是也可能属于老年代的



刚开始Region可能谁都不属于，然后接着就分配给了新生代，然后放了很多属于新生代的对象，接着就触发了垃圾回收这个Region，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35384900_1564333463.cn/txdocpic/0/643d265d93b6ce3d9c04b6033640320b/0)



然后下一次同一个Region可能又被分配了老年代了，用来放老年代的长生存周期的对象，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/50699600_1564333463.cn/txdocpic/0/5e2c1c9655e7ff1d08bb6925ebd097c5/0)



所以其实在G1对应的内存模型中，Region随时会属于新生代也会属于老年代，所以没有所谓新生代给多少内存，老年代给多少内存这 一说了



实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。



**5、本文总结**

本文先初步的介绍一下G1垃圾回收器的设计思想，包括Region的划分，然后Region动态转移给新生代或者老年代，按需分配



然后触发垃圾回收的时候，可以根据设定的预期系统停顿时间，来选择**最少回收时间和最多回收对象的Region进行垃圾回收**，保证GC对系统停顿的影响在可控范围内，同时还能尽可能回收最多的对象。



大家把本文思路串起来看看，首先高屋建瓴的对G1垃圾回收器的整体设计思想有了一定的理解。



在接下来的文章中，我们会逐步深入去看更多技术细节，比如：

- G1是如何工作的？
- 对象什么时候进入新生代的Region？
- 什么时候触发Region GC？
- 什么时候对象进入老年代的Region？
- 什么时候触发老年代的Region GC？



**6、今日思考题**

大家看看自己负责的系统，有没有谁是已经在生产用了G1垃圾回收器的？



如果没有的话，可以想想为什么自己还没用G1？如果用了的话，可以看看G1的效果如何？



# 030、G1分代回收原理深度图解：为什么回收性能比传统GC更好？

2019-07-30 07:00:00

**1、前文回顾**



上篇文章我们给大家分析了一下G1垃圾回收器设计的思想，主要是把内存拆分为很多个小的Region，然后新生代和老年代各自对应一些Region，回收的时候尽可能挑选停顿时间最短以及回收对象最多的Region，尽量保证达到我们指定的垃圾回收系统停顿时间。



这篇文章我们继续一步一图，把G1垃圾回收器工作的时候，从对象在内存中的分配到垃圾回收的触发，给大家来分析一下。



**2、如何设定G1对应的内存大小**



大家看如下的图，我们都知道G1对应的是一大堆的Region内存区域，每个Region的大小是一致的。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/55505200_1564395424.cn/txdocpic/0/db6e9e39b5ce000de030e7dc6b91810a/0)



那么首先思考两个问题：到底有多少个Region呢？每个Region的大小是多大呢？



其实这个默认情况下自动计算和设置的，我们可以给整个堆内存设置一个大小，比如说用“-Xms”和“-Xmx”来设置堆内存的大小。



然后JVM启动的时候一旦发现你使用的是G1垃圾回收器，可以使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，此时会自动用堆大小除以2048



因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的。



比如说堆大小是4G，那么就是4096MB，此时除以2048个Region，每个Region的大小就是2MB。大概就是这样子来决定Region的数量和大小的，大家一般保持默认的计算方式就可以



如果通过手动方式来指定，则是“-XX:G1HeapRegionSize”，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79268700_1564395424.cn/txdocpic/0/4ad559530fc1c3013c8aaece423c92fd/0)

刚开始的时候，默认新生代对堆内存的占比是5%，也就是占据200MB左右的内存，对应大概是100个Region，这个是可以通过“-XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。



因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”。



而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少，这些其实都是动态的。



大家看下图，刚开始就是一部分的Region是属于新生代的。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/11170800_1564395425.cn/txdocpic/0/774b3a2de1407af9de5e7fed0896fa8f/0)



**3、新生代还有Eden和Survivor的概念吗？**



没错，其实在G1中虽然把内存划分为了很多的 Region，但是其实还是有新生代、老年代的区分



而且新生代里还是有Eden和Survivor的划分的，所以大家会发现之前学习的很多技术原理在G1时期都是有用的。



大家应该还记得之前说过的一个新生代的参数，“-XX:SurvivorRatio=8”，所以这里还是可以区分出来属于新生代的Region里哪些属于Eden，哪些属于Survivor。



比如新生代之前说刚开始初始的时候，有100个Region，那么可能80个Region就是Eden，两个Survivor各自占10个Region，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/34885700_1564395425.cn/txdocpic/0/f36695ab9cd0f4cf871cfb51d401befe/0)



所以大家要明白在这里其实还是有Eden和Survivor的概念的，他们会各自占据不同的Region。



只不过随着对象不停的在新生代里分配，属于新生代的Region会不断增加，Eden和Survivor对应的Region也会不断增加。



**4、G1的新生代垃圾回收**



既然G1的新生代也有Eden和Survivor的区分，那么触发垃圾回收的机制都是类似的



随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，直到新生代占据堆大小的最大比例60%。



一旦新生代达到了设定的占据堆内存的最大大小60%，比如都有1200个Region了，里面的Eden可能占据了1000个Region，每个Survivor是100个Region，而且Eden区还占满了对象，此时如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/62162400_1564395425.cn/txdocpic/0/98cca872e36020564d24191ebe9dae39/0)

这个时候还是会触发新生代的GC，G1就会用之前说过的复制算法来进行垃圾回收，进入一个“Stop the World”状态



然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85873300_1564395425.cn/txdocpic/0/2d6fd54a3e06d5e02e2ee3c6cf86353b/0)



但是这个过程跟之前是有区别的，因为G1是可以设定目标GC停顿时间的，也就是G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。



那么G1就会通过之前说的，对每个Region追踪回收他需要多少时间，可以回收多少对象来选择回收一部分的Region，保证GC停顿时间控制在指定范围内，尽可能多的回收掉一些对象。



**5、对象什么时候进入老年代？**



大家都知道，在G1的内存模型下，新生代和老年代各自都会占据一定的Region，老年代也会有自己的Region



按照默认新生代最多只能占据堆内存60%的Region来推算，老年代最多可以占据40%的Region，大概就是800个左右的Region。



那么对象什么时候从新生代进入老年代呢？



可以说跟之前几乎是一样的，还是这么几个条件：



**（1）**对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，“-XX:MaxTenuringThreshold”参数可以设置这个年龄，他就会进入老年代



**（2）**动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%



此时就会判断一下，比如年龄为1岁，2岁，3岁，4岁的对象的大小总和超过了Survivor的50%，此时4岁以上的对象全部会进入老年代，这就是动态年龄判定规则



大家看下图，所以经过一段时间的新生代使用和垃圾回收之后，总有一些对象会进入老年代中。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/14961300_1564395426.cn/txdocpic/0/5c2c89d0b6c7899f4f52c0c1228a534b/0)



**6、大对象Region**



大家此时可能会疑惑了，唉？以前说是那种大对象也是可以直接进入老年代的，那么现在在G1的这套内存模型下呢？



实际上这里会有所改变，G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。



在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对象超过了1MB，就会被放入大对象专门的Region中



而且一个大对象如果太大，可能会横跨多个Region来存放。如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/46320600_1564395426.cn/txdocpic/0/8e7d241fe34a0b1c5fd785e96066bccc/0)



肯定还有人会问，那堆内存里哪些Region用来存放大对象啊？



不是说60%的给新生代，40%的给老年代吗，那还有哪些Region给大对象？



很简单，之前说过了，在G1里，新生代和老年代的Region是不停的变化的



比如新生代现在占据了1200个Region，但是一次垃圾回收之后，就让里面1000个Region都空了，此时那1000个Region就可以不属于新生代了，里面很多Region可以用来存放大对象。



那么还有人会问了，大对象既然不属于新生代和老年代，那么什么时候会触发垃圾回收呢？



也很简单，其实新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回收的策略。



**7、本文总结**



本文就初步介绍了G1的内存模型和分配规则，包括了下面的一些知识：

- 每个Region多大
- 新生代包含多少Region，
- 新生代如何动态增加Region
- Eden和Survivor两个区域仍然还是存在
- 什么时候触发新生代的垃圾回收
- 垃圾回收的复制算法
- 还有G1特有的预设GC停顿时间的作用
- 什么时候对象进入老年代
- 大对象的独立Region存放和回收



大家基本就搞清楚了新生代的内存分配、对象分配和垃圾回收的策略，还有对象进入老年代的时机



下一篇文章，我们就会分析**G1的老年代的垃圾回收机制**，相对来说会更为复杂。



**8、今日思考题**



看完了今天的文章之后，大家可以思考一下：



从新生代的垃圾回收来看，大家觉得G1垃圾回收器在新生代垃圾回收过程中，相比之前的ParNew而言，**最大的进步在哪里？**

**End**

# 031、动手实验：线上系统部署如果采用G1垃圾回收器，应该如何设置参数？

2019-07-31 07:00:00

**1、前文回顾**



上篇文章大家已经搞清楚了G1的动态内存管理策略，他会根据情况动态的把Region分配给新生代、Eden、Survivor、老年代和大对象，但是新生代和老年代有一个各自的最大占比，然后在新生代的Eden满的时候，触发新生代垃圾回收。



新生代的垃圾回收还是采用了复制算法，只不过会考虑预设GC停顿时间，保证垃圾回收的停顿时间不能超过预设时间，因此会挑选一些Region来进行垃圾回收。



然后跟之前说的一样，如果一些对象在新生代熬过了一定次数的GC，或者是触发了动态年龄判定规则，或者是存活对象在Survivor放不下了，都会让对象进入老年代中。



而大对象则是进入单独的大对象Region，不再进入老年代。



所以实际上在G1中，还是会存在新生代的对象慢慢会因为各种情况进入老年代的。



**2、****什么时候触发新生代+老年代的混合垃圾回收？**



G1有一个参数，是“-XX:InitiatingHeapOccupancyPercent”，他的默认值是45%



意思就是说，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。



比如按照我们之前说的，堆内存有2048个Region，如果老年代占据了其中45%的Region，也就是接近1000个Region的时候，就会开始触发一个混合回收，如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49902200_1564483609.cn/txdocpic/0/8c756171f4df5f545487ae587b3c87c0/0)



**3、G1垃圾回收的过程**



首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC  Roots直接能引用的对象，这个过程速度是很快的。



如下图，先停止系统程序的运行，然后对各个线程栈内存中的局部变量代表的GC Roots，以及方法区中的类静态变量代表的GC Roots，进行扫描，标记出来他们直接引用的那些对象。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/69547800_1564483609.cn/txdocpic/0/f14f155db0f70244d2ca3a543b5c01f7/0)



接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92482000_1564483609.cn/txdocpic/0/a1cac6cd668144a9fbcc655b546e1c1c/0)



这里对GC Roots追踪做更加详细的说明，比如下面的代码



大家可以看到，Kafka这个类有一个静态变量是“replicaManager”，他就是一个GC Root对象，初始标记阶段，仅仅就是标记这个“replicaManager”作为GC Roots直接关联的对象，就是“ReplicaManager”对象，他肯定是要存活的。



然后在并发标记阶段，就会进行GC Roots追踪，会从“replicaManager”这个GC Root对象直接关联的“ReplicaManager”对象开始往下追踪



可以看到“ReplicasManager”对象里有一个实例变量“replicaFetcher”，此时追踪这个“replicaFetcher”变量可以看到他引用了“ReplicaFetcher”对象，那么此时这个“ReplicaFetcher”对象也要被标记为存活对象。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/16851400_1564483682.png)



这个并发标记阶段还是很耗时的，因为要追踪全部的存活对象。



但是这个阶段是可以跟系统程序并发运行的，所以对系统程序的影响不太大。



而且JVM会对并发标记阶段对对象做出的一些修改记录起来，比如说哪个对象被新建了，哪个对象失去了引用。



接着是下一个阶段，最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/9875900_1564483610.cn/txdocpic/0/a5ba2998ff473519aed188ae9acd882e/0)



最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。



接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我们指定的范围内。



比如说老年代此时有1000个Region都满了，但是因为根据预定目标，本次垃圾回收可能只能停顿200毫秒，那么通过之前的计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region，把GC导致的停顿时间控制在我们指定的范围内，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/31957000_1564483610.cn/txdocpic/0/1139a6e2b39fec9a6147b4681593b9b0/0)



而且大家需要在这里有一点认识，其实老年代对堆内存占比达到45%的时候，触发的是“混合回收”



也就是说，此时垃圾回收不仅仅是回收老年代，还会回收新生代，还会回收大对象。



那么，到底是回收这些区域的哪些Region呢？



那就要看情况了，因为我们设定了对GC停顿时间的目标，所以说他会从新生代、老年代、大对象里各自挑选一些Region，保证用指定的时间（比如200ms）回收尽可能多的垃圾，这就是所谓的混合回收，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/58234100_1564483610.cn/txdocpic/0/96d0505c1a95d595da1602572b735353/0)



**4、G1垃圾回收器的一些参数**



大家在上面都看到了，一般在老年代的Region占据了堆内存的Region的45%之后，会触发一个混合回收的过程，也就是Mixed GC，分为了好几个阶段。



在这里最后一个环节，其实就是执行混合回收，从新生代和老年代里都回收一些Region。



但是最后一个阶段混合回收的时候，其实会停止所有程序运行，所以说G1是允许执行多次混合回收。



比如先停止工作，执行一次混合回收回收掉 一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。



有一些参数可以控制这个，比如“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次



意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。



如下图，假设一次混合回收预期要回收掉一共有160个Region，那么此时第一次混合回收，会回收掉一些Region，比如就是 20个Region。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/77654400_1564483610.cn/txdocpic/0/4dbd40e7a95b7bf9b8d48388bbeec1d1/0)



接着恢复系统运行一会儿，然后再执行一次“混合回收”，如下图，再次回收掉20个Region。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3865200_1564483611.cn/txdocpic/0/4dbd40e7a95b7bf9b8d48388bbeec1d1/0)

如此反复执行8次混合回收阶段之后 ，不就把预订的160个Region都回收掉了？而且还把系统停顿时间控制在指定范围内。



那么为什么要反复回收多次呢？



因为你停止系统一会儿，回收掉一些Region，再让系统运行一会儿，然后再次停止系统一会儿，再次回收掉一些Region，这样可以尽可能让系统不要停顿时间过长，可以在多次回收的间隙，也运行一下。



还有一个参数，就是“-XX:G1HeapWastePercent”，默认值是5%



他的意思就是说，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉



如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27702500_1564483611.cn/txdocpic/0/f901c786a737d416daefd7ad953b7b03/0)



这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，意味着本次混合回收就结束了。



而且从这里也能看出来G1整体是基于复制算法进行Region垃圾回收的，不会出现内存碎片的问题，不需要像CMS那样标记-清理之后，再进行内存碎片的整理。



还有一个参数，“-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，意思就是确定要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收



否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region，这个成本是很高的。



**5、回收失败时的Full GC**



如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里去



此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。



一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢的。



**6、本文总结**



本文看完，大家基本上对老年代占堆内存45%的时候触发的Mixed垃圾回收的过程就很清楚了



包括如何标记，如何进行混合回收，回收时采用的复制算法，包括一些对应的参数的含义。



**7、今日思考题**



大家结合我们之前针对ParNew+CMS的组合分析过的JVM GC优化思路，可以考虑一下：



- 如果使用G1垃圾回收的时候，应该值得优化的是什么地方？
- 什么时候可能会导致G1频繁的触发Mixed混合垃圾回收？
- 如何尽量减少Mixed GC的频率？

# 032、案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能（上）？

目录：

1、案例背景引入

2、系统核心业务流程分析



3、系统的运行压力



4、本文总结与下文预告





**1、案例背景引入**



咱们接下来用一个真实的案例来给大家聊聊G1垃圾回收器的一些性能优化的手段和背后的原理



其实核心思想跟之前我们讲过的“ParNew+CMS”的垃圾回收器组合的优化思想是类似的，但是因为G1的运行原理有一些不一样的地方，所以说在优化上会略有不同。



首先我们来说说案例的背景，这是一个百万级注册用户的在线教育平台，主要目标用户群体是几岁到十几岁的孩子，注册用户大概是几百万的规模，日活用户规模大概在几十万。



系统的业务流程其实也不复杂，而且我们可以排除掉一些选课、排课、浏览课程详情以及付费购买之类的低频的行为。



为什么这么说呢？大家可以想一下，一个在线教育平台，本来用户也不是特别多，他不是一个电商平台，不会说每天每个人都会进来浏览幼儿课程详情。



所以一般业务流程就是，有人进来浏览一下 ，考虑一段时间，然后下定决心了给自己孩子报名一个在线的英语课程，或者数学课程之类的。



所以其实他的普通用户浏览课程详情、下单付费、选课排课，这些都是绝对的低频行为，我们几乎不用考虑到系统的运行中去，可以暂时忽略掉。



那么对于这样的一个系统，他最关键的高频行为是什么呢？



**上课！**



也就是说，大家从这个系统的本质来思考一下，这样的一个平台，他的使用人群是幼儿园的孩子到中小学的孩子



他们平时白天都要上学，一般也就是晚上放学之后到八九点钟的样子，是最活跃使用这个平台的时候，还有就是周末也是最活跃使用这个平台的时候。



这里尤为关键的需要注意的，就是每天晚上那两三小时的高峰时期，几乎你可以认为每天几十万日活用户（那些小孩儿）都会集中在这个时间段来平台上上在线课程，比如青少年英语课，或者数学课之类的。



所以这个晚上两三小时的时间段里，将会是平台每天绝对的高峰期，而且白天几乎没什么流量，可能99%的流量都集中在晚上，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54127100_1564588470.cn/txdocpic/0/f5dac1f816cb249d8295dd6123a1678f/0)



**2、系统核心业务流程分析**



接着我们来明确一下，这样的一个系统，孩子们在上课的时候主要高频使用的是哪些功能呢？



其实非常的简单，现在如果大家家里有孩子，平时对一些在线教育APP有一定了解的话，应该知道现在在线教育APP都会尤为主打的是互动环节。



给大家举个例子，比如说给五六岁的孩子上的幼儿英语课，大家觉得，还会跟20年前一样，给他们放非常枯燥的“李雷和韩梅梅”的情节么？然后机械式的去跟读？



那肯定不是了！现在尤为强调的是在欢快的娱乐游戏中进行教学，让孩子们快乐的学习英语、数学之类学科的知识。



所以说，在那几十万用户晚上高峰时间段使用系统上课的时候，尤为核心的业务流程，就是大量的游戏互动环节



通过游戏互动让孩子们感兴趣，愿意学，而且通过游戏强互动让他们保持注意力，促使他们对学习到的东西进行输出，提升学习的效果，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73054000_1564588470.cn/txdocpic/0/365d93d7573e00e88bee2735b00a79dc/0)



也就是说，这个游戏互动功能，一定会承载用户高频率、大量的互动点击



比如在完成什么任务的时候必须要点击很多的按钮，频繁的进行互动，然后系统后台需要接收大量的互动请求，并且记录下来用户的互动过程和互动结果。



系统得记录下来用户完成了多少个任务，做对了几个，做错了几个，诸如此类的。



**3、系统的运行压力**



现在我们开始来分析一下这个系统运行时候对内存使用产生的一个压力



其实核心点就是搞明白在晚上两三小时高峰期内，每秒钟会有多少请求，每个请求会连带产生多少对象，占用多少内存，每个请求要处理多长时间。



首先我们来分析一下晚上高峰期内几十万用户同时在线使用平台，每秒钟会产生多少请求？



我们可以大致来估算一下，比如说晚上3小时高峰期内有总共60万活跃用户，平均每个用户大概会使用1小时左右来上课，那么每小时大概会有20万活跃用户同时在线学习。



这20万活跃用户因为需要进行大量的互动操作，所以大致可以认为是每分钟进行1次互动操作，一小时内会进行60次互动操作



那么20万用户在1小时内会进行1200万次互动操作，平均到每秒钟大概是3000次左右的互动操作，这是一个很合理的数字。



那么每秒钟要承载3000并发请求，根据经验来看，一般系统的核心服务需要部署5台4核8G的机器来抗住是差不多的，每台机器每秒钟抗个600请求，这个压力可以接受，一般不会导致宕机的问题。



那么每个请求会产生多少个对象呢？



一次互动请求不会有太复杂的对象，他主要是记录一些用户互动过程的，可能会跟一些积分之类的东西有关联



大家如果玩儿过在线教育APP都知道，每次你完成一个活动，一般会给你累加一些对应的“XX币“，“XX宝石”之类的东西。



所有大致估算一下，一次互动请求大致会连带创建几个对象，占据几KB的内存，比如我们就认为是5KB吧那么一秒600请求会占用3MB左右的内存。



**4、本文总结与下文预告**



基于百万用户在线教育平台的G1垃圾回收优化案例，分为上下两文



本文先按照惯例，把**整个系统的****背景、核心业务流程、高峰运行压力、机器部署、每秒请求压力、每秒内存使用压力**，都给分析了出来。



接着下文就会基于这个每秒内存使用压力，结合G1垃圾回收器的运行原理，来给大家分析在这个压力之下，G1垃圾回收机制会如何来运行，这个过程中可能会产生哪些问题，如何对G1的一些参数进行基本的优化来调整垃圾回收的性能。



但是G1本身运行机制极为复杂，所以真的要搞懂他很多优化的细节，必须结合后面**几十个不同的案例**，不同的场景来说明，一个案例也仅仅能把部分优化方式给说清楚而已。

# 033、案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能（下）？

**1、前文回顾**



上篇文章我们针对一个案例背景进行了系统的分析，其实这套系统分析方法论大家如果一路跟着学习到如今，都已经非常的熟练了，可以说这是一个优秀工程师必须具备的JVM压力分析的能力。



作为开发业务系统的工程师，不一定说要深入理解JVM的各种底层原理和源码，因为也没那么多精力去研究那些



但是务必要能够合理的分析自己系统的内存压力，然后合理的优化JVM的参数，尽可能降低JVM GC的频率，同时降低JVM GC导致的系统停顿的时间。



本文我们接着上文的案例继续来分析，在这个案例背景之下来看看，G1垃圾回收器在使用的时候有哪些地方是值得优化的。



**2、G1垃圾回收器的默认内存布局**



接着我们来看看G1垃圾回收器的默认内存布局，之前说过我们采用的是4核8G的机器来部署系统，然后每台机器每秒会有600个请求会占用3MB左右的内存空间。



那么假设我们对机器上的JVM，分配4G给堆内存，其中新生代默认初始占比为5%，最大占比为60%，每个Java线程的栈内存为1MB，元数据区域（永久代）的内存为256M，此时JVM参数如下：



“-Xms4096M -Xmx4096M  -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseG1GC“



“-XX:G1NewSizePercent”参数是用来设置新生代初始占比的，不用设置，维持默认值为5%即可。



“-XX:G1MaxNewSizePercent”参数是用来设置新生代最大占比的，也不用设置，维持默认值为60%即可。



此时堆内存共4G，那么此时会除以2048，计算出每个Region的大小，此时每个Region的大小就是2MB，刚开始新生代就占5%的Region，可以认为新生代就是只有100个Region，有200MB的内存空间，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/55691100_1564643980.cn/txdocpic/0/b4b4067310941d58313bb135bbcb804f/0)



**3、GC停顿时间如何设置？**



在G1垃圾回收器中有一个至关重要的参数会影响到GC的表现，就是“-XX:MaxGCPauseMills”，他的默认值是200毫秒



也就是说咱们希望每次触发一次GC的时候导致的系统停顿时间（也就是“Stop the World”）不要超过200毫秒，避免系统因为GC长时间卡死。



这个参数我们可以先保持一个默认值，继续往下分析看看，不着急忙下结论。



**4、到底多长时间会触发新生代GC？**



有一个问题，就是系统运行起来之后，会不停的在新生代的Eden区域内分配对象，按照之前的推算是每秒分配3MB的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85027600_1564643980.cn/txdocpic/0/578d76745ec7fb0e64a473a27f3f5855/0)



那么之前是说“Eden区域的空间不够了，就触发新生代gc”，但是到底什么时候Eden区域会内存不够呢？



之前说过“-XX:G1MaxNewSizePercent”参数限定了新生代最多就是占用堆内存60%的空间



那么难道必须得随着系统运行一直给新生代分配更多的Region，直到新生代占据了60%的Region之后，无法再分配更多的Region了，再触发新生代gc？



G1肯定不是这么搞的，后续我们会通过几十个案例带着大家来实操体验各种JVM运行场景和通过工具来查看内存占用情况，GC频率和效果，但是现在我们就初步给大家说说G1的运行原理。



我们首先假设一个前提，这个纯碎就是我们人为设定的，就是假设在这个系统里，G1回收掉300个Region（600MB内存），大致需要200ms。



那么很有可能系统运行时，G1呈现出如下的运行效果。



首先，随着系统运行，每秒创建3MB的对象，大概1分钟左右就会塞满100个Region（200MB内存），如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10495800_1564643981.cn/txdocpic/0/9dcbec741f3edacc0be902ddff326e5c/0)

此时很可能G1会觉得，要是我现在就触发一次新生代gc，那么回收区区200MB只需要大概几十ms，最多就让系统停顿几十ms而已，跟我的主人设定的“-XX:MaxGCPauseMills”参数限制的200ms停顿时间相差甚远。



要是我现在就触发新生代gc，那岂不是会导致回收完过后接着1分钟再次让新生代这100个Region塞满，接着又触发新生代gc？



那这样算下来，岂不是每分钟都要执行一次新生代gc？是不是太频繁了？好像没这个必要吧！



所以还不如给新生代先增加一些Region，然后让系统继续运行着在新生代Region中分配对象好了，这样就不用过于频繁的触发新生代gc了，此时如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/30983400_1564643981.cn/txdocpic/0/5eea17c4e805fc8c159b1f0e6da15cda/0)



然后系统继续运行，一直到可能300个Region都占满了，此时通过计算发现回收这300个Region大概需要200ms，那么可能这个时候就会触发一次新生代gc了。



所以大家通过这一小节的分析就明白了，其实G1里是很动态灵活的，他会根据你设定的gc停顿时间给你的新生代不停分配更多Region



然后到一定程度，感觉差不多了，就会触发新生代gc，保证新生代gc的时候导致的系统停顿时间在你预设范围内。



但是大家觉得上述的数字一定精准吗？



**No！**



完全只是示范一下做一个示例，其实这个G1到底会分配多少个Region给新生代，多久触发一次新生代gc，每次耗费多长时间，这些都是不确定的，必须通过一些工具去查看系统实际情况才知道，这个提前是无法预知的。



但是大家需要知道的，就是G1它本身是这样的一个运行原理，他会根据你预设的gc停顿时间，给新生代分配一些Region，然后到一定程度就触发gc，并且把gc时间控制在预设范围内，尽量避免一次性回收过多的Region导致gc停顿时间超出预期。



**5、新生代gc如何优化？**



此时大家就可以思考一下了，那么新生代gc如何优化？



其实，垃圾回收器是一代比一代先进，内部实现机制越来越复杂，但是对我们来说优化的时候越来越简单了。



比如对于G1而言，我们首先应该给整个JVM的堆区域足够的内存，比如我们在这里就给了JVM超过5G的内存，其中堆内存有4G的内存。



接着就应该合理设置“-XX:MaxGCPauseMills”参数



如果这个参数设置的小了，那么说明每次gc停顿时间可能特别短，此时G1一旦发现你对几十个Region占满了就立即触发新生代gc，然后gc频率特别频繁，虽然每次gc时间很短。



比如说30秒触发一次新生代gc，每次就停顿30毫秒。



如果这个参数设置大了呢？



那么可能G1会允许你不停的在新生代理分配新的对象，然后积累了很多对象了，再一次性回收几百个Region



此时可能一次GC停顿时间就会达到几百毫秒，但是GC的频率很低。比如说30分钟才触发一次新生代GC，但是每次停顿500毫秒。



所以这个参数到底如何设置，需要结合后续给大家讲解的系统压测工具、gc日志、内存分析工具结合起来进行考虑，尽量让系统的gc频率别太高，同时每次gc停顿时间也别太长，达到一个理想的合理值。



**6、mixed gc如何优化？**



说完了这个新生代gc之后，那接下来就是mixed gc的优化了



对于这个mixed gc的触发，大家都知道是老年代在堆内存里占比超过45%就会触发。



大家之前都很清楚了年轻代的对象进入老年代的几个条件了，要不然是新生代gc过后存活对象太多没法放入Survivor区域，要不然是对象年龄太大，要不然是动态年龄判定规则。



其中尤其关键的，就是新生代gc过后存活对象过多无法放入Survivor区域，以及动态年龄判定规则



这两个条件尤其可能让很多对象快速进入老年代，一旦老年代频繁达到占用堆内存45%的阈值，那么就会频繁触发mixed gc。



所以mixed gc本身很复杂，很多参数可以优化，但是优化mixed gc的核心不是优化他的参数，而是跟我们之前分析的思路一样，尽量避免对象过快进入老年代，尽量避免频繁触发mixed gc，就可以做到根本上优化mixed gc了。



那么G1里面跟之前的ParNew+CMS的组合是不同的，我们到底应该如何来优化参数呢？



其实核心的点，还是“-XX:MaxGCPauseMills”这个参数。



大家可以想一下，假设你“-XX:MaxGCPauseMills”参数设置的值很大，导致系统运行很久，新生代可能都占用了堆内存的60%了，此时才触发新生代gc。



那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。



或者是你新生代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。



所以这里核心还是在于调节“-XX:MaxGCPauseMills”这个参数的值，在保证他的新生代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少，避免存活对象太多快速进入老年代，频繁触发mixed gc。



至于到底如何优化这个参数，**一切都要结合后续大量工具的讲解和实操演练了**，到这里为止，至少大家对原理性的东西都很了解了。



**7、今日思考题**



到底为止，大家已经基本学明白了G1的运行原理以及基本的优化思路，那么**我想问大家两个问题：**

- G1这种垃圾回收器到底在什么场景下适用呢？
- 有了G1以后，是不是还有一些场景采用“ParNew+CMS”垃圾回收器也可以呢？

# 034、第一阶段复习：当你开发完一个系统准备部署上线时，如何设置JVM参数？

2019-08-03 07:00:00

**第一阶段复习：**

**当你开发完一个系统准备部署上线时，如何设置JVM参数？**

各位同学，不知不觉，我们已经完成了头5周的内容了，对JVM的核心运行原理以及JVM GC的原理都进行了分析



并且，我们还结合了多个案例，给大家讲解了如何在开发好一个系统之后，合理的预估系统压力，合理的设置JVM的各种参数，在系统压测和上线之前，也让JVM参数尽量合理一些

本周作业是阶段性复习作业，**希望大家能够对这5周的内容做一个全面的梳理，自己写一些笔记，把学习到的知识体系都梳理一下**，形式不限，可以画图，也可以做思维导图，总之就是希望大家用自己的方式，对目前为止学习到的内容深度思考和消化总结

学了不练，学了不复习，学了不总结，基本等于白学。希望大家记住这句话。



所以我们的专栏尤为重视每日思考题、每周作业还有阶段性的复习总结，尤其希望大家每个人都自己去做这个事儿，不要什么都希望我们整理好了发给你

记住，自己思考和总结出来的东西，跟我们总结好发给你的东西，效果是完全不同的，一定要自己去做

下周开始将要**全面进入JVM实操环节**，用可以运行的代码模拟出各种场景和故障，然后让大家动手体验如何分析JVM内存，如何分析GC日志，如何动手优化参数得到想要的结果，然后结合几十个案例来进行实操，让大家绝对务必要掌握在实际工作可以玩儿转JVM的优化

# 035、第5周答疑：本周问题答疑，上周作业点评

2019-08-04 09:55:58

第5周答疑：

本周问题答疑，上周作业点评



**问题：**

老师，我刚刚回想了一下，突然懂了。本案例是秒杀系统和高峰时期的案例情况分析。如果是平时的情况下。每秒也就是不足10个订单的请求。



那么每秒在eden区的对象10*1*20*10=2000kb大小，按照新生代区2g大小，可以保证说minor gc频率大概在20分钟左右。



**回答：**

是的，一般其实新生代gc没那么频繁的



**问题：**

我回去分析了一下系统gc情况，整个堆3600m，新生代仅仅给680m，然后平均每隔40分钟一次minor gc，即便深夜也是这样，我估计是一些定期任务在执行。



然后老年代占内存600多m，没有fullgc，好像没什么要调优的了。唯一有点诟病就是新生代给的太少的，才680，是通过xmn指定的。



我觉得起码要给个默认的1200m吧，这一块是否需要调大新生代呢？



我的观点是，调大了也就是降低一点minorgc的频率，好像没有什么太大的收益



**回答：**

对的，你们系统新生代那么小，还要40分钟一次minor gc，原因只有一个，那就是你们系统的访问量很低，负载很低，产生对象的速度很低



这种情况下，也可以给新生代多分配一些内存，其实说白了，一些负载很低的系统，可能jvm本身就没什么好调优的



**问题：**

老师，负责的系统对内存使用压力有多大，意思是每秒有多少个请求，这些请求会生成多大的对象对吗，多少个请求怎么看啊?



**回答：**

你完全可以根据自己写的代码来预估，基本都能估算出来 ，每秒多少请求，每个请求会连带产生多少个对象，每个对象大致多大。后面我们也会讲怎么通过工具来看



**问题：**

感觉还是需要系统复杂度和压力上去才能更多的暴露问题



**回答：**

对的，没复杂度和高负载的系统，一般JVM这块出问题的比较少



**问题：**

老师，是否可以监控到因为survivor区域放不下或者因为动态年龄导致进去老年代的对象大小或者次数甚至是哪些对象？ 如果能够监控到那岂不是更加准确调优参数？



**回答：**

刚开始开发完毕肯定得先按照估算的来进行jvm参数设置，后续在压测、生产 环境可以用工具来精准的检测，这个工具后续会讲



**问题：**

老师，请问一下，minor gc 之前如果老年代剩余空间小于新生代所有对象大小或者小于之前历次 minor gc 后进入老年代对象平均大小，从而会触发老年代 full gc，那么这个老年代的 full gc 使用的垃圾回收器是 CMS 还是 Serial Old？



**回答：**

此时垃圾回收是CMS



**问题：**

文章里说，老年代的回收触发有两种情况，我不理解第二种（在minorGC之后）



按文章说的，根本就不会有这种情况啊，因为在minorgc之前都会检查老年代的大小是否大于新生代的大小。



如果是小于新生代的，都先fullGC了，哪里了还有在minorgc以后的？



还有疑问就是：如果我把老年代的大小设置为小于新生代的，例如新生代设置了100m，而老年代设置了1m，岂不是基本每次minorgc都fullgc？



**回答：**

1、不是，你没看清楚，如果老年代可用空间大于历次minor gc后升入老年代的对象平均大小，也可以进行minor gc，但是此时可能minor gc后的存活对象特别多都要进入老年代，就会触发full gc 



2、不会，你仔细看看，现在最新版本里，只要老年代可用空间大于历次minor gc后升入老年代的对象平均大小，就可以直接进行minor gc，不需要每次都full gc



**问题：**

老师，请问用了G1回收器，是不是我们前面的知识都用不上了？



还有G1这个停顿时间我们应该怎么预估呢？比如我们设置一小时停顿0.5秒，当它明显做不到这个停顿时间的时候，它会怎么样？



**回答：**

不是的，G1里很多原理都是跟之前讲解的一脉相承，都有用，具体看后续的文章



**问题：**

我司的广告系统，使用的就是G1垃圾回收器……因为是一个30G的大堆，传统回收器可能会造成很大的停顿，所以使用了G1



**回答：**

对的，G1非常适合超大内存的机器，因为内存太大，如果不用G1，会导致新生代每次GC回收垃圾太多，停顿时间太长，用了G1可以指定每次GC停顿时间，他会每次回收一部分Region



**问题：**

我现在有点迷糊了：jdk1.8 Minor GC之前是否还比较老年代的可用空间大于新生代存活对象的总大小？如果还比较的话，调大年轻大的大小，调小老年代的大小，那岂不是有问题？



**回答：**

两个条件，“老年代可用空间”> “新生代所有对象大小”，“老年代可用空间”> “新生代历次minor gc后升入老年代的平均对象大小”，满足任意一个即可





**问题：**

新生代和老年代各自的内存区域是不停变动的，新生代变为老年代可以理解，老年代会变为新生代么？



我猜想应该不会，老年代的Region空间全部回收完了，可能从老年代 变成 初始状态（非新非老），然后变成新生代，这样循环轮回。而不会从老年代直接变成新生代吧



**回答：**

会变，G1里一切都可以变，Region都是动态灵活的，一个Region回收掉垃圾空了之后，未来可以分配给新生代，也可以分配给老年代





**问题：**

虽然我们没有用过 G1，但是从 GC 效果上看，G1 最明显的特点就是可以预测 STW 的时间。



而 G1 为了达到这个效果，抛弃传统分代内存，把它们都变成了各个小内存块 region ，针对这些内存块 region 预测垃圾回收的性价比，然后选某些性价比最高最高的内存块 region 进行 GC，以在预先设定的 GC 时间内完成 GC。



猜测可以用到对 STW 特别敏感的业务上。这可能是实时通信之类的，也就是一些追求低延迟的响应的业务。



**回答：**

对的，还有就是那种大内存机器，比如16G，32G的机器部署的系统，不用G1一次回收时间太长了，内存满了对象太多了，用了G1可以控制，每次就回收部分Region即可





**问题：**

按照老师的介绍， G1 是不是也会给年轻代和老年代分配一定的内存比例 虽然region不一直属于年轻代活老年代， 但是也会有类似 eden区放不下的情况 这个时候触发 region gc 然后根据“回收价值”去做回收 这样猜测不知道正不正确？



**回答：**

对的，明天的文章里会分析这些细节





**问题：**

按region回收会不会形成新的内存碎片呀？



**回答：**

不会的，后续会分析，Region回收的时候走复制算法，存活对象挪动到其他Region，然后对一个Region直接回收掉全部垃圾





**问题：**

老师，有个疑问，假设新生代占55%的堆内存，老年代占30%的堆内存，大对象占15%的堆内存，这样的情况会进行垃圾回收吗？



**回答：**

如果新生代已经没法给eden分配更多空间了，那肯定会垃圾回收





**问题：**

老师，有点想不明白，G1分那么多的Region,有点像hdfs里面的小文件，小文件太多会影响性能，但是为什么G1的性能会比之前那些更好呢？



**回答：**

很简单，划分为很多的Region了，回收的时候比如你设定只能停顿系统20ms，那他就挑选比如几十个Region回收，可以控制垃圾回收的停顿时间。



如果按照以前那么简单粗暴的划分，必须回收整个新生代，岂不是每次gc都要停顿更多时间？





**思考题：**从新生代的垃圾回收来看，大家觉得G1垃圾回收器在新生代垃圾回收过程中，相比之前的ParNew而言，最大的进步在哪里？



学员回答：最大进步就是STW可控，但是，虽然各个Region所属区域是动态变化的，但不是随意变化的，还是会为Eden、Survivor、老年代保留各自需要的空间。例如不会让Eden空间的分配超过系统设定的值



**回答：**

是的，这点非常关键，其实G1很适合大内存机器，因为比如你给JVM分配32G内存，要是用ParNew+CMS，每次gc都是内存快满了，此时一下子要回收对象太多了，就会导致gc停顿时间很长，所以针对那种大内存机器，用G1是很合适的





**问题：**

咦，我还是沙发！ 终于追上了进度，每天早上到公司开了电脑，启动了工作要用的所有程序，就开始看书。 哈哈，早上记忆里好，看了顺便做点简单笔记，然后晚上回去复习下笔记，基本就记住了。 就是实操的比较少，才入新公司，还对项目的各种不熟悉。自己的阿里云又没有项目在跑，感觉时机正不好。



**回答：**

非常好，后续会有很多的实操环节的





**问题：**

文末给出的案例非常好，我在上上周已动手调试了我自己的项目 ，就是一个单体的spring boot 在8g内存台式机上跑， 需要加载的类特别多 ，根本没有什么百万流量。



 jvm一启动 直接每秒10m的内存增长速度，光是启动要花十分钟。启动期间就进行了两次full gc，半小时走了十几次ygc 



当时我就调了新老比例为2:1 ，共分配4g， 之后 fgc一直为0， ygc半小时只有两次， 启动降为1分钟以内



**回答：**

是的，这就是典型的新生代内存不足，导致你启动系统创建一堆对象，然后新生代不够，频繁young gc进入很多对象到老年代，然后老年代又不足了，又要对老年代full gc，最后就是十多次young gc+几次full gc，因为gc太多还导致启动速度很慢。



你优化了比例之后，新生代内存充足，很多对象都直接进入新生代，不用进入老年代，最多就是少数young gc回收一部分对象，也不会有full gc。gc次数减少了，那启动速度立马就快了





**问题：**

老师，网上大部分资料设置新生代和老年代都有一个比率(1:2)，这个比率是正确的吗？并且和你说的不一样，新生代一般小于老年代。都不知道以那个为准了。



**回答：**

不对，那都是错误引导，完全没从根上来说明怎么优化jvm参数，可以跟着我们的文章来学，是最科学的设置方法





**问题：**

我觉得G1垃圾回收也应该合理分配年轻代的占比 ，保证 supervisor区放得下 或者 动态年龄不会那么快进入老年代 ，让老年代很快占到百分之45。 



如果老年代不那么快占到百分之45自然就可以减少 混合回收



**回答：**

分析的非常的好



**问题：**

\1. G1回收器的4个阶段是只针对混合回收的吗？那么新生代的回收过程又是如何的？ 假如老年代总量没有达到45%,是不是不会进行混合回收，只会进行新生代的回收，顺带回收大对象Region 



\2. G1混合回收、第四个阶段会进行多次混合回收，那么这个多次混合回收的间隔是如何定义的？ 



\3. 空闲的Region数量达到堆内存的就会停止回收，也就是说正常是8次混合回收，但是可能到了4次，发现空闲Region达到5%了，就不进行后续的混合回收 



\4. 回收失败时Full GC，应该是采用Serial Old回收器吧。



**回答：**

1、新生代垃圾回收策略也说了，基本和之前一致 



2、间隔由g1自己控制 



3、对的 



4、是的，直接就是serial old





**学员思考题回答：**使用G1垃圾回收的时候，值得优化的地方： 

对于新生代，和之前的理论差不多，主要目标是避免短期存活的对象进入老年代。 



\1. 预估系统每次GC后存活对象，确保Survivor能放得下。 



\2. 避免高峰期间，新生代对象满足动态年龄判断条件，导致短期存活对象进入老年代。 



\3. 大对象有大对象Region，不占用老年代空间，基本不用考虑。 



对于老年代； 



\1. 对于可预测停顿时间，需要合理设置，并不是越小越好，如果过小，有可能多次回收效果不大，最终导致回收失败FullGC，停顿系统线程。 



\2. G1HeapWastePercent 这个参数，我觉得应该可以适当提高，避免万一真的遇到了高峰期，短期存活对象进入老年代，但是回收的时候，进行了几次混合回收的时候， 刚好达到了5%,但是在老年代Region中可能还是存在某些短期存活对象没有被回收。过早结束混合回收。 



\3. -XX:G1MixedGCLiveThresholdPercent这个参数，暂时不用管，降低这个参数可能会让Region的回收效率更高， 但是也可能导致短期存活对象驻留内存时间过长，进入老年代的风险。



**回答：**

分析的很好





**问题：**

这篇有个疑问，JVM能保证无论如何都有一个Survivor区是空着的吗？



会不会存在这一个情况，第一次在Survivor1区有存活对象，然后第二次GC的时候，又放到了Survivor2区(同时s1也有对象)，第三次GC的时候，s1和s2都有存活对象，这样就不能保证无论如何都有一个Survivor区存在的情况。



**回答：**

不会的，一次gc，会把eden和s1里的存活对象都转移到s2，然后清空eden和s1





**学员思考题回答：**

**1. 如果使用G1垃圾回收的时候，应该值得优化的是什么地方？** 



感觉jvm优化的主旋律就是，尽量让短命对象在新生代回收掉，长期存活对象早进入老年代，G1的优化思路亦是如此。 



首先是根据具体业务系统，合理分配老年代和新生代的大小、新生代Eden和Survivor区大小 其次是根据具体业务系统，合理设置G1的MaxGCPauseMills大小。



太小容易造成回收频繁，影响系统的吞吐量。太大会增大系统的停顿时间，影响用户体验 



**2. 什么时候可能会导致G1频繁的触发Mixed混合垃圾回收？** 



1、InitiatingHeapOccupancyPercent设置的值太小 



2、新生代和老年代空间设置不合理，导致进入老年代对象太多，频繁达到MixedGC的条件 上面两个原因导致频繁的MixedGC 



**3. 如何尽量减少Mixed GC的频率？** 



首先看触发MixedGC的条件是什么，触发MixedGC条件是到老年代达InitiatingHeapOccupancyPercent设置的值，这就会回到如何让老年代尽量不达到这个值的问题。 



1、让垃圾对象尽量在新生代就被回收掉，尽量让短命对象不进老年代。这就要求根据具体应用系统来合理设置新生代Eden大小和Survivor的大小。 



2、将老年代设置为较小的值或者提高InitiatingHeapOccupancyPercent的值，这样就可以使达到触发MixedGC概率降低。但这样可能会存在一些问题： 



（1）设置老年代为较小的值存在的问题：如果有较多的需要长期存活的对象的情况下，容易FullFC或直接OOM了. 



（2）提高InitiatingHeapOccupancyPercent存在的问题：虽然降低了MixedGC的频率，但导致老年代存在过多的对象，增加了每次老年代回收时‘并发标记’阶段的计算负担和‘MixedGC’阶段计算和预估的负担。不适合CPU负载较高的计算型业务的系统



**回答：非常好的分析解答**





**问题：**

坚持，加油，老师讲得很好!我小白同时跟这门和石杉老师的课，有点困难，时间消耗比较多，坚持加油!



**回答：**

一定要坚持，学习技术就是这样的，长期跟着坚持下来，收获就会很大





**问题：**

一如既往的分析流程，总结一下：分析系统的背景和核心业务流程，预估高峰时长及当时的活跃用户，预估产生多少请求及每个请求处理时长，预估需要部署多少台机器及每台机器每秒抗多少请求，预估一个对象的内存大小及每秒产生对象总大小，然后对JVM参数进行调优。老师看是否有遗漏的？



**回答：**

相当好，这套理论掌握好了，以后才能从根上玩儿转jvm优化



**问题：**

我自己先分析了一下，按照老师的思路接着往下走：



比如每台机器堆内存5G，新生代最多占堆内存的60%，即3000MB左右，1秒3MB对象，60秒180MB对象



Eden区域和survivor是默认的8:1:1比例来计算，Eden大概有2400M，要占满需要大概14分钟就得去回收一次



每个survivor区有300MB内存，每次回收大概有180MB对象会卡在内存中，因为1分钟请求一次，一分钟用户才点击一次按钮，所以一次请求大概得一分钟才能处理完（我是这么想的你比如讲个故事大概讲50多秒，快60秒的时候点一下按钮）



所以大概有200MB左右的垃圾不会被回收进入了survivor区，此时超过了survivor的50%了，会进入老年代



也就是每隔14分钟就会有200MB的垃圾进入老年代，快一个小时的时候有800MB会进入老年代，老年代达到45%会进行混合垃圾回收，那么大概1个小时零10分时候就进行一次混合回收，我觉的如果是这样的话应该还可以，系统性能不会太差



因为我这里还没有考虑G1在规定的时间内尽可能的去回收更多的垃圾，每次回收还要分8次，在这8次中的空隙还让用户线程去工作，性能应该不会差。看着今天的文章，心痒痒了，自己大概练了一下，不知道对不对，抛砖引玉吧。



**回答：**分析的非常好





**问题：**

刚看完，简单记录一下笔记。调优思路还是减少耗时的垃圾回收，也就是避免对象进入老年代。



传统的垃圾收集器是通过调整s区和e区的大小来控制，而G1则比较先进，直接指定一个期望的停顿时间，选择停顿时间的标准是既不能频繁触发minor gc，也不能一次回收过多的对象，所以还得通过工具来调试出一个最适合自己系统的停顿时间。



通过工具检测，要得出一个停顿多久可以回收多少的内存大小的指标。根据这个指标和业务系统生成垃圾的速率设置合理的停顿时间。之后等作业里面再整理一个详细的。



**回答：**是的，分析的很好，都吸收了





**问题：**

老师的意思 G1就是调最大停顿时间 过大新生代 存活对象太多 可能新生代gc过后 存活对象太多 supervisor放不下 进入老年代 或者 因为动态年龄进入老年代 其实mix gc也是新生代的最大停顿时间设置的不合理



**回答：**

是的，其实核心的调优没那么复杂，关键是明白背后的原理，调节几个关键参数即可，不是说优化jvm就一定要优化一大堆的参数





**学员思考题回答：**



到底为止，大家已经基本学明白了G1的运行原理以及基本的优化思路，那么我想问大家两个问题：

- G1这种垃圾回收器到底在什么场景下适用呢？
- 有了G1以后，是不是还有一些场景采用“ParNew+CMS”垃圾回收器也可以呢？



1、G1压缩内存空间会比较有优势，适合会产生大量碎片的应用； 



2、G1能够可预期的GC停顿时间，对高并发应用更有优势 



3、其他垃圾收集器对大内存回收耗时较长，G1对内存分成多块区域，能够根据预期停顿时间选择性的对垃圾多的区域进行回收，适用多核、jvm内存占用大的应用 



4、parNew+cms回收器比较适用内存小，对象能够在新生代中存活周期短的应用



**回答：**分析很好





**学员思考题回答：**

到底为止，大家已经基本学明白了G1的运行原理以及基本的优化思路，那么我想问大家两个问题：

- G1这种垃圾回收器到底在什么场景下适用呢？
- 有了G1以后，是不是还有一些场景采用“ParNew+CMS”垃圾回收器也可以呢？



g1适合 大堆的场景 或者有业务不能有太高的延时 如果业务上不需要特别大的堆 或者 业务属于不需要及时反馈用户的 比如贷款业务 申请额度之后就后台处理了 有额度以后 在通知你这个时候 par new 加 cms可以用的



**回答：**分析的非常到位





**问题：**

请问老师我的理解对么：使用系统的用户其实并不关心什么gc频率，但他们关心的是我使用的系统卡不卡，处理速度快不快。系统卡不卡是受-XX:MaxGCPauseMills影响的。系统处理速度快不快是受gc的频率影响的。



“gc的频率高”翻译一下应该是“系统的吞吐量低”，gc频率高说明cpu用来处理垃圾回收的时间比例变多了，自然用来处理业务的cpu时间变少了。比如原先每秒可以取出1w条数据，现在只能取出2k条。



**回答：**理解正确

036、糟糕！运行着的线上系统突然卡死无法访问，万恶的JVM GC！

**1、前文回顾**



之前我们通过5周的内容分析了JVM的核心运行原理，还有JVM GC的工作原理



同时结合案例给大家分析了JVM什么情况下会出现GC的问题，平时我们说优化JVM，到底是在说优化JVM的什么东西，相信这些内容，大家都已经理解并且掌握了。



因为每周我们都会布置一个作业，是希望大家对所学内容进行深度思考和总结，同时通过写笔记、画图的方式，最大限度把学到的东西消化掉变成自己的东西。所以希望大家一定要认认真真的去完成作业。



第六周的内容是对JVM GC相关的内容做一个总结，梳理出来一些名词的清晰的含义，做一个承上启下的作用，引出后面几周的JVM纯实战内容。



从第七周开始，就会对JVM优化进行实操，带着大家动手去模拟出来各种生产故障，然后通过各种工具以及JVM GC日志，去学习如何排查、定位和解决JVM的性能问题。



**2、****基于JVM运行的系统最怕什么？**



我们先来梳理一下，平时我们基于Java写出来的系统在部署的时候，基于JVM把系统跑起来之后，这样一个系统最怕的是什么？



通过之前的学习相信大家现在都能理解一个点，就是在JVM运行的时候，最核心的内存区域，其实就是堆内存，在这里会放各种我们系统中创建出来的对象。



而且堆内存里通常都会划分为新生代和老年代两个内存区域，对象一般来说都是优先放在新生代的，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89051300_1564922273.cn/txdocpic/0/f8d45dd0a6d0d1e4ce85461af3f5e60a/0)

接着随着系统不停的运行，一定会导致越来越多的对象放入年轻代中，然后年轻代都快塞满了，放不下更多的对象了，毕竟内存都是有限的。



这个时候你就必须清理一下年轻代的垃圾对象，也就是那些没有GC Roots引用的对象。



大家都知道，所谓的GC Roots就是类的静态变量，方法的局部变量。平时我们最经常创建对象的地方，就是在方法里，但是一旦一个方法运行完毕之后，方法的局部变量就没了，此时之前在方法里创建出来的对象就是垃圾了，没人引用了。



所以在咱们的年轻代里，其实99%都是这种没人引用的垃圾对象。



在年轻代（也可以叫做新生代）快要塞满的时候，就会触发年轻代gc，也就是对年轻代进行垃圾回收，需要把年轻代里的垃圾对象都给回收掉。



那么到底怎么回收呢？



其实我们通过之前的学习，都很清楚，会通过复制算法进行回收，通常来说新生代会有一块Eden区域用来创建对象，默认占据80%的内存，还有两块Survivor区域用来放垃圾回收后存活下来的对象，分别占据10%的内存，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3929900_1564922274.cn/txdocpic/0/5dd4f2b982cf8cd4dff5ec8237e845cb/0)



而且大家要注意一点，一旦要对新生代进行垃圾回收了，此时一定会停止系统程序的运行，不让系统程序执行任何代码逻辑了，这个叫做“Stop the World”



此时只能允许后台的垃圾回收器的多个垃圾回收线程去工作，执行垃圾回收，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/14257400_1564922274.cn/txdocpic/0/3b0c0c777308f3e02bf365bd8f692d64/0)



所谓的复制算法，说白了，就是对所有的GC Roots进行追踪，去标记出来所有被GC Roots直接或者间接引用的对象，他们就是存活对象



比如上图中大家可以看到有一个类的静态变量就引用了一个对象，那个对象就是存活对象。



接着就会把存活对象都转移到一块Survivor区域里去，如上图，就把存活的对象转移到一块Survivor区域里去了。



接着就会直接把Eden区里的剩下的垃圾对象全部回收掉，释放内存空间，然后恢复系统程序的运行，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/30074000_1564922274.cn/txdocpic/0/70552ff4458798c1f448821b8219f32e/0)



看到这里，要给大家说第一个重点了，不知道大家发现了没有，这里有一个很大的问题，就是每次一旦年轻代塞满之后，在进行垃圾回收的时候，这个期间都必须停止系统程序的运行！



这个就是基于JVM运行的系统最害怕的问题：**系统卡顿问题！**



假设一次年轻代垃圾回收需要20ms，那么就意味着在这20ms内，系统是无法工作的，此时用户对系统发送的请求，在这20ms内是无法处理的，需要卡住20ms，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40450800_1564922274.cn/txdocpic/0/7a5c6af86635a507fe1b41d6f6940727/0)



**3、年轻代gc到底多久一次对系统影响不大？**



那么现在有一个问题，年轻代gc对系统的性能影响到底大不大？



其实通常来说是不大的，不知道大家发现没有，其实年轻代gc几乎没什么好调优的，因为他的运行逻辑非常简单，就是Eden一旦满了无法放新对象就触发一次gc。



一般来说，真要说对年轻代的gc进行调优，只要你给系统分配足够的内存即可，核心点还是在于堆内存的分配、新生代内存的分配



内存足够的话，通常来说系统可能在低峰时期在几个小时才有一次新生代gc，高峰期最多也就几分钟一次新生代gc。



而且一般的业务系统都是部署在2核4G或者4核8G的机器上，此时分配给堆的内存不会超过3G，给新生代中的Eden区的内存也就1G左右。



而且新生代采用的复制算法效率极高，因为新生代里存活的对象很少，只要迅速标记出这少量存活对象，移动到Survivor区，然后回收掉其他全部垃圾对象即可，速度很快。



很多时候，一次新生代gc可能也就耗费几毫秒，几十毫秒。大家设想一下，假如说你的系统运行着，然后每隔几分钟或者几十分钟执行一次新生代gc，系统卡顿几十毫秒，就这期间的请求会卡顿几十毫秒，几乎用户都是无感知的，所以新生代gc一般基本对系统性能影响不大。



**4、什么时候新生代gc对系统影响很大？**



那么什么时候新生代gc对系统影响会很大呢？



简单，当你的系统部署在大内存机器上的时候，比如说你的机器是32核64G的机器，此时你分配给系统的内存有几十个G，新生代的Eden区可能30G~40G的内存。



比如类似Kafka、Elasticsearch之类的大数据相关的系统，都是部署在大内存的机器上的，此时如果你的系统负载非常的高，对于大数据系统是很有可能的，比如每秒几万的访问请求到Kafka、Elasticsearch上去。



那么可能导致你Eden区的几十G内存频繁塞满要触发垃圾回收，假设1分钟会塞满一次。



然后每次垃圾回收要停顿掉Kafka、Elasticsearch的运行，然后执行垃圾回收大概需要几秒钟，此时你发现，可能每过一分钟，你的系统就要卡顿几秒钟，有的请求一旦卡死几秒钟就会超时报错，此时可能会导致你的系统频繁出错。



**5、如何解决大内存机器的新生代GC过慢的问题？**



那么如何解决这种几十G的大内存机器的新生代GC过慢的问题呢？



**用G1垃圾回收器**



大家都知道，我们针对G1垃圾回收器，可以设置一个期望的每次GC的停顿时间，比如我们可以设置一个20ms。



那么G1基于他的Region内存划分原理，就可以在运行一段时间之后，比如就针对2G内存的Region进行垃圾回收，此时就仅仅停顿20ms，然后回收掉2G的内存空间，腾出来了部分内存，接着还可以继续让系统运行。



G1天生就适合这种大内存机器的JVM运行，可以完美解决大内存垃圾回收时间过长的问题。



**6、要命的频繁老年代gc问题**



综上所述，其实新生代gc一般问题不会太大，但是真正问题最大的地方，在于频繁触发老年代的GC。



之前给大家讲过对象进入老年代的几个条件：年龄太大了、动态年龄判断规则、新生代gc后存活对象太多无法放入Survivor中。



给大家重新分析一下这几个条件。



**第一个**，对象年龄太大了，这种对象一般很少，都是系统中确实需要长期存在的核心组件，他们一般不需要被回收掉，所以在新生代熬过默认15次垃圾回收之后就会进入老年代。



**第二个**，动态年龄判定规则，如果一次新生代gc过后，发现Survivor区域中的几个年龄的对象加起来超过了Survivor区域的50%，比如说年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区域的50%，此时就会把年龄3以上的对象都放入老年代。



**第三个**，新生代垃圾回收过后，存活对象太多了，无法放入 Surviovr中，此时直接进入老年代。



其实上述条件中，第二个和第三个都是很关键的，通常如果你的新生代中的Survivor区域内存过小，就会导致上述第二个和第三个条件频繁发生，然后导致大量对象快速进入老年代，进而频繁触发老年代的gc，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53950800_1564922274.cn/txdocpic/0/d43a5d9437838a816ef8db766f81ee1a/0)



老年代gc通常来说都很耗费时间，无论是CMS垃圾回收器还是G1垃圾回收器，因为比如说CMS就要经历初始标记、并发标记、重新标记、并发清理、碎片整理几个环节，过程非常的复杂，G1同样也是如此。



通常来说，老年代gc至少比新生代gc慢10倍以上，比如新生代gc每次耗费200ms，其实对用户影响不大，但是老年代每次gc耗费2s，那可能就会导致老年代gc的时候用户发现页面上卡顿2s，影响就很大了。



所以一旦你因为jvm内存分配不合理，导致频繁进行老年代gc，比如说几分钟就有一次老年代gc，每次gc系统都停顿几秒钟，那简直对你的系统就是致命的打击。此时用户会发现页面上或者APP上经常性的出现点击按钮之后卡顿几秒钟。



**如果你把系统做成这个样子，那么相信我，你的老板一定会对你很生气的！**



**7、JVM性能优化到底在优化什么？**



所以这篇文章一个承上启下的结论就出现了，其实说白了，系统真正最大的问题，就是因为内存分配、参数设置不合理，导致你的对象频繁的进入老年代，然后频繁触发老年代gc，导致系统频繁的每隔几分钟就要卡死几秒钟。



这就是所谓JVM的性能问题，也是所谓的JVM性能优化到底在优化什么东西！希望大家务必记住这个结论，在脑子里梳理清楚这个思路。



**End**



# 036、糟糕！运行着的线上系统突然卡死无法访问，万恶的JVM GC！

**1、前文回顾**



之前我们通过5周的内容分析了JVM的核心运行原理，还有JVM GC的工作原理



同时结合案例给大家分析了JVM什么情况下会出现GC的问题，平时我们说优化JVM，到底是在说优化JVM的什么东西，相信这些内容，大家都已经理解并且掌握了。



因为每周我们都会布置一个作业，是希望大家对所学内容进行深度思考和总结，同时通过写笔记、画图的方式，最大限度把学到的东西消化掉变成自己的东西。所以希望大家一定要认认真真的去完成作业。



第六周的内容是对JVM GC相关的内容做一个总结，梳理出来一些名词的清晰的含义，做一个承上启下的作用，引出后面几周的JVM纯实战内容。



从第七周开始，就会对JVM优化进行实操，带着大家动手去模拟出来各种生产故障，然后通过各种工具以及JVM GC日志，去学习如何排查、定位和解决JVM的性能问题。



**2、****基于JVM运行的系统最怕什么？**



我们先来梳理一下，平时我们基于Java写出来的系统在部署的时候，基于JVM把系统跑起来之后，这样一个系统最怕的是什么？



通过之前的学习相信大家现在都能理解一个点，就是在JVM运行的时候，最核心的内存区域，其实就是堆内存，在这里会放各种我们系统中创建出来的对象。



而且堆内存里通常都会划分为新生代和老年代两个内存区域，对象一般来说都是优先放在新生代的，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89051300_1564922273.cn/txdocpic/0/f8d45dd0a6d0d1e4ce85461af3f5e60a/0)

接着随着系统不停的运行，一定会导致越来越多的对象放入年轻代中，然后年轻代都快塞满了，放不下更多的对象了，毕竟内存都是有限的。



这个时候你就必须清理一下年轻代的垃圾对象，也就是那些没有GC Roots引用的对象。



大家都知道，所谓的GC Roots就是类的静态变量，方法的局部变量。平时我们最经常创建对象的地方，就是在方法里，但是一旦一个方法运行完毕之后，方法的局部变量就没了，此时之前在方法里创建出来的对象就是垃圾了，没人引用了。



所以在咱们的年轻代里，其实99%都是这种没人引用的垃圾对象。



在年轻代（也可以叫做新生代）快要塞满的时候，就会触发年轻代gc，也就是对年轻代进行垃圾回收，需要把年轻代里的垃圾对象都给回收掉。



那么到底怎么回收呢？



其实我们通过之前的学习，都很清楚，会通过复制算法进行回收，通常来说新生代会有一块Eden区域用来创建对象，默认占据80%的内存，还有两块Survivor区域用来放垃圾回收后存活下来的对象，分别占据10%的内存，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3929900_1564922274.cn/txdocpic/0/5dd4f2b982cf8cd4dff5ec8237e845cb/0)



而且大家要注意一点，一旦要对新生代进行垃圾回收了，此时一定会停止系统程序的运行，不让系统程序执行任何代码逻辑了，这个叫做“Stop the World”



此时只能允许后台的垃圾回收器的多个垃圾回收线程去工作，执行垃圾回收，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/14257400_1564922274.cn/txdocpic/0/3b0c0c777308f3e02bf365bd8f692d64/0)



所谓的复制算法，说白了，就是对所有的GC Roots进行追踪，去标记出来所有被GC Roots直接或者间接引用的对象，他们就是存活对象



比如上图中大家可以看到有一个类的静态变量就引用了一个对象，那个对象就是存活对象。



接着就会把存活对象都转移到一块Survivor区域里去，如上图，就把存活的对象转移到一块Survivor区域里去了。



接着就会直接把Eden区里的剩下的垃圾对象全部回收掉，释放内存空间，然后恢复系统程序的运行，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/30074000_1564922274.cn/txdocpic/0/70552ff4458798c1f448821b8219f32e/0)



看到这里，要给大家说第一个重点了，不知道大家发现了没有，这里有一个很大的问题，就是每次一旦年轻代塞满之后，在进行垃圾回收的时候，这个期间都必须停止系统程序的运行！



这个就是基于JVM运行的系统最害怕的问题：**系统卡顿问题！**



假设一次年轻代垃圾回收需要20ms，那么就意味着在这20ms内，系统是无法工作的，此时用户对系统发送的请求，在这20ms内是无法处理的，需要卡住20ms，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40450800_1564922274.cn/txdocpic/0/7a5c6af86635a507fe1b41d6f6940727/0)



**3、年轻代gc到底多久一次对系统影响不大？**



那么现在有一个问题，年轻代gc对系统的性能影响到底大不大？



其实通常来说是不大的，不知道大家发现没有，其实年轻代gc几乎没什么好调优的，因为他的运行逻辑非常简单，就是Eden一旦满了无法放新对象就触发一次gc。



一般来说，真要说对年轻代的gc进行调优，只要你给系统分配足够的内存即可，核心点还是在于堆内存的分配、新生代内存的分配



内存足够的话，通常来说系统可能在低峰时期在几个小时才有一次新生代gc，高峰期最多也就几分钟一次新生代gc。



而且一般的业务系统都是部署在2核4G或者4核8G的机器上，此时分配给堆的内存不会超过3G，给新生代中的Eden区的内存也就1G左右。



而且新生代采用的复制算法效率极高，因为新生代里存活的对象很少，只要迅速标记出这少量存活对象，移动到Survivor区，然后回收掉其他全部垃圾对象即可，速度很快。



很多时候，一次新生代gc可能也就耗费几毫秒，几十毫秒。大家设想一下，假如说你的系统运行着，然后每隔几分钟或者几十分钟执行一次新生代gc，系统卡顿几十毫秒，就这期间的请求会卡顿几十毫秒，几乎用户都是无感知的，所以新生代gc一般基本对系统性能影响不大。



**4、什么时候新生代gc对系统影响很大？**



那么什么时候新生代gc对系统影响会很大呢？



简单，当你的系统部署在大内存机器上的时候，比如说你的机器是32核64G的机器，此时你分配给系统的内存有几十个G，新生代的Eden区可能30G~40G的内存。



比如类似Kafka、Elasticsearch之类的大数据相关的系统，都是部署在大内存的机器上的，此时如果你的系统负载非常的高，对于大数据系统是很有可能的，比如每秒几万的访问请求到Kafka、Elasticsearch上去。



那么可能导致你Eden区的几十G内存频繁塞满要触发垃圾回收，假设1分钟会塞满一次。



然后每次垃圾回收要停顿掉Kafka、Elasticsearch的运行，然后执行垃圾回收大概需要几秒钟，此时你发现，可能每过一分钟，你的系统就要卡顿几秒钟，有的请求一旦卡死几秒钟就会超时报错，此时可能会导致你的系统频繁出错。



**5、如何解决大内存机器的新生代GC过慢的问题？**



那么如何解决这种几十G的大内存机器的新生代GC过慢的问题呢？



**用G1垃圾回收器**



大家都知道，我们针对G1垃圾回收器，可以设置一个期望的每次GC的停顿时间，比如我们可以设置一个20ms。



那么G1基于他的Region内存划分原理，就可以在运行一段时间之后，比如就针对2G内存的Region进行垃圾回收，此时就仅仅停顿20ms，然后回收掉2G的内存空间，腾出来了部分内存，接着还可以继续让系统运行。



G1天生就适合这种大内存机器的JVM运行，可以完美解决大内存垃圾回收时间过长的问题。



**6、要命的频繁老年代gc问题**



综上所述，其实新生代gc一般问题不会太大，但是真正问题最大的地方，在于频繁触发老年代的GC。



之前给大家讲过对象进入老年代的几个条件：年龄太大了、动态年龄判断规则、新生代gc后存活对象太多无法放入Survivor中。



给大家重新分析一下这几个条件。



**第一个**，对象年龄太大了，这种对象一般很少，都是系统中确实需要长期存在的核心组件，他们一般不需要被回收掉，所以在新生代熬过默认15次垃圾回收之后就会进入老年代。



**第二个**，动态年龄判定规则，如果一次新生代gc过后，发现Survivor区域中的几个年龄的对象加起来超过了Survivor区域的50%，比如说年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区域的50%，此时就会把年龄3以上的对象都放入老年代。



**第三个**，新生代垃圾回收过后，存活对象太多了，无法放入 Surviovr中，此时直接进入老年代。



其实上述条件中，第二个和第三个都是很关键的，通常如果你的新生代中的Survivor区域内存过小，就会导致上述第二个和第三个条件频繁发生，然后导致大量对象快速进入老年代，进而频繁触发老年代的gc，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53950800_1564922274.cn/txdocpic/0/d43a5d9437838a816ef8db766f81ee1a/0)



老年代gc通常来说都很耗费时间，无论是CMS垃圾回收器还是G1垃圾回收器，因为比如说CMS就要经历初始标记、并发标记、重新标记、并发清理、碎片整理几个环节，过程非常的复杂，G1同样也是如此。



通常来说，老年代gc至少比新生代gc慢10倍以上，比如新生代gc每次耗费200ms，其实对用户影响不大，但是老年代每次gc耗费2s，那可能就会导致老年代gc的时候用户发现页面上卡顿2s，影响就很大了。



所以一旦你因为jvm内存分配不合理，导致频繁进行老年代gc，比如说几分钟就有一次老年代gc，每次gc系统都停顿几秒钟，那简直对你的系统就是致命的打击。此时用户会发现页面上或者APP上经常性的出现点击按钮之后卡顿几秒钟。



**如果你把系统做成这个样子，那么相信我，你的老板一定会对你很生气的！**



**7、JVM性能优化到底在优化什么？**



所以这篇文章一个承上启下的结论就出现了，其实说白了，系统真正最大的问题，就是因为内存分配、参数设置不合理，导致你的对象频繁的进入老年代，然后频繁触发老年代gc，导致系统频繁的每隔几分钟就要卡死几秒钟。



这就是所谓JVM的性能问题，也是所谓的JVM性能优化到底在优化什么东西！希望大家务必记住这个结论，在脑子里梳理清楚这个思路。



#   037、大厂面试题：解释一下什么是Young GC和Full GC？

这篇文章篇幅不长，主要是给大家屡清楚几个概念。



不知道大家注意到没有，在之前我们的文章中出现了很多名词：Minor GC、Young GC、Full GC、Old GC、Major GC、Mixed GC。



之前在评论区中也有朋友提出过疑问，说感觉对这些概念有很多都混淆掉了，不知道到底是怎么回事，到底各种乱七八糟的GC指的是什么？



今天正好借着这一周承上启下的机会，我们稍微停一停脚步，把这些各种各样的GC名词的含义给捋一捋。



其实说实话，这些名词在业内也并没有完全标准而且统一的定义，甚至在不同的书里，不同的文章里，对同一个名词的定义都是不一样的。所以我们也是尽量给大家把这些名词的含义区分开来。



此外在面试中，这些名词也会经常被问到，面试官很有可能会考一下你对这些名词的理解



但是有可能会出现你的理解和面试官的理解是不同的，所以大家切记切记，在面试的时候回答此类问题，一定要对一个名词可能有的多种不同的理解都给出说明，避免双方理解的歧义。



**（1）Minor GC / Young GC**



首先我们先来看最简单的名词，Minor GC / Young GC，这个非常好理解，大家都知道，“新生代”也可以称之为“年轻代”，这两个名词是等价的。那么在年轻代中的Eden内存区域被占满之后，实际上就需要触发年轻代的gc，或者是新生代的gc。



此时这个新生代gc，其实就是所谓的“Minor GC”，也可以称之为“Young GC”，这两个名词，相信大家就理解了，说白了，就专门针对新生代的gc。



**（2）Full GC？Old GC？傻傻分不清楚**



之前给大家分析的时候，一直是说老年代一旦被占满之后，就会触发老年代的gc，之前称呼这种GC为Full GC。



所以之前就有同学提出异议了，有人觉得老年代的gc怎么能叫做Full GC呢？他并不是这个含义啊



其实所谓的老年代gc，称之为“Old GC”更加合适一些，因为从字面意义上就可以理解，这就是所谓的老年代gc。



但是在这里之所以我们把老年代GC称之为Full GC，其实也是可以的，只不过是一个字面意思的多种不同的说法。



为了更加精准的表述这个老年代gc的含义，我们从现在开始，一律把老年代gc称之为Old GC，后续也如此定义。



所以在这里，大家务必捋清这个概念，在跟面试官聊的时候，如果说到所谓的老年代gc，为了避免歧义，建议大家用Old GC来指代。



**（3）Full GC**



对于Full GC，其实这里有一个更加合适的说法，就是说Full GC指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为Full GC。



从字面意思上也可以理解，“Full”就是整体的意思，所以就是对JVM进行一次整体的垃圾回收，把各个内存区域的垃圾都回收掉。



但是说实话，不同的名词如何定义每个人都有自己的看法，有些人，包括我自己，平时有一定的习惯是把Full GC直接等价为Old GC的，也就是仅仅针对老年代的垃圾回收。



但是如果从字面意义上来理解，建议大家日后在外面跟别人交谈的时候，把Full GC理解为针对JVM内所有内存区域的一次整体垃圾回收。



**（4）Major GC**



还有一个名词是所谓的Major GC，这个其实一般用的比较少，他也是一个非常容易混淆的概念



有些人把Major GC跟Old GC等价起来，认为他就是针对老年代的GC，也有人把Major GC和Full GC等价起来，认为他是针对JVM全体内存区域的GC。



所以针对这个容易混淆的概念，建议大家以后少提。如果听到有人说这个Major GC的概念，大家可以问清楚，他到底是想说Old GC呢？还是Full GC呢？



**（5）Mixed GC**



Mixed GC是G1中特有的概念，其实说白了，主要就是说在G1中，一旦老年代占据堆内存的45%了，就要触发Mixed GC，此时对年轻代和老年代都会进行回收。这个概念很好理解，大家只要知道是G1中特有的名词即可。



# 038、大厂面试题：Young GC和Full GC分别在什么情况下会发生？

**1、前文回顾**



本文篇幅同样不长，其实是上篇文章的一个续篇，本周主要就是承上启下，把一些核心的概念和名词梳理清楚



上文就给大家梳理清楚了Young GC、Old GC、Full GC几个概念，大家现在已经知道，如果用一个非常清晰的方法来限定各个名词的含义的话，可以认为Young GC就是年轻代的gc，Old GC就是老年代的gc，Full GC是针对年轻代、老年代、永久代进行的整体的GC。



而且还有几个其他的名词跟他们有重叠的含义，比如Minor GC也可以称之为Young GC，Major GC也可以称之为Old GC，有的人也把Major GC和Full GC划等号，也有人把Full GC和Old GC划等号，其实这些概念在国内混淆还是很严重的。



所以以后大家在外面跟人聊起各种GC名词的时候，一定要问清楚他指代的到底是什么！



对于我们而言，之前我是简单的用Minor GC指代年轻代gc，用Full GC指代老年代gc。



但是接下来开始我们既然已经理清了各种概念，那么我们就**统一用Young GC指代年轻代gc，用Old GC指代老年代GC，用Full GC指代年轻代、老年代、永久代共同的gc**。



**2、Young GC的触发时机**



其实之前几周的文章里，我们已经分析的很清楚了，Young GC其实一般就是在新生代的Eden区域满了之后就会触发，采用复制算法来回收新生代的垃圾



所以Young GC的触发时机，我觉得所有跟到现在的同学，闭着眼睛都能说出来了。



**3、Old GC和Full GC的触发时机**



其实之前的文章里也对Old GC的触发时机说的很清晰了，简而言之就是下面几种情况：



（1）发生Young GC之前进行检查，如果“老年代可用的连续内存空间” < “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间



此时必须先触发一次Old GC给老年代腾出更多的空间，然后再执行Young GC



（2）执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Old GC



（3）老年代内存使用率超过了92%，也要直接触发Old GC，当然这个比例是可以通过参数调整的



其实说白了，上述三个条件你**概括成一句话**，就是老年代空间也不够了，没法放入更多对象了，这个时候务必执行Old GC对老年代进行垃圾回收。



顺便说一句，大家在很多地方看到一个说法，意思是说Old GC执行的时候一般都会带上一次Young GC



可能很多人不理解，其实如果你把咱们这里的几个条件分析清楚了就知道了，一般Old GC很可能就是在Young GC之前触发或者在Young GC之后触发的，所以自然Old GC一般都会跟一次Young GC连带关联在一起了。



另外一个，在很多JVM的实现机制里，其实在上述几种条件达到的时候，他触发的实际上就是Full GC，这个Full GC会包含Young GC、Old GC和永久代的GC



也就是说触发Full GC的时候，可能就会去回收年轻代、老年代和永久代三个区域的垃圾对象。



下周开始我们进入JVM实操环节，会带大家用各种代码模拟出各种场景，然后观察JVM GC日志



大家会看到，其实满足上述一些条件的时候，在GC日志中看到的就是Full GC的字样，同时在Full GC中大家会看到同时对年轻代、老年代、永久代都进行了垃圾回收。



但是这个东西其实没办法给大家一个准确的定义，说到底触发Full GC的时候，是先执行Young GC？还是先执行Old GC。



因为不同的Full GC触发条件其实是不一样的，而且不同的JVM版本的实现机制也不同。



所以很多时候，我们也只能给大家笼统的概括一句：上述条件满足时触发Full GC，Full GC一般会带上一次Young GC去回收新生代，同时也会有Old GC也回收老年代，还会去回收永久代。



**4、永久代满了之后怎么办？**



大家现在既然都知道了，Full GC有上述几个触发条件，同时触发Full GC的时候其实会带上针对新生代的Young GC，也会有针对老年代的Full GC，还会有针对永久代的GC。所以假如存放类信息、常量池的永久代满了之后，就会触发一次Full GC。



这样Full GC执行的时候，就会顺带把永久代中的垃圾给回收了，但是永久代中的垃圾一般是很少的，因为里面存放的都是一些类，还有常量池之类的东西，这些东西通常来说是不需要回收的。如果永久代真的放满了，回收之后发现没腾出来更多的地方，此时只能抛出内存不够的异常了。



**5、本文总结**



上篇文章和这篇文章，基本上就把各种GC的概念给屡清楚了，同时结合之前学习到的知识，清楚的限定了各种GC的触发时机。其实整体知识框架跟之前基本上是匹配和吻合的，只不过在各种细化的概念上，做了很多的澄清和限定。



# 039、案例实战：每秒10万并发的BI系统是如何频繁发生Young GC的？

2019-08-08 07:00:00

**1、前文回顾**



本周我们的一个重点就是给大家再次强调一下JVM频繁GC对系统性能的危害性



因此在分析完JVM发生GC的场景以及原理，以及梳理清楚各种GC名词的概念和触发时机之后，我们就可以来用两个之前我们线上系统真实的案例来给大家再次在脑海中强化一下频繁GC带来的性能问题。



**2、服务于百万级商家的BI系统是什么？**



先给大家说一下我们线上一个真实的生产系统，是一个服务于百万级商家的BI系统。



这个所谓BI系统，很多开发业务系统的同学可能没接触过，所以我们简单介绍一下他的背景。



简单来说，比如你是一个平台，然后有数十万甚至上百万的商家在你的平台上做生意，会使用你的这个平台系统



此时一定会产生大量的数据，然后基于这些数据我们需要为商家提供一些数据报表，比如：每个商家每天有多少访客？有多少交易？付费转化率是多少？



当然实际情况会比这个简单几句话复杂很多，我们这里就简单说个概念而已。所以此时就需要一套BI系统



所谓BI，英文全称是“Business Intelligence”，也就是“商业智能”，听起来是不是特别的高大上？



其实也别想的太高大上了，说白了，就是把一些商家平时日常经营的数据收集起来进行分析，然后把各种数据报表展示给商家的一套系统。



所谓“商务智能”，指的就是给你看一些数据报表，然后让你平时能够更好的了解自己的经营状况，然后让老板“智能”的去调整经营策略，提升业绩。



所以类似这样的一个BI系统，大致的运行逻辑如下所示，首先从我们提供给商家日常使用的一个平台上会采集出来很多商家日常经营的数据，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60840200_1565174333.cn/txdocpic/0/64a85974a95f162917f56c27734292f9/0)



接着就可以对这些经营数据依托各种大数据计算平台，比如Hadoop、Spark、Flink等技术进行海量数据的计算，计算出来各种各样的数据报表，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79688500_1565174333.cn/txdocpic/0/78d0d3d671ffe7167277b36188df951d/0)



然后我们需要将计算好的各种数据分析报表都放入一些存储中，比如说MySQL、Elastcisearch、HBase都可以存放类似的数据，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3529100_1565174334.cn/txdocpic/0/8df26d89ab5ec10da32a3d79c6134151/0)



最后一步，就是基于MySQL、HBase、Elasticsearch中存储的数据报表，基于Java开发出来一个BI系统，通过这个系统把各种存储好的数据暴露给前端，允许前端基于各种条件对存储好的数据进行复杂的筛选和分析，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24062500_1565174334.cn/txdocpic/0/94a2fd799b14896a8f9e908b5e407edb/0)



**3、刚开始上线系统时候的部署架构**



我们在这里重点作为案例分析的就是上述场景中的BI系统，其他环节都跟大数据相关的技术是有关联的，我们暂时先不涉及，未来有机会可以给大家出更多的课程来阐述那些技术。



刚开始的时候，这个BI系统使用的商家是不多的。因为大家要知道，即使在一个庞大的互联网大厂里，虽然说大厂本身积累了大量的商家，但是你要是针对他们上线一个付费的产品，刚开始未必所有人都买账，所以一开始系统上线大概就少数商家在使用，比如就几千个商家。



所以刚开始系统部署的非常简单，就是用几台机器来部署了上述的BI系统，机器都是普通的4核8G的配置，然后在这个配置之下，一般来说给堆内存中的新生代分配的内存都在1.5G左右，Eden区大概也就1G左右的空间



如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42196900_1565174334.cn/txdocpic/0/ccb37c6e35533b8dff1c47ce882a0863/0)



**4、技术痛点：实时自动刷新报表 + 大数据量报表**



其实刚开始，在少数商家的量级之下，这个系统是没多大问题的，运行的非常良好，但是问题恰恰就出在突然使用系统的商家数量开始暴涨的时候。



突然使用系统的商家开始越来越多，比如给大家举个例子，当商家的数量级达到几万的时候。



此时要给大家说明一个此类BI系统的特点，就是在BI系统中有一种数据报表，他是支持前端页面有一个JS脚本，自动每隔几秒钟就发送请求到后台刷新一下数据的，这种报表称之为“**实时数据报表**”，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/58762200_1565174334.cn/txdocpic/0/60af57a050f134d2e1b508c55571a182/0)



那么大家可以设想一下，假设仅仅就几万商家作为你的系统用户，很可能同一时间打开那个实时报表的商家就有几千个



然后每个商家打开实时报表之后，前端页面都会每隔几秒钟发送请求到后台来加载最新数据，基本上会出现你BI系统部署的每台机器每秒的请求会达到几百个，我们假设就是每秒500个请求吧。



然后每个请求会加载出来一张报表需要的大量数据，因为BI系统可能还需要针对那些数据进行内存中的现场计算加工一下，才能返回给前端页面展示。



根据我们之前的测算，每个请求大概需要加载出来100kb的数据进行计算，因此每秒500个请求，就需要加载出来50MB的数据到内存中进行计算，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75825400_1565174334.cn/txdocpic/0/fa9d08c6b4b3a1cf29c17b390511869a/0)



**5、没什么大影响的频繁Young GC**



其实大家都已经发现上述系统的问题了，在上述系统运行模型下，基本上每秒会加载50MB的数据到Eden区中，只要区区200s，也就是3分钟左右的时间，就会迅速填满Eden区，然后触发一次Young GC对新生代进行垃圾回收。



当然1G左右的Eden进行Young GC其实速度相对是比较快的，可能也就几十ms的时间就可以搞定了



所以之前也分析过，其实对系统性能影响并不大。而且上述BI系统场景下，基本上每次Young GC后存活对象可能就几十MB，甚至是几MB。



所以如果仅仅只是这样的话，那么大家可能会看到如下场景，BI系统运行几分钟过后，就会突然卡顿个10ms，但是对终端用户和系统性能几乎是没有影响的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98734200_1565174334.cn/txdocpic/0/5b40474a48e743fbc7a8bd7781ea4149/0)





**6、提升机器配置：运用大内存机器**



针对这样的一套系统，后来随着越来越多的商家来使用，并发压力越来越大，甚至高峰期会有每秒10万的并发压力



大家想想，如果还是用4核8G的机器来支撑，那么可能需要部署上百台机器来抗住每秒10万的高并发压力。



所以一般针对这种情况，我们会提升机器的配置，本身BI系统就是非常吃内存的系统，所以我们将部署的机器全面提升到了16核32G的高配置机器上去。每台机器可以抗个每秒几千请求，此时只要部署比如二三十台机器就可以了。



但是此时问题就来了，大家可以想一下，如果要是用大内存机器的话，那么新生代至少会分配到20G的大内存，Eden区也会占据16G以上的内存空间，此时如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/22850200_1565174335.cn/txdocpic/0/bdde1f7ba18db5691fe9a0fff78fe034/0)



此时每秒几千请求的话，每秒大概会加载到内存中几百MB的数据，那么大概可能几十秒，甚至1分钟左右就会填满Eden区，会就需要执行Young GC。



此时Young GC要回收那么大的内存，速度会慢很多，也许此时就会导致系统卡顿个几百毫秒，或者1秒钟，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45753900_1565174335.cn/txdocpic/0/828a55f48b1394fb5faa8f37abd11f13/0)



那么你要是系统卡顿时间过长，必然会导致瞬间很多请求积压排队，严重的时候会导致线上系统时不时出现前端请求超时的问题，就是前端请求之后发现一两秒后还没返回就超时报错了。



**7、用G1来优化大内存机器的Young GC性能**



所以当时对这个系统的一个优化，就是采用G1垃圾回收器来应对大内存的Young GC过慢的问题



对G1设置一个预期的GC停顿时间，比如100ms，让G1保证说每次Young GC的时候最多停顿100ms，避免影响终端用户的使用。



此时效果是非常显著的，G1会自动控制好在每次Young GC的时候就回收一部分Region，确保GC停顿时间控制在100ms以内



这样的话，也许Young GC的频率会更高一些，但是每次停顿时间很小，这样对系统影响就不大了。



**8、本文总结**



本文用一个案例，其实就想给大家说明一个问题，那就是Young GC通常哪怕发生的频繁一些，其实一般都对系统造成不了太大的影响



只有在你机器内存特别大的时候，要注意Young GC也可能会导致比较长时间的停顿，此时针对大内存机器通常建议采用G1垃圾回收器。



**9、小小思考题**



看到这里，给大家留一个小思考题，去想办法看看自己线上系统：



- 多长时间发生一次Young GC？
- Young GC耗时多久？
- 然后你觉得它对你的系统影响大吗？

# 040、案例实战：每日百亿数据量的实时分析引擎，为啥频繁发生Full GC ？

2019-08-09 07:00:00

**1、上文案例再分析**



这个案例将会给大家分析一个频繁Full GC的真实生产案例，我们会延续之前讲过的一个案例，继续进行分析，下面先把之前的案例贴出来放在下文。



之前分析过的一个日处理上亿数据的计算系统，就是本文所要分析的“每日百亿数据量的实时分析系统”。



**2、一个日处理上亿数据的计算系统**



先给大家说一下这个系统的案例背景，大概来说是当时我们团队里自己研发的一个数据计算系统，日处理数据量在上亿的规模。



为了方便大家集中注意力理解这个系统的生产环境的JVM相关的东西，所以对系统本身就简化说明了。



简单来说，这个系统就是会不停的从MySQL数据库以及其他数据源里提取大量的数据加载到自己的JVM内存里来进行计算处理，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13463500_1565270423.cn/txdocpic/0/a2a44346a04ac9e835c45bc763f5fbe2/0)



这个数据计算系统会不停的通过SQL语句和其他方式，从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。



但是这是一套分布式运行的系统，所以生产环境部署了多台机器，每台机器大概每分钟负责执行100次数据提取和计算的任务。



每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间，然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/32394800_1565270423.cn/txdocpic/0/0f1c80d13cc35c5a59e006c125ab6471/0)



**3、这个系统到底多块会塞满新生代？**



现在明确了一些核心数据，接着我们来看看这个系统到底多快会塞满新生代的内存空间？



既然这个系统每台机器上部署的实例，每分钟会执行100次数据计算任务，每次是1万条数据需要计算10秒的时间，那么我们来看看每次1万条数据大概会占用多大的内存空间？



这里每条数据都是比较大的，大概每条数据包含了平均20个字段，可以认为平均每条数据在1KB左右的大小。那么每次计算任务的1万条数据就对应了10MB的大小。



所以大家此时可以思考一下，如果新生代是按照8:1:1的比例来分配Eden和两块Survivor的区域，那么大体上来说，Eden区就是1.2GB，每块Survivor区域在100MB左右，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53741500_1565270423.cn/txdocpic/0/27013616e76c608d90f90c4aa8839ad0/0)



基本上按照这个内存大小而言，大家会发现，每次执行一个计算任务，就会在Eden区里分配10MB左右的对象，那么一分钟大概对应100次计算任务，其实基本上一分钟过后，Eden区里就全是对象，基本就全满了。



所以说，回答这个小节的问题，新生代里的Eden区，基本上1分钟左右就迅速填满了。



**4、触发Minor GC的时候会有多少对象进入老年代？**



此时假设新生代的Eden区在1分钟过后都塞满对象了，然后在接着继续执行计算任务的时候，势必会导致需要进行Minor GC回收一部分的垃圾对象。



那么上篇文章给大家讲过这里在执行Minor GC之前会先进行的检查。



首先第一步，先看看老年代的可用内存空间是否大于新生代全部对象？看下图，此时老年代是空的，大概有1.5G的可用内存空间，新生代的Eden区大概算他有1.2G的对象好了。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73417700_1565270423.cn/txdocpic/0/0c9b3fef4480068f6596d7e497b69f43/0)



此时会发现老年代的可用内存空间有1.5GB，新生代的对象总共有1.2GB，即使一次Minor GC过后，全部对象都存活，老年代也能放的下的，那么此时就会直接执行Minor GC了。



那么此时Eden区里有多少对象还是存活的，无法被垃圾回收呢？



大家可以考虑一下之前说的那个点，每个计算任务1万条数据需要计算10秒钟，所以假设此时80个计算任务都执行结束了，但是还有20个计算任务共计200MB的数据还在计算中



那么此时就是200MB的对象是存活的，不能被垃圾回收掉，然后有1GB的对象是可以垃圾回收的，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95300400_1565270423.cn/txdocpic/0/2c9dd6de204132c1782abb9befc0108f/0)



此时一次Minor GC就会回收掉1GB的对象，然后200MB的对象能放入Survivor区吗？



**不能！**因为任何一块Survivor区实际上就100MB的空间，此时就会通过空间担保机制，让这200MB对象直接进入老年代去，占用里面200MB内存空间，然后Eden区就清空了，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13555300_1565270424.cn/txdocpic/0/595cc6ef34ae543070f7c2a199041ada/0)





**5、系统运行多久，老年代大概就会填满？**



那么大家想一下，这个系统大概运行多久，老年代会填满呢？



按照上述计算，每分钟都是一个轮回，大概算下来是每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，然后大概都会有200MB左右的数据进入老年代。



那么大家可以想一下，假设现在2分钟运行过去了，此时老年代已经有400MB内存被占用了，只有1.1GB的内存可用，此时如果第3分钟运行完毕，又要进行Minor GC会做什么检查呢？



如下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33582400_1565270424.cn/txdocpic/0/5b5b675f627b6e4079b5a25c51fd7489/0)



此时会先检查老年代可用空间是否大于新生代全部对象！



此时老年代可用空间1.1GB，新生代对象有1.2GB，那么此时假设一次Minor GC过后新生代对象全部存活，老年代是放不下的，那么此时就得看看一个参数是否打开了 。



如果“-XX:-HandlePromotionFailure”参数被打开了，当然一般都会打开其实，此时会进入第二步检查，就是看看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。



我们已经计算过了，大概每分钟会执行一次Minor GC，每次大概200MB对象会进入老年代。



那么此时发现老年代的1.1GB空间，是大于每次Minor GC后平均200MB对象进入老年代的大小的，所以基本可以推测，本次Minor GC后大概率还是有200MB对象进入老年代，1.1G可用空间是足够的。



所以此时就会放心执行一次Minor GC，然后又是200MB对象进入老年代。



转折点大概在运行了7分钟过后，7次Minor GC执行过后，大概1.4G对象进入老年代，老年代剩余空间就不到100MB了，几乎快满了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53368600_1565270424.cn/txdocpic/0/4858e3f283323859740672320cd34233/0)





**6、这个系统运行多久，老年代会触发1次Full GC？**



大概在第8分钟运行结束的时候，新生代又满了，执行Minor GC之前进行检查，此时发现老年代只有100MB内存空间了，比之前每次Minor GC后进入老年代的200MB对象要小，此时就会直接触发一次Full GC。



Full GC会把老年代的垃圾对象都给回收了，假设此时老年代被占据的1.4G空间里，全部都是可以回收的对象，那么此时一次性就会把这些对象都给回收了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79149500_1565270424.cn/txdocpic/0/dfa1aa67d11adc2344b6eaf6b8f0afe5/0)



然后接着就会执行Minor GC，此时Eden区情况，200MB对象再次进入老年代，之前的Full GC就是为这些新生代本次Minor GC要进入老年代的对象准备的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/97454800_1565270424.cn/txdocpic/0/ff8e4614f20b8854780172685c53ea1c/0)



按照这个运行模型，基本上平均就是七八分钟一次Full GC，这个频率就相当高了。



因为每次Full GC速度都是很慢的，性能很差，而且**明天的文章会告诉大家，为什么Full GC的时候会严重影响系统性能。**



**7、该案例应该如何进行JVM优化？**



相信通过这个案例，大家结合图一路看下来，对新生代和老年代如何配合使用，然后什么情况下触发Minor GC和Full GC，什么情况下会导致频繁的Minor GC和Full GC，大家都有了更加深层次和透彻的理解了。



对这个系统，其实要优化也是很简单的，因为这个系统是数据计算系统，每次Minor GC的时候，必然会有一批数据没计算完毕，但是按照现有的内存模型，最大的问题，其实就是每次Survivor区域放不下存活对象。



所以当时我们就是对生产系统进行了调整，增加了新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代，这样Survivor区大概就是200MB，每次刚好能放得下Minor GC过后存活的对象了，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15068200_1565270425.cn/txdocpic/0/c6dd4fa67166c92a852d81497602b4bd/0)



只要每次Minor GC过后200MB存活对象可以放Survivor区域，那么等下一次Minor GC的时候，这个Survivor区的对象对应的计算任务早就结束了，都是可以回收的



此时比如Eden区里1.6GB空间被占满了，然后Survivor1区里有200MB上一轮 Minor GC后存活的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35208100_1565270425.cn/txdocpic/0/1529a0eb09d15c59499ee08fdaf539a7/0)



然后此时执行Minor GC，就会把Eden区里1.4GB对象回收掉，Survivor1区里的200MB对象也会回收掉，然后Eden区里剩余的200MB存活对象会放入Survivor2区里，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56278200_1565270425.cn/txdocpic/0/6ea6749024c342adef6918b21d3751f6/0)



以此类推，基本上就很少对象会进入老年代中，老年代里的对象也不会太多的。



通过这个分析和优化，定时我们成功的把生产系统的老年代Full GC的频率从几分钟一次降低到了几个小时一次，大幅度提升了系统的性能，避免了频繁Full GC对系统运行的影响。





**8、如果该系统的工作负载再次扩大10倍呢？**



相信大家之前都看过这个案例了，这次正好借着这个机会再次重看一遍，加深一下印象，同时我们接着说当时那个生产系统在每日处理1亿数据之后，随着一段时间过后，工作负载再次扩大10倍的情景。



如果工作负载扩大10倍，那么大家参照上图来看，此时会导致每秒钟要加载100MB的数据到内存里去，对于1.6G的Eden而言，10多秒就会迅速塞满，此时就会触发Young GC。



但是之前说过，你每次加载一批数据到内存里去，一般要处理10秒以上的时间才能计算完毕，在计算完毕之前这些数据是不能被回收的。



所以如果你10多秒就触发一次Young GC，直接导致的后果就是，此时可能能回收掉的垃圾也就几百MB而言，可能1GB的对象都是无法回收的，大家仔细理解一下这个意思。



此时就会导致每隔10多秒，就有1GB的数据进入老年代中，而老年代之前给大家说过，也就1GB左右的空间而已，即使勉强让你放下了，那么下一次过10多秒之后，又会放1GB的对象到老年代，此时必然会提前触发Full GC去回收老年代里的1GB的对象，然后再让你把这次Young GC后存活的1GB对象放入老年代。



这就是当时我们遇到的真实生产场景，基本上一台4核8G的机器，每分钟要触发二三次Full GC，对系统性能造成了巨大的影响，简直是可怕至极。





**9、使用大内存机器来优化上述场景**



所以但是针对这个问题，因为考虑是计算类的系统，也是非常的吃内存的，所以同样是更换成了每台机器都是16核32G的高配置机器



这样的话，Eden基本上空间会扩大10倍，比如有16GB。



那么此时按照每秒加载100MB的数据到内存里进行计算，要2分钟左右才会触发一次Young GC，因为降低了Young GC的频率，所以每次Young GC的时候存活对象大概也就几百MB而已，不会超过1GB。



当时给Survivor区域分配的是每个Survivor有2GB内存，所以每次Young GC过后的存活对象可以轻松放入Survivor区域中，不会进入老年代。这就完美的通过提升机器配置的方式，解决了频繁Young GC和Full GC的问题。



很多同学可能会提问了，那么针对大内存机器，需要用G1来减少每次Young GC的停顿时间吗？



**答案是：不用**。因为这是一个后台自动进行计算的系统，他不是直接面向用户的系统，所以哪怕每隔2分钟一次Young GC，一次要停顿1秒钟，也对系统几乎没任何影响。





**10、本文总结**



这篇文章接着之前的案例，让大家看了一下，1亿数据量级下的系统部署4核8G的机器，Full GC为何频繁发生，如何优化？10亿量级下的系统部署在4核8G的机器上，Full GC会发生的有多么的恐怖，如何通过提升机器配置来优化？



相信大家仔细看完这个案例，多看几遍，透彻理解了，多频繁Full GC问题就彻底理解了。





**11、小小思考题**



今日给大家留的一个小小思考题：

- 看看你们线上系统一般每隔多长时间发生一次Full GC？
- 每次Full GC持续多久？
- 对你们系统的性能有影响吗？

# 041、第6周作业：打开脑洞！如果你的线上系统压力增长100倍，会有频繁GC问题吗？

2019-08-10 07:00:00

很多同学都给我反馈说，看了这系列文章，感觉学到了很多东西



但是手痒痒自己想优化一下线上系统的时候，尴尬的发现，线上系统似乎内存充足，压力不大，Young GC和Full GC的频率都很低，好像没什么好优化的。



其实这就是一个很正常的现状，大部分普通系统，其实压力很小，几乎没什么JVM的性能问题，也很正常。



但是你负责的系统JVM一切正常，不代表你就不需要了解JVM的运行原理和优化手段！尤其在面试跳槽的时候，那3年以上经验的工程师，都必然会问你JVM相关的问题，尤其注重考查你对线上JVM做的优化。



何况你现在如果得过且过了，那么如果未来你有机会进入阿里呢？有机会进入美团呢？或者进入一些虽然是中小公司，但是线上系统也有一定压力。类似这种大厂里的系统很多负载压力都很高，你进去了以后发现线上JVM有问题了，此时再想着学习JVM优化，那就是临时抱佛脚了。



所以本周的作业非常简单，就是让你思考一个问题：打开脑洞，如果你当前负责的系统负载增加10倍，或者100倍，那么在有限的机器资源下，每台机器复杂都打到很高的话，此时你分析分析，Young GC的频率会如何？Full GC的频率会如何？对你们的系统性能会有影响吗？



大家自己一定要思考和分析一下这些问题。

-----评论-------
 nightmare 2天前

我们线上的系统 young gc 和 full gc 都比较频繁，但是业务层面并不要求实时性很大 学完一系列文章以后 偷偷的在服务器上加上了 parnew cms收集器 然后差不多7分钟一次young gc 然后几个小时一次full gc 但是贷款业务真的对延时不在乎

dexia 2天前

老师，如果在做定时任务数据处理的时候，在一个方法里面通过多线程的方式来处理数据库中的数据，在其他线程没有结束之前，其中一个线程提前处理完了，那该线程所new的对象会变成垃圾对象吗？还是说也要等到其他线程都处理完了才会变成垃圾对象？

丁硕 2天前

就着这篇作业，总结一下。我理解的优化思路： 项目上线初期： 1、上线前，根据预期的并发量、平均每个任务的内存需求大小等，然后评估需要使用几台机器来承载，每台机器需要什么样的配置。 2、根据系统的任务处理速度，评估内存使用情况，然后合理分配Eden、Survivor，老年代的内存大小。 总体原则就是，让短命对象在YoungGC就被回收，不要进入老年代，长期存活的对象，尽早进入老年代，不要在新生代复制来复制去。对系统响应时间敏感且内存需求大的，建议采用G1回收器 如何合理分配: （1）、根据内存增速来评估多久进行进行Young GC （2）、根据每次Young GC的存活，评估一下Survivor区的大小设置是否合理 （3）、评估多久进行一次FullGC，产生的STW，是否可以接受？ 公司的运营很牛，过了一段时间，系统负载增加了10倍，100倍： 方案1：增加服务器数量 根据系统负载的增比，同比增加机器数量，机器配置，和jvm的配置可以保持不变。 方案2：使用更高配置的机器 更高的配置，意味着更快速的处理速度和更大的内存。响应时间敏感且内存需求大的使用G1回收器 这时候需要和‘项目上线初期’一样，合理的使用配置和分配内存



# 042、第6周答疑：本周问题答疑汇总！

2019-08-11 07:00:00

**学员总结：**

g1和pn+cms调优原则都是尽可能ygc，不做老年代gc。 g1相对而言更加智能，也意味着jvm会用更多的资源去判断每个region的使用情况。



而pn+cms也更加纯粹和直接，虽然g1在gc时不会产生碎片，但是由于每个region存在存活率85%不清理的机制，会导致内存没有充分释放问题。 



因此，对于cpu性能高的，内存容量大的，对应用响应度高的系统推荐使用g1。 而内存小，cpu性能比较低下的系统也可以使用pn+cms会更合适。



**回答：**分析的很好



**问题：**

复习的总结： 脑子里一定要有一个会动的图： 

1、启动一个线程执行业务代码（执行main方法就是开启一个main线程）； 

2、线程对应的程序计数器PC来记录程序执行到哪行字节码指令（线程与PC是1:1关系）； 

3、调用方法时会创建一个“栈帧”，放入线程对应的栈中（线程与栈、方法和栈帧都是1:1关系） 

4、代码运行中创建的对象放在java堆内存（堆与JVM进程是1:1关系，堆是所有进程共享）



**回答：**很好，可以把后面学习的各种gc原理都总结一下



**问题：**

老师，这里为什么说G1就适合大堆的情况呢？说对实时性要求高一点的可以理解，因为它有Maxpause的时间限制，但这个适合大堆的情况是怎么来理解呢



**回答：**假设你有32G内存，如果用ParNew+CMS，必须等待你的内存填满了才会触发GC，此时一GC就会回收几十G的垃圾，那么速度会很慢，可能导致你的系统停顿时间多达几十秒都有可能。



但是用了G1之后，他会更加频繁的回收Region，每次就回收一部分Region，保证停机时间不会太长。所以G1其实更加适合大内存的机器



**问题：**

动态对象年龄判断我有点疑惑，假设年龄为3的对象大小超过了survivor 区域的一半，年龄都为3，说明它们都是经过了3次gc存活下来的，都是从年龄为2的时候经过gc存活下来的，那在年龄为2的时候这些对象大小就应该超过survivor的一半了



同理年龄为1的时候也一样，也就是说如果有同龄的对象大小超过了survivor的一半，就只能是年龄为1的对象，而根据规则，年龄大于等于1的就得转移到老年代去了



那根据以上的推论，根本就不会出现年龄大于1的同龄对象总大小超过survivor一半的，如果有，早在年龄为1的时候这些对象就已经转移到老年代了。



然后在一篇博客上看到说这是一个误区，是年龄从小到大进行累加，当加入某个年龄段后大小超过一半了，就从这个年龄段往上的年龄转移到老年代，而不是某个年龄的大小。看上去好像也挺有道理的，所以就有点疑惑。



**回答：**其实是年龄1+年龄2+年龄3的对象占据了超过50%的Survivor，就会让年龄3以上的对象进入老年代，动态年龄判定规则应该是这样的



**问题：**

请问老师，动态年龄判断算法是这样么：Survivor区的对象年龄从小到大进行累加，当累加到 X 年龄时的总和大于50%（可以使用-XX:TargetSurvivorRatio=? 来设置保留多少空闲空间，默认值是50），那么比X大的都会晋升入老年代



**回答：**对的，就是你说的这样





**学员思考题回答：**

老师，请您耐心帮我看下，如果有错误的话帮我指点下，谢谢啦。



系统采用是g1回收器。 

1.如果新生代未达60%，老年代未达45%，系统照常运行，不会触发回收 



2.如果新生代达60%，此后如果如有新对象生成，跑到新生代，会触发ygc. 

（1）开启了空间担保机制，ygc先判断是否需要fgc,如果每次回收后对象少于老年代空闲大小，则不用fgc,否则要 

（2）不用触发，但ygc后的对象大于老年代空闲大小，无法直接进入老年代，触发fgc. 

（3）触发混合回收，先通过gcroot初始标记哪些不是垃圾对象(此过程会stw,不过很快)，然后并发标记(用户线程和标记线程并行)，接着最终标记(会stw，标记并发标记过程中可能新产生的垃圾对象)，最后混合回收(此过程采用复制算法，不会产生垃圾碎片，所以不用在回收完去整理内存碎片



g1会按照我们给定的时间去stw并回收，争取回收性价比的对象，如果回收次数少于8次，则再次混合回收。不过，在回收中空闲region大小达到堆5%，会提前结束。)如果回收失败，则转换采用serialold回收器。 3.当老年代代达45%会触发上面那个混合过程。



**回答：**分析的非常好



**问题：**

老师，请教下，是否有方法可以根据设定的xss的大小推算可以支撑多少线程的方法？



是不是可以理解为整个jvm的大小减掉堆和方法区的余下额度/xss的大小呢？谢谢



**回答：**对的，就是这样子，但是一般单个JVM内部也就最多几百个线程，其实不会太多的



**学员评价：**

感谢老师的这篇，这样螺旋上升可以说是非常的值得了。



**回答：**是的，我们的思路就是每周布置作业，对核心原理会贯穿全文反复的强化，最终就是让你彻底建立起来系统运行时候的jvm动态运行模型，理解如何对jvm进行优化，解决问题



**学员评价：**

老师深知人脑的遗望曲线啊，还专门花一周带着我们复习，太赞了，有时候学得太快反而学完就忘，只有充分消化成自己的东西才能达到学习的最佳效果。期待老师写完这个专栏继续出更多的好专栏。



**回答：**是的，我们很了解大部分人学习的问题，很多人也许会做作业，很多人也许不做作业，所以必须把核心知识螺旋形，反复强化，深入每个人的脑子里去，让脑子里有一个jvm运行时的动态图



**学员总结：**

文章总体意思，就是新生代gc一般没什么影响 ，但是大内存的堆就会导致 新生代回收很慢 。



如果在高并发的情况下，不仅慢而且还没频繁 full gc影响很大 涉及过程很复杂 ，时间也是新生代的10倍以上 。但是 full gc频繁不频繁又和新生代 gc有很大的关系 比如 

1.新生代年龄躲过15次以后 



2.大对象直接进入老年代 G1例外 有专门存储大对象的region 



3.动态年龄规则 4.supervisor区放不下 



其中 3和 4是 最值得关注的 比如supervisor区内存很小 会引发3 4 很频繁 导致很频繁的full gc



**回答：**分析总结的非常到位



**问题：**

老师，学了一个多月还积累了几个问题。 



1、minor fc和full gc一样都是追踪追踪gc root，为什么full gc的root追踪就更慢呢？是因为minor fc的root更少，还是链条更短？ 



2、从root追踪是垃圾回收线程从扫描栈中的局部变量开始吗？



**回答：**

1、老年代gc，从GC Roots开始追踪，但是老年代的存活对象更多，所以追踪速度更慢；新生代存活对象极少，所以追踪速度极快 



2、GC Roots就是两种，方法里的局部变量，类的静态变量，从这两个地方开始追踪扫描即可



**学员学习总结：**

前几天碰到了full gc非常频繁的状态。由于同事采用了默认的jvm参数，导致前期新生代不断扩容，对象直接进入老年代。



中期，s区大小不够，对象还是往老年代走。后期，老年代不断在full gc，导致cpu使用率99%，阿里云都报警了。



最后我固定了新生代2g，老年代2g，eden和s比例为2，并且使用了cms，最后屏蔽了system.gc()的full gc回收。最终可以做到只做minor gc的效果。感谢老师这一个月的教导。



**回答：**非常的好，足见你真的吃透了这一个月的内容了，而且对线上系统的jvm问题，可以分析出来是怎么回事，合理优化内存分配，就能提升jvm性能，继续加油



**学员思考题回答：**

系统创建的对象被分配到java堆内存中，要想计算创建的对象内所占的内存对象，就需要计算对象的每个部分所占的内存大小；



java对象包括对象头、实例数据以及对象填充： 对象头包括对象的基本信息以及class的指针类等相关信息占用64bit（64位机器不压缩）； 



数据实例包括八种数据基本类型以及引用类型，将所用的全部算起来相加； 最后再加上对象头，计算8的最低倍数进行是否填充，最终则为所占用的内存空间bit



**回答：**对的



**学员总结：**

新系统上线要估算核心业务，每次请求产品的内存垃圾



例如100k，访问量QPS为100，则每秒产生垃圾10M，每次请求响应限制在时间为200ms以内,每次回收会有2M的对象卡在内存中,这40M内存触发Minor GC的时候还有引用，是存活对象，Minor GC后进入Survivor区。 



1个4和8G的服务器，可以分配永久代0.5G(512M)+新生代4G+(4G+0.5G+0.5G)+永久代1G， 那相当于平均没400秒（大约7分钟）Eden区就满了，就触发Minor GC。 



如果发现有太多对象没进入Survivor区，而是直接进入老年代，频繁Full GC的情况，则可以加大Survivor区。 



如果发现有对象写对象存活时间较长，进行15次GC后进入老年代，然后被Full GC清理。则可以加大MaxTenuringThreshold的参数值。 



大致思路就是尽量减少对象进入老年代，让年轻对象在MInor GC就被清理。 如果访问量暴增，则可以用多态机器进行负载均衡。



**回答：**分析的非常好





**问题：**

老师：一直有一个疑问，就是对象在minor gc后，survivor无法容纳就会进入老年代。疑问：gc剩余的对象年龄各不相同，应该是部分进入老年代？还是全部进入老年代



**回答：**要是Survivor无法容纳， 那就全部进入老年代





**问题：**

假如我们设置GC停顿时间设置为20ms，新生代默认最大占比60%，当G1监控到Region区域的对象的回收预期时间满足20ms，是否会马上进行一次minor GC？此时新生代的占比仅为20%。 



老师请问下，上述表述是否正确，或者说另一个触发G1 minor gc的条件是新生代监控到的可回收象的回收预期时间满足MaxGCPauseMills就立马触发，进行垃圾回收，释放空间？



**回答：**不会的，其实他很可能让你用到50%的时候，然后回收掉里面一小部分Region，保证gc停顿时间在20ms



**学员动手之后的总结：**

在自己的阿里云上跑了一个开源的后台管理系统。 最开始启动后，我随便刷了几个网页，在服务器上用命令一查看GC情况，YGC 100多次，FullGC 6次。然后看JVM内存，才100M。 



然后我就调大了 JVM 堆内存，新生代内存，还没有调 Eden 区的比例。然后我又刷了20多次页面，一直追踪 JVM 内存占用情况。此时才发生了6次YGC，3次FullGC，而且在刷新网页的时候，没有发生 FullGC 的情况。 所以3次 FullGC 应该是启动的时候发生的。 



一次简单的实际操作，感觉对所谓的 JVM 优化，理解又上了一个小层次。 



正好呼应了老师今天的课程，为什么要 JVM 优化，就是为了避免系统频繁的卡顿，因为如果内存大小、参数设置不合理，就会让对象频繁进入老年代，老年代对象迅速增多，频繁触发 FullGC。



**回答：**分析的非常棒



**问题：**

老师，感觉jvm的优化就在于尽量降低老年代gc，而最根本的就是对于新生代的内存分配，同时如果是大内存的场景对于垃圾回收器就可以考虑G1.平衡垃圾回收的资源数和时间关系。



这么理解合适吗？谢谢



**回答：**理解的很到位



**学员总结：**

今天对一些概念理清总结:minor gc/young gc即年轻代垃圾回收，old gc单纯指老年代垃圾回收，full gc指年轻代，老年代，永久代等整个JVM的内存回收，mixed gc 指年轻代和老年代回收。建议用以上名词，少用major gc。



**回答：**对的





**问题：**

可以不可以这样理解采用G1回收刚开始新生代是不会回收的即便是最初的eden满了也不会gc此时因为还有好多region可以分配所以继续扩展region直到堆内存的60%或者你设置的置才不会扩展region但是回收 region还是遵循规定时间内回收一部分region



**回答：**理解正确



**学员总结：**

哟，又是沙发。 早上到公司，开机，开发工具全部启动。然后开网页，看老师的课程，如果有些比较不太理解的知识点，或者比较重要的知识点，就记录在笔记里。 谢谢老师的课程，对我来说，起到了查漏补缺，并且深入理解原理的作用。 跑了个开源项目在阿里云，也可以实际操作，跟着老师课程走。 肯定物有所值。



**回答：**多谢支持，继续加油



**学员总结：**

温故了一下：jvm内存优化就是 了解自己的系统运行的内存模型，估算合理的单位时间内产生的对象大小，然后分配合理的新生代和老年代内存空间，尽可能让普通的对象在新生代中折腾，不进入老年代.



**回答：**对的，完全get到我们的核心要点了



**学员评价：**

一路跟学下来感觉受益匪浅 老师内功深厚 毫无保留的授课 真的非常让我们感激 讲解思路清晰 希望以后老师能多出些课程 这样高含金量的专题太少了



**回答：**多谢支持，我和我的朋友未来会出更多类似这样的专栏的



**学员思考题回答：**

什么时候尝试触发Minor GC：

1，检查老年代的可用内存大于新生代的所有存活对象的大小直接触发Minor GC；

2，前1中检查结果相反，如果设置了handlerPromotionFailure然后检查老年代的可用内存大于历次转移过来的对象平均大小，则会尝试MinorGC，如果没设置或者检查相反也会触发，不过是先FullGC。 



什么时候回提前触发Full GC：在设置了handlerPromotionFailure下，老年代的可用内存小于历次转移过来的对象平均大小或者没设置了handlerPromotionFailure，可用内存小于新生代转移对象总大小则提前触发Full GC。 



Full GC算法：标记整理，需要标记存活对象并且移动排序到连续内存，耗时较长，这应该是就是为什么新生代不适用一块内存使用这个算法的原因吧。 



Minor GC之后对应集中情况：

1，Minor GC 之后存活的对象可以放入Survivor中。

2，Minor GC 之后存活对象较多但可以放入老年代。

3，老年代依然存不下转移对象产生OOM。 



哪些情况Minor GC 后会进入老年代：

1，每次Minor GC 存活对象年龄超过默认15岁（可设置）。

2，通过判断动态年龄达到的进入老年代。

3，大对象直接进入老年代



**回答：**分析的很好



**学员总结：**

看了大家的回复，都提到了spring 的bean。除此之外，我觉得还有以下几类长生命周期对象： 线程池的核心线程，coreSize那些，以及他们引用的对象，包括threadlocal引用的对象（除非手动清理） tomcat的各类组件，包括connector和container部分，比如filter，servlet，listener； 



同时，classloader， Class对象这些也是长生命周期； 各类池化技术，比如线程池，连接池等等。 暂时就知道这些吧



**回答：**是的，很好



**学员思考：**

打卡。大内存机器用g1，一般机器用parnew+cms就可以了。思考题容我去看看线上机器内存，我们一个机器都部署了好几个系统。还没有用容器技术。有的时候卡的不行，估计就是因为stop the world 导致的。



**回答：**是的，一般系统卡顿就是gc导致的



**学员思考：**

打卡。我们线上系统现在日活才1000左右，所以部署在4核8G机器上基本没压力，更多压力来自于定时任务，这个是每分钟就要读数据然后计算一下



但是相对于来说每秒吃的内存也很少，触发Young GC后，基本都回收完了，就是一些托管给spring的类进入老年代。所以这样的系统主要还是保证业务正常就行了，性能怎么样不太关心。



**回答：**很好，起码你对自己系统有个底了

# 043、动手实验：自己动手模拟出频繁Young GC的场景体验一下！

2019-08-12 07:00:00

**1、前文回顾**



从本周开始，我们将要全面进入实操环节，也就是说之前几周时间都是在分析JVM的运行原理、GC原理以及优化原理，但是本周开始我们将要通过各种代码模拟出来JVM的各种场景，同时结合GC日志去分析到底JVM是怎么运行的。



今天的文章，我们将会给大家通过代码演示年轻代的Young GC是如何发生的，同时告诉大家如何在JVM参数中去配置打印对应的GC日志，然后我们通过GC日志来慢慢的分析JVM的GC到底是如何运行的。



**2、程序的JVM参数示范**



首先，我们通过之前的学习都知道，我们平时系统运行创建的对象，除非是那种大对象，否则通常来说都是优先分配在新生代中的Eden区域的



而且新生代还有另外两块Survivor区域，默认Eden区域占据新生代的80%，每块Survivor区域占据新生代的10%。



比如我们用以下JVM参数来运行代码：

-XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC



上述参数都是基于JDK 1.8版本来设置的，不同的JDK版本对应的参数名称是不太一样的，但是基本意思是类似的。



上面“-XX:InitialHeapSize”和“-XX:MaxHeapSize”就是初始堆大小和最大堆大小，“-XX:NewSize”和“-XX:MaxNewSize”是初始新生代大小和最大新生代大小，“-XX:PretenureSizeThreshold=10485760”指定了大对象阈值是10MB。



相当于给堆内存分配10MB内存空间，其中新生代是5MB内存空间，其中Eden区占4MB，每个Survivor区占0.5MB，大对象必须超过10MB才会直接进入老年代，年轻代使用ParNew垃圾回收器，老年代使用CMS垃圾回收器，看下图图示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76996800_1565339987.cn/txdocpic/0/65911a045e76e3e16999973cc6518ce3/0)



**3、如何打印出JVM GC日志？**



接着我们需要在系统的JVM参数中加入GC日志的打印选型，如下所示：



1. -XX:+PrintGCDetils：打印详细的gc日志
2. -XX:+PrintGCTimeStamps：这个参数可以打印出来每次GC发生的时间
3. -Xloggc:gc.log：这个参数可以设置将gc日志写入一个磁盘文件



加上这个参数之后，jvm参数如下所示：

-XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log



**4、示例程序代码**



接着我们给大家看一段示例程序代码：

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/6175200_1565340158.png)



**5、对象是如何分配在Eden区内的**



上面的这段代码非常简单，先通过“new byte[1024 * 1024]”这样的代码连续分配了3个数组，每个数组都是1MB



然后通过array1这个局部变量依次引用这三个对象，最后还把array1这个局部变量指向了null



那么在JVM中上述代码是如何运行的呢？



首先我们来看第一行代码：byte[] array1 = new byte[1024 * 1024];。



这行代码一旦运行，就会在JVM的Eden区内放入一个1MB的对象，同时在main线程的虚拟机栈中会压入一个main()方法的栈帧，在main()方法的栈帧内部，会有一个“array1”变量，这个变量是指向堆内存Eden区的那个1MB的数组，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/6038300_1565339988.cn/txdocpic/0/4514ae339bf07256519140a4e72b2034/0)

接着我们看第二行代码：array1 = new byte[1024 * 1024];



此时会在堆内存的Eden区中创建第二个数组，并且让局部变量指向第二个数组，然后第一个数组就没人引用了，此时第一个数组就成了没人引用的“垃圾对象”了，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24271900_1565339988.cn/txdocpic/0/e21aa92656ef0da16c7e1560be62ee7c/0)



然后看第三行代码：byte[] array1 = new byte[1024 * 1024];。



这行代码在堆内存的Eden区内创建了第三个数组，同时让array1变量指向了第三个数组，此时前面两个数组都没有人引用了，就都成了垃圾对象，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41682600_1565339988.cn/txdocpic/0/b0850b892ef2a6cf4319674629a50c05/0)



接着我们来看第四行代码：array1 = null;。



这行代码一执行，就让array1这个变量什么都不指向了，此时会导致之前创建的3个数组全部变成垃圾对象，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/61832700_1565339988.cn/txdocpic/0/a6b0a185e74f4203228cba47186fdf44/0)



最后看第五行代码：byte[] array2 = new byte[2 * 1024 * 1024];。



此时会分配一个2MB大小的数组，尝试放入Eden区中，大家觉得这个时候Eden区能放的下吗？



**明显是不行的**，因为Eden区总共就4MB大小，而且里面已经放入了3个1MB的数组了，所以剩余空间只有1MB了，此时你放一个2MB的数组是放不下的。



所以这个时候就会触发年轻代的Young GC。



**6、采用指定JVM参数运行程序**



之前给大家讲过，在Eclipse等开发工具里如何以指定JVM参数运行程序，就是对你的程序右键，然后选择“Run As -> Run Configurations”，接着在下图中填入对应的JVM参数：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/82438100_1565339988.cn/txdocpic/0/120a83e3776a88e4fc6cdc7a59a09df4/0)



然后运行即可，此时运行完毕后，会在下述工程目录中出现一个gc.log文件，里面就是本次程序运行的gc日志，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99808300_1565339988.cn/txdocpic/0/a17c96c6b3355dc3f10ebc036ab5188f/0)



打开gc.log文件，我们会看到如下所示的gc日志：



Java HotSpot(TM) 64-Bit Server VM (25.151-b12) for windows-amd64 JRE (1.8.0_151-b12), built on Sep  5 2017 19:33:46 by "java_re" with MS VC++ 10.0 (VS2010)

Memory: 4k page, physical 33450456k(25709200k free), swap 38431192k(29814656k free)

CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC

0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K->512K(4608K), 0.0015734 secs] 4030K->574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

Heap

par new generation   total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)

 eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)

 from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)

 to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)

concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K



**是不是觉得乱七八糟，密密麻麻的？**



没关系，明天的文章我们会对照gc日志以及通过一步一图的方式，来分析一下到底Young GC是如何运行的。



**7、今日思考题**



给大家今天留一个小的思考题，自己结合之前学习过的JVM原理，包括我们已经画出来的图，还有GC日志，分析一下，这次Young GC到底是如何运行的？



# 044、高级工程师的硬核技能：JVM的Young GC日志应该怎么看？

2019-08-13 07:00:00

**1、前文回顾**

昨天的文章我们给大家了一个示例性的代码，同时给出了实验用的JVM参数，教会了大家如何在Eclipse中去使用指定的JVM参数运行程序，并且看到了代码运行触发的Young GC的日志，然后先让大家自己尝试思考和分析一下。



今天我们的文章就通过一步一图的方式，接着昨天的内容继续来仔细分析GC日志，同时配合画图告诉大家依次Young GC的实际执行过程。



**2、程序运行采用的默认JVM参数如何查看？**



在GC日志中，可以看到如下内容：



CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 .........



这就是告诉你这次运行程序采取的JVM参数是什么，基本都是我们设置的，同时还有一些参数默认就给设置了，不过一般关系不大。



告诉大家这个，是很多人问我，如果没设置JVM参数的话，怎么看系统用的默认JVM参数？



很简单，给你的JVM起码加一段打印gc日志的参数，就可以在这里看到他默认会给你的JVM进程分配多大的内存空间了。默认给的内存是很小的。



**3、一次GC的概要说明**



接着我们看GC日志中的如下一行：



0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K->512K(4608K), 0.0015734 secs] 4030K->574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]



这个就是概要说明了本次GC的执行情况，给大家讲一遍，大家就知道怎么回事了。



GC (Allocation Failure)，这个看字面意思就知道，为啥会发生一次GC呢？



很简单，因为看上图，要分配一个2MB的数组，结果Eden区内存不够了，所以就出现了“Allocation Failure”，也就是对象分配失败。



所以此时就要触发一次Young GC。



那这次GC是什么时候发生的呢？



很简单，看一个数字，“0.268”，这个意思就是你的系统运行以后过了多少秒发生了本次GC，比如这里就是大概系统运行之后过了大概200多毫秒，发生了本次GC。



ParNew: 4030K->512K(4608K), 0.0015734 secs



这个“ParNew”的意思，大家很明确了吧，我们触发的是年轻代的Young GC，所以是用我们指定的ParNew垃圾回收器执行GC的。



4030K->512K(4608K)



这个代表的意思是，年轻代可用空间是4608KB，也就是4.5MB，为啥是4.5MB呢？



大家看上图，Eden区是4MB，两个Survivor中只有一个是可以放存活对象的，另外一个是必须一致保持空闲的，所以他考虑年轻代的可用空间，就是Eden+1个Survivor的大小，也就是4.5MB。



然后4030K->512K，意思就是对年轻代执行了一次GC，GC之前都使用了4030KB了，但是GC之后只有512KB的对象是存活下来的。



0.0015734 secs，这个就是本次gc耗费的时间，看这里来说大概耗费了1.5ms，仅仅是回收3MB的对象而已。



4030K->574K(9728K), 0.0017518 secs，这段话指的是整个Java堆内存的情况



意思是整个Java堆内存是总可用空间9728KB（9.5MB），其实就是年轻代4.5MB+老年代5M，然后GC前整个Java堆内存里使用了4030KB，GC之后Java堆内存使用了574KB。



[Times: user=0.00 sys=0.00, real=0.00 secs] 



这个意思就是本次gc消耗的时间，大家可以看，这里最小单位是小数点之后两位，但是这里全部是0.00 secs，也就是说本次gc就耗费了几毫秒，所以从秒为单位来看，几乎是0。



相信大家看到这里，会有很多疑惑，感觉好像跟自己的认知有一些差距



不要紧，稍安勿躁，继续跟着看下去，接下来我们给大家图解一下这个GC发生的过程。





**4、图解GC执行过程**



第一个问题，看这行日志，ParNew: 4030K->512K(4608K), 0.0015734 secs



大家很奇怪，我们在GC之前，明明在Eden区里就放了3个1MB的数组，一共是3MB，也就是3072KB的对象，那么GC之前年轻代应该是使用了3072KB的内存啊，为啥是使用了4030KB的内存呢？



其实这个问题，大家先不要纠结，你只要明白两点：



1. 其实你创建的数组本身虽然是1MB，但是为了存储这个数组，JVM内置还会附带一些其他信息，所以每个数组实际占用的内存是大于1MB的；

   

2. 除了你自己创建的对象以外，可能还有一些你看不见的对象在Eden区里，至于这些看不见的未知对象是什么，后面我们有专门的工具可以分析堆内存快照，以后会带你看到这些对象是什么。



所以如下图所示，GC之前，三个数组和其他一些未知对象加起来，就是占据了4030KB的内存。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/55831900_1565591635.cn/txdocpic/0/202386e26debd8cb6ba3d85014975a8d/0)



接着你想要在Eden分配一个2MB的数组，此时肯定触发了“Allocation Failure“，对象分配失败，就触发了Young GC



然后ParNew执行垃圾回收，回收掉之前我们创建的三个数组，此时因为他们都没人引用了，一定是垃圾对象，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75850100_1565591635.cn/txdocpic/0/f80d812e9c67513fe7cb3335750271c9/0)



然后我们继续看gc日志，ParNew: 4030K->512K(4608K), 0.0015734 secs



gc回收之后，从4030KB内存使用降低到了512KB的内存使用



也就是说这次gc日志有512KB的对象存活了下来，从Eden区转移到了Survivor1区，其实我们可以把称呼改改，叫做Survivor From区，另外一个Survivor叫做Survivor To区，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95054300_1565591635.cn/txdocpic/0/1d3937919a9bcfc1c8da36a5f696bbc9/0)



其实结合GC日志就能看出来，这就是本次GC的全过程。





**5、GC过后的堆内存使用情况**



接着我们看下面的GC日志：



Heap

par new generation   total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)

 eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)

 from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)

 to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)

concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

这段日志是在JVM退出的时候打印出来的当前堆内存的使用情况，其实也很简单，一点点看一下，先看下面这段。



par new generation   total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)

 eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)

 from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)

 to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)



par new generation   total 4608K, used 2601K，这就是说“ParNew”垃圾回收器负责的年轻代总共有4608KB（4.5MB）可用内存，目前是使用了2601KB（2.5MB）。



那么大家思考一下，此时在JVM退出之前，为什么年轻代占用了2.5MB的内存？



很简单，在gc之后，我们这不是通过如下代码又分配了一个2MB的数组吗：byte[] array2 = new byte[2 * 1024 * 1024];



所以此时在Eden区中一定会有一个2MB的数组，也就是2048KB，然后上次gc之后在From Survivor区中存活了一个512KB的对象，大家也不知道是啥，先不用管他。



但是此时你疑惑了，2048KB + 512KB = 2560KB。



那为什么说年轻代使用了2601KB呢？



因为之前说过了每个数组他会额外占据一些内存来存放一些自己这个对象的元数据，所以你可以认为多出来的41KB可以是数组对象额外使用的内存空间。



如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/28073900_1565591636.cn/txdocpic/0/2cb984e97be2854f58042673c98bcfc8/0)



接着我们继续看GC日志：



 eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)

 from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)

 to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)

 

通过GC日志就能验证我们的推测是完全准确的，这里说的很清晰了，Eden区此时4MB的内存被使用了51%，就是因为有一个2MB的数组在里面。



然后From Survivor区，512KB是100%的使用率，此时被之前gc后存活下来的512KB的未知对象给占据了。



接着看GC日志：



concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

concurrent mark-sweep generation total 5120K, used 62K，这个很简单，就是说Concurrent Mark-Sweep垃圾回收器，也就是CMS垃圾回收器，管理的老年代内存空间一共是5MB，此时使用了62KB的空间，这个是啥你也先不用管了，可以先忽略不计，以后我们有内存分析工具了，你都能看到。





Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

上述两段日志也很简单，意思就是Metaspace元数据空间和Class空间，存放一些类信息、常量池之类的东西，此时他们的总容量，使用内存，等等。



**6、今日思考题**



昨天的思考题其实在今天的文章里就解答了，但是今天要给大家留一个小的思考题。



Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

对JDK 1.8以后的Metaspace和Classspace，大家去百度一下，这里都是存放什么内容的



然后gc日志中这里的used、capacity、committed、reserved几个字段，都表示什么含义？希望大家自己去探索一下。



**结合专栏的学习，同时自己探索一些小细节，是一件很有意思的事情，大家加油，有心得可以在评论区发出来，给其他人分享一下。**



**End**



# 045、动手实验：自己动手模拟出对象进入老年代的场景体验一下（上）

**1、前文回顾**



上一篇文章我们已经带着大家初步分析了一次Young GC的日志，相信大家已经完全掌握了如何结合GC日志去分析一次Young GC执行的全过程。



这篇文章我们接着之前的案例继续来做实验，动手体验一下对象是如何从新生代进入老年代的。



**2、动态年龄判定规则**



之前我们给大家总结过对象进入老年代的4个常见的时机：



1. 躲过15次gc，达到15岁高龄之后进入老年代；

   

2. 动态年龄判定规则，如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%，此时年龄n以上的对象会进入老年代，不一定要达到15岁

3. 如果一次Young GC后存活对象太多无法放入Survivor区，此时直接计入老年代

4. 大对象直接进入老年代



首先我们先通过代码给大家模拟出来最常见的一种进入老年代的情况，如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%，此时年龄n以上的对象会进入老年代，也就是所谓的动态年龄判定规则。



先来看看我们这次示例程序的JVM参数：



“-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log”



在这些参数里我们注意几点，新生代我们通过“-XX:NewSize”设置为10MB了



然后其中Eden区是8MB，每个Survivor区是1MB，Java堆总大小是20MB，老年代是10MB，大对象必须超过10MB才会直接进入老年代



但是我们通过“-XX:MaxTenuringThreshold=15”设置了，只要对象年龄达到15岁才会直接进入老年代。



一切准备就绪，先看看我们当前的内存分配情况，如下图，然后接下来我们开始来看看我们的示例代码。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79061700_1565687771.cn/txdocpic/0/d8686a936f5e7f9ec47ae789c4130adb/0)



**3、动态年龄判定规则的部分示例代码**



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/26821500_1565687874.png)



研究jvm运行过程，一定要一步一步调试代码，上面只是我们例子的部分代码，但是我们需要先运行部分代码，通过gc日志来分析这部分代码执行过后jvm中的对象分配情况。



**4、部分示例代码运行后产生的gc日志**



接着我们把上述示例代码以及我们给出的JVM参数配合起来运行，此时会看到如下的GC日志，接着我们就开始一步一步分析一下这部分代码运行后的gc日志。



0.297: [GC (Allocation Failure) 0.297: [ParNew: 7260K->715K(9216K), 0.0012641 secs] 7260K->715K(19456K), 0.0015046 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

Heap

par new generation   total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

 from space 1024K,  69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)

 to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

**5、部分代码的GC日志分析**



首先我们先看下述几行代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29923000_1565687907.png)



在这里连续创建了3个2MB的数组，最后还把局部变量array1设置为了null，所以此时的内存如下图所示：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98529100_1565687771.cn/txdocpic/0/1e0b38c7d17beca6237b1253b08ca193/0)



接着执行了这行代码：byte[] array2 = new byte[128 * 1024];。此时会在Eden区创建一个128KB的数组同时由array2变量来引用，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/18942300_1565687772.cn/txdocpic/0/d00208ff647f45585fd957f7cb89f214/0)



然后会执行下面的代码：byte[] array3 = new byte[2 * 1024 * 1024];



此时希望在Eden区再次分配一个2MB的数组，大家觉得可行吗？



因为此时Eden区里已经有3个2MB的数组和1个128KB的数组，大小都超过6MB了，Eden总共才8MB，此时是不可能让你创建2MB的数组的。



因此此时一定会触发一次Young GC，接着我们开始看GC日志。



ParNew: 7260K->715K(9216K), 0.0012641 secs



这行日志清晰表明了，在GC之前年轻代占用了7260KB的内存，这里大概就是6MB的3个数组 + 128KB的1个数组 + 几百MB的一些未知对象



如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41391100_1565687772.cn/txdocpic/0/c43eba93555df958f6ac16987e57983e/0)



接着看这里，7260K->715K(9216K)，一次Young GC过后，剩余的存活对象大概是715KB，大家还记得我们上篇文章分析的GC日志吗？



之前就说过大概年轻代刚开始会有512KB左右的未知对象，此时再加上我们自己的128KB的数组，大家想想，是不是差不多就是700KB？



接着看GC日志如下：



par new generation   total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

 from space 1024K,  69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)

 to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)





从上面的日志可以清晰看出，此时From Survivor区域被占据了69%的内存，大概就是700KB左右，这就是一次Young GC后存活下来的对象，他们都进入From Survivor区了。



同时Eden区域内被占据了26%的空间，大概就是2MB左右，这就是byte[] array3 = new byte[2 * 1024 * 1024];，这行代码在gc过后分配在Eden区域内的数组



如下图所示：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/62965500_1565687772.cn/txdocpic/0/757e92b3d6075f5fcb054da16adebc0b/0)



那么大家思考一个问题，现在Survivor From区里的那700kb的对象，是几岁呢？



**答案是：1岁**



他熬过一次gc，年龄就会增长1岁。而且此时Survivor区域总大小是1MB，此时Survivor区域中的存活对象已经有700KB了，绝对超过了50%。



**6、完善示例代码**





![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/25779300_1565687925.png)



接着我们把示例代码给完善一下，变成上述的样子，我们要触发出来第二次Young GC，然后看看Survivor区域内的动态年龄判定规则能否生效。



先看下面几行代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13548700_1565687925.png)



这几行代码运行过后，实际上会接着分配2个2MB的数组，然后再分配一个128KB的数组，最后是让array3变量指向null，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83986000_1565687772.cn/txdocpic/0/88eac16925186a4c368c4020a416fd19/0)



此时接着会运行下面的代码：byte[] array4 = new byte[2 * 1024 * 1024];



这个时候，大家会发现，Eden区如果要再次放一个2MB数组下去，是放不下的了，所以此时必然会触发一次Young GC。



大家使用上述的JVM参数运行这段程序会看到如下的GC日志：



0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K->713K(9216K), 0.0013103 secs] 7260K->713K(19456K), 0.0015501 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K->0K(9216K), 0.0036521 secs] 7017K->700K(19456K), 0.0037342 secs] [Times: user=0.06 sys=0.00, real=0.00 secs]

Heap

par new generation   total 9216K, used 2212K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)

 from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

 to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)

concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

好，接下来我们来分析这些GC日志。



**7、分析最终版的GC日志**



首先第一次GC的日志如下：



0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K->713K(9216K), 0.0013103 secs] 7260K->713K(19456K), 0.0015501 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 



这个过程刚才我们分析过了。



接着第二次GC的日志如下：



0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K->0K(9216K), 0.0036521 secs] 7017K->700K(19456K), 0.0037342 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] 



第二次触发Yuong GC，就是我们上述代码执行的时候，此时大家发现ParNew: 7017K->0K(9216K)



这行日志表明，这次GC过后，年轻代直接就没有对象了，也就是说没有任何存活对象，**你觉得可能吗？**



要是这么简单的想，绝对是侮辱自己的智商了，大家还记得array2这个变量一直引用着一个128KB的数组，他绝对是存活对象，还有那**500多KB的未知对象，此时都去哪里了呢？**



首先我们先看看上面的图，在Eden区里有3个2MB的数组和1个128KB的数组，这绝对是会被回收掉的，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8395600_1565687773.cn/txdocpic/0/b1e06cf7915fd62661c4f33c1612e42a/0)



接着其实此时会发现Survivor区域中的对象都是存活的，而且总大小超过50%了，而且年龄都是1岁



此时根据动态年龄判定规则：年龄1+年龄2+年龄n的对象总大小超过了Survivor区域的50%，年龄n以上的对象进入老年代。



当然这里的对象都是年龄1的，所以直接全部进入老年代了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/28665600_1565687773.cn/txdocpic/0/b92840561055fc074427d39a75875982/0)



大家看下面的日志可以确认这一点：



concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)



CMS管理的老年代，此时使用空间刚好是700KB，证明此时Survivor里的对象触发了动态年龄判定规则，虽然没有达到15岁，但是全部进入老年代了。



包括我们自己的那个array2变量一直引用的128KB的数组。



然后array4变量引用的那个2MB的数组，此时就会分配到Eden区域中，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/50264500_1565687773.cn/txdocpic/0/9ab9d2b1f0898f6d56fde59c75b83ba5/0)

此时大家看下面的日志：  



eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)



这里就说明Eden区当前就是有一个2MB的数组。



然后再看下面的日志：  



from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

 to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)



两个Survivor区域都是空的，因为之前存活的700KB的对象都进入老年代了，所以当然现在Survivor里都是空的了。

 

**8、今日思考题**



今天已经给大家分析了对象是如何通过动态年龄判定规则进入老年代的



其实之前我们通过大量的案例给大家演示过，如果你每次Young GC过后存活的对象太多进入Survivor，特别是超过了Survivor 50%的空间，很可能下次Young GC的时候就会让一些对象触发动态年龄判定规则进入老年代中。





今天给大家留的思考题很简单，**希望大家自己通过代码模拟出来对象达到15岁年龄之后自然进入老年代的场景**



**自己写代码，自己模拟，自己看GC日志，这样才能真正学好。**



**End**

# 046、动手实验：自己动手模拟出对象进入老年代的场景体验一下（下）

2019-08-15 07:00:00

**1、前文回顾**



上篇文章给大家分析了一下对象是如何通过动态年龄判定规则进入老年代的，同时让大家自己动手去模拟写代码体验一下对象达到15岁之后自动进入老年代的场景。



今天这篇文章我们就来给大家示范一下，对象是如何在Young GC过后因为放入下Survivor区域，就直接进入老年代了。



有了之前几篇文章的铺垫，今天的文章大家理解起来就简单多了。



**2、示例代码**

先来看看下面的示例代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/52983600_1565787699.png)



**3、GC日志**



然后我们使用之前的JVM参数来跑一下上面的程序，可以看到下面的GC日志：



0.421: [GC (Allocation Failure) 0.421: [ParNew: 7260K->573K(9216K), 0.0024098 secs] 7260K->2623K(19456K), 0.0026802 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

Heap

par new generation   total 9216K, used 2703K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

 from space 1024K,  55% used [0x00000000ff500000, 0x00000000ff58f570, 0x00000000ff600000)

 to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

 

**3、一步一图来分析GC日志**



接着我们一点点来分析一下，首先看如下几行代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/37120400_1565787699.png)



上面的代码中，首先分配了3个2MB的数组，然后最后让array1变量指向了第三个2MB数组



接着创建了一个128K的数组，但是确让array2指向了null，同时我们一直都知道，Eden区里会有500KB左右的未知对象



此时如下图所示：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47882800_1565787505.cn/txdocpic/0/f85ddee38d1cc5271bc89028cae340fa/0)



接着会执行如下代码：byte[] array3 = new byte[2 * 1024 * 1024];。此时想要在Eden区里再创建一个2MB的数组，肯定是不行的，所以此时必然触发一次Young GC。



先看如下日志：ParNew: 7260K->573K(9216K), 0.0024098 secs。



这里清晰说明了，本次GC过后，年轻代里就剩下了500多KB的对象



这是为什么呢？此时明明array1变量是引用了一个2MB的数组的啊！



其实道理很简单，大家可以想一下，这次GC的时候，会回收掉上图中的2个2MB的数组和1个128KB的数组，然后留下一个2MB的数组和1个未知的500KB的对象



如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/72865900_1565787505.cn/txdocpic/0/4e9c4fe5dcb763d6f1e1dfbdf52053d0/0)



那么此时剩下来的2MB的数组和500KB的未知对象能放入From Survivor区吗？



**答案是：不能**



因为Survivor区仅仅只有1MB。根据我们之前说过的规则，此时是不是要把这些存活对象全部放入老年代？



**答案：也不是**



大家看如下日志：  



eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)



首先Eden区内一定放入了一个新的2MB的数组，就是刚才最后想要分配的那个数组，由array3变量引用，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95684500_1565787505.cn/txdocpic/0/2d7bd6514c07cab484d4299ed697b71e/0)



其次，看下面的日志：



from space 1024K,  55% used [0x00000000ff500000, 0x00000000ff58f570, 0x00000000ff600000)



大家发现此时From Survivor区中有500KB的对象，其实就是那500KB的未知对象！



所以在这里并不是让2MB的数组和500KB的未知对象都进入老年代，而是把500KB的未知对象放入From Survivor区中！



从这里可以看到，很多细节，我们都是逐步给大家揭露开来的，之前有同学问我，如果对象放入下Survivor，是不是会有部分留在Survivor，部分进入老年代？



我当时没做明确的回答，而且之前的案例里从没提过这个细节，那是因为时机不到，当时大家不需要理解到这么细的程度。



但是现在结合GC日志，大家可以清晰的看到，在这种情况下，是会把部分对象放入Survivor区的。



此时如下图所示。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15552300_1565787506.cn/txdocpic/0/a54814c1c8b42f93915c6d23f3ee0431/0)



接着我们看如下日志： 



concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)



此时老年代里确有2MB的数组，因此可以认为，Young GC过后，发现存活下来的对象有2MB的数组和500KB的未知对象。



此时把500KB的未知对象放入Survivor中，然后2MB的数组直接放入老年代，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/34486000_1565787506.cn/txdocpic/0/2f6a040bfbbfe46c195d0797e28d4a92/0)



**4、本文总结**



本文篇幅不长，但是很好的给大家结合GC日志分析了Young GC过后存活对象放不下Survivor区域，从而部分对象会进入老年代的示例



在这里大家也明白了一个细节，在这种场景下，有部分对象会留在Survivor中，有部分对象会进入老年代的。



**5、今日思考题**



今天给大家留一个思考题，希望大家去写代码模拟一下，分配一个大对象，然后让大对象直接进入老年代，看看GC日志，是否大对象会直接进入老年代？

#   047、高级工程师的硬核技能：JVM的Full GC日志应该怎么看？

2019-08-16 07:00:00

**1、前文回顾**



之前两篇文章已经给大家分析清楚了对象是如何进入老年代的，接着我们就给大家演示一下，老年代的GC是如何触发的。



**2、示例代码**



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/71840000_1565842080.png)



**3、GC日志**



我们需要采用如下参数来运行上述程序：



“-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3145728 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log”



这里最关键一个参数，就是“-XX:PretenureSizeThreshold=3145728”



这个参数要设置大对象阈值为3MB，也就是超过3MB，就直接进入老年代。



运行之后会得到如下GC日志：



“0.308: [GC (Allocation Failure) 0.308: [ParNew (promotion failed): 7260K->7970K(9216K), 0.0048975 secs]0.314: [CMS: 8194K->6836K(10240K), 0.0049920 secs] 11356K->6836K(19456K), [Metaspace: 2776K->2776K(1056768K)], 0.0106074 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

Heap

par new generation   total 9216K, used 2130K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

 from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)

 to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 6836K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K”



**4、一步一图分析日志**



首先我们看如下代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/22260200_1565842097.png)



这行代码直接分配了一个4MB的大对象，此时这个对象会直接进入老年代，接着array1不再引用这个对象



此时如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/72239300_1565841991.cn/txdocpic/0/36e31945ff5f21fdcef2c67a2c11ddb0/0)



接着看下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12642600_1565842097.png)



连续分配了4个数组，其中3个是2MB的数组，1个是128KB的数组，如下图所示，全部会进入Eden区域中。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92926300_1565841991.cn/txdocpic/0/47440ac5b146737b5c1aa7f5d4d48e4e/0)



接着会执行如下代码：byte[] array6 = new byte[2 * 1024 * 1024];。此时还能放得下2MB的对象吗？不可能了，因为Eden区已经放不下了。因此此时会直接触发一次Young GC。



我们看下面的GC日志：ParNew (promotion failed): 7260K->7970K(9216K), 0.0048975 secs



这行日志显示了，Eden区原来是有7000多KB的对象，但是回收之后发现一个都回收不掉，因为上述几个数组都被变量引用了。



所以此时大家都知道，一定会直接把这些对象放入到老年代里去，但是此时老年代里已经有一个4MB的数组了，还能放的下3个2MB的数组和1个128KB的数组吗？



明显是不行的，此时一定会超过老年代的10MB大小。



所以此时我们看gc日志：



[CMS: 8194K->6836K(10240K), 0.0049920 secs] 11356K->6836K(19456K), [Metaspace: 2776K->2776K(1056768K)], 0.0106074 secs]



大家可以清晰看到，此时执行了CMS垃圾回收器的Full GC，我们之前讲过Full GC其实就是会对老年代进行Old GC，同时一般会跟一次Young GC关联，还会触发一次元数据区（永久代）的GC。



在CMS Full GC之前，就已经触发过Young GC了，此时大家可以看到此时Young GC就已经有了，接着就是执行针对老年代的Old GC，也就是如下日志：



CMS: 8194K->6836K(10240K), 0.0049920 secs



这里看到老年代从8MB左右的对象占用，变成了6MB左右的对象占用，这是怎么个过程呢？



很简单，一定是在Young GC之后，先把2个2MB的数组放入了老年代，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15466800_1565841992.cn/txdocpic/0/6688854514b2a0f8f2b3509e2e4673c2/0)



此时要继续放1个2MB的数组和1个128KB的数组到老年代，一定会放不下，所以此时就会触发CMS的Full GC



然后此时就会回收掉其中的一个4MB的数组，因为他已经没人引用了，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/48350700_1565841992.cn/txdocpic/0/e0eb5ff0c6340f24dae03df522481fc0/0)



接着放入进去1个2MB的数组和1个128KB的数组，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68094100_1565841992.cn/txdocpic/0/f48166b71918eed166ab2452c75ce525/0)



所以大家再看CMS的垃圾回收日志：CMS: 8194K->6836K(10240K), 0.0049920 secs，他是从回收前的8MB变成了6MB，就是上图所示。



最后在CMS Full GC执行完毕之后，其实年轻代的对象都进入了老年代，此时最后一行代码要在年轻代分配2MB的数组就可以成功了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87078800_1565841992.cn/txdocpic/0/b19f81ed13cf8ac28cc74e7e75285be0/0)



**5、本文总结**



本文给大家又讲解了一个触发老年代GC的案例，就是年轻代存活的对象太多放不下老年代了，此时就会触发CMS的Full GC，大家可以清晰的看到全过程。



**6、今日思考题**



今天留给大家的思考题，就是让大家可以自己写代码模拟出来另外几种老年代GC的场景



其中一个就是在触发Young GC之前，可能老年代可用空间小于了历次Young GC后升入老年代的对象的平均大小，就会在Young GC之前，提前触发Full GC。



还有一个，就是老年代被使用率达到了92%的阈值，也会触发Full GC。



其实说实话，很多场景并不太容易用代码模拟出来，但是大家还是尽量尝试一下，因为这样可以增强大家对这里原理的一个理解。



# 048、第7周作业：自己尝试着分析一把你们线上系统的JVM GC日志

2019-08-17 07:00:00

本周作业很简单，大家已经完全结合JVM的GC日志搞明白了到底应该如何去结合GC日志去分析自己的系统平时的GC情况



而且结合GC日志也完全搞明白了平时Young GC的触发时机和原理，对象升入老年代的原理，Full GC的触发时机和原理，相当于从实操层面对之前所学内容进行了一个印证。



所以本周就是希望大家去看看自己线上系统的GC日志，然后分析分析每次GC的触发时机，以及每次GC之后的对象变化情况。




# 049、第7周答疑：本周问题答疑汇总

2019-08-18 09:02:02

第7周学员答疑汇总



**学员总结：**

就着这篇作业，总结一下。我理解的优化思路： 项目上线初期： 

1、上线前，根据预期的并发量、平均每个任务的内存需求大小等，然后评估需要使用几台机器来承载，每台机器需要什么样的配置。 



2、根据系统的任务处理速度，评估内存使用情况，然后合理分配Eden、Survivor，老年代的内存大小。 



总体原则就是，让短命对象在YoungGC就被回收，不要进入老年代，长期存活的对象，尽早进入老年代，不要在新生代复制来复制去。对系统响应时间敏感且内存需求大的，建议采用G1回收器



如何合理分配各个区域: 

1. 根据内存增速来评估多久进行Young GC 
2. 根据每次Young GC的存活，评估一下Survivor区的大小设置是否合理 
3. 评估多久进行一次FullGC，产生的STW，是否可以接受？ 



公司的运营很牛，过了一段时间，系统负载增加了10倍，100倍： 

方案1：增加服务器数量 根据系统负载的增比，同比增加机器数量，机器配置，和jvm的配置可以保持不变。 



方案2：使用更高配置的机器 更高的配置，意味着更快速的处理速度和更大的内存。响应时间敏感且内存需求大的使用G1回收器 这时候需要和‘项目上线初期’一样，合理的使用配置和分配内存



**回答**：理解完全正确



**问题：**

老师，如果在做定时任务数据处理的时候，在一个方法里面通过多线程的方式来处理数据库中的数据，在其他线程没有结束之前，其中一个线程提前处理完了，那该线程所new的对象会变成垃圾对象吗？还是说也要等到其他线程都处理完了才会变成垃圾对象？



**回答**：他自己引用的对象，他自己线程销毁了，自然那些对象都是垃圾了，如果触发gc就会被回收



**问题：**

在main方法中周期性执行loadReplicasFromDisk方法，文中说，loadReplicasFromDisk方法执行完毕之后，一旦方法结束，loadReplicasFromDisk方法的栈帧就会出栈，就没人引用ReplicaManager对象了。



我的疑问是为什么loadReplicasFromDisk执行完毕就会出栈呢，不应该是一直调用这个loadReplicasFromDisk方法，对应的一直有新的loadReplicasFromDisk方法的栈帧入栈



除非while true结束了，也就是main方法结束了，各个栈帧才会按照后进先出的顺序陆续出栈吗？栈帧A出栈后，才会回收栈帧A的局部变量表，这个时候才可以说没人引用栈帧A创建的那个ReplicaManager对象。



**回答：**一次方法调用就得入栈一次，一次方法调用结束了就会出栈，不是说一个方法调用多次，他就一直在栈里的





**学员总结：**

我们线上的系统 young gc 和 full gc 都比较频繁，但是业务层面并不要求实时性很大 



学完一系列文章以后 偷偷的在服务器上加上了 parnew cms收集器 然后差不多7分钟一次young gc 然后几个小时一次full gc 但是贷款业务真的对延时不在乎



**回答**：非常好，无论在乎不在乎，你自己优化一下，以后面试和工作都需要用到这个jvm优化技能





**问题：**

老师， 我想问一下， 当一次MinorGC时 发现应该进行 FullGC， 此时就进行FullGC。 今天的我课中说到，在并发清理的过程中可能会有Minor 送来的新对象在老年代放不下 ，就会出发 Concurrent Mode Failure 错误。 



我想问的是： 在第一次的Minor 触发FullGC时， Minor 送来的那批对象是怎么处理的呢？ 



是先卡一会儿， 等 FullGC的并发清理阶段 有了那么大的空间后， 这次的Minor对象就放下去， 然后这次MinorGC结束。 此时 FullGC依旧在处理并发清理阶段， 这个时候若老年代进来的对象大于可用的连续内存， 所以就 换成 Serial Old 去 STW 单线程的 GC 全部的老年代， 然后在把这批对象放进去是吗？

 

**回答**：是的，你理解没错



**学员总结：**

文章写的太好了，刚买几天，太精彩了，这个周末忍不住一口气把42章全看完了，基本上都理解了，就是东西太多有点记不住，还得从新慢慢看一下总结一波才行，总算是理解jvm这东西了



之前看书看的晕头晕脑得，老师讲的非常通俗易懂，再加上这么案例的讲解，以前一直认为jvm优化有啥用呢，工作中根本用不到，看完案例才知道这个东西的重要性，感谢老师！



**回答：**多谢支持，继续加油





**问题：**

有个疑问：每次1w条数据需要处理10秒，那么每分钟也就处理6次数据，那么新生代就会积压94次数据，即积压940M（94*10M）数据未处理。也就是说1分钟把新生代填满，940M存活。而不是文中说的200M存活对象啊。



如果老师指的10秒的处理时间是单核处理速度，那每分钟4核也就处理240M还剩760M存活呢？



**回答**：不是的，1分钟来计算，填满之后，会垃圾回收，大部分对象会被回收掉，然后遗留200MB左右的数据是存活的





**问题：**

老师，在你的例子中，把s区扩大到200M，刚好占满s区，然后就只有很少的对象进入老年代。



我有个疑问，都占到s区的100%了，难道不会触发年龄担保机制么？



**回答**：对的，这里我只是做一个示例，其实最好让S增加到400左右，避免触发动态年龄判定机制





**问题：**

我有两个问题: 

1.基于动态年龄来判断的时候，如果年龄1-5的对象占有s区的50%，那么是＞=5还是＞5的对象会进入老年代？这里是否会有＝号？ 



2.按照动态年龄判断的规则，是不是每次minor gc后，都保证s区存活的对象＜=s区大小的50%?(因为根据年龄判断，50%以外的那部分直接进入老年代了，所以每次minor gc后s区最多剩下50%)

 

**回答：**

1、>=5

2、对的，你最好是让存活对象小于S的50%





**问题：**

这里我有个误区，那就是动态年龄的判断并不伴随minor gc，他应该拥有属于自己的触发时机(何时会触发？)



那我是不是可以这么理解：基于动态年龄的机制是随时有可能会触发的(那么触发的时机是什么？)



这时候，s区剩余空间一定是＜=50％。 但是minor gc之后，s区的存活对象是有可能＞50％的，只有等到下一次动态年龄判断触发时，又会下降到50％以及以下。



**回答：**每次Minor GC过后就会触发动态年龄判定机制





**学员总结：**

参数设置： 参数设置了堆大小为10M，指定了新生代5M ，那么老年代也是5M，因为SurvivorRatio=8，所以Eden区4M，S1、S2分别是0.5M。 



GC前的空间分配及判断： 先分配了3次1M对象进入Eden区，再次分配2M时，Eden区放不下了，准备进行Young GC，此时需要判断是否需要空间担保，5M的老年代空余>3M的新生代已用空间，不需要空间担保。直接进行Young GC。 



执行Young GC： 遍历所有线程栈中的和静态的引用变量，进行GCRoots追踪，发现新生代的Eden和S1区没有对象存活，不需要进行对象的拷贝，直接清空Eden区和S1区。此时YoungGC执行完成。



**回答**：对的





**问题：**

问题1：案例中的s区大小为200m，刚好容得下每次minor gc后存活对象的大小，但是根据动态年龄判断的规则



因此这里的s区大小是否应该设置为400m，才能更大程度的避免对象在一次minor gc后进入老年代？（也就是调整eden:s:s=6:2:2）但是这样好像又导致了更加频繁的minor gc 



问题2：文章中在提及动态年龄判断规则的时候，说的是同龄对象占有s区大小>50%，但是其实应该是年龄1-N的对象占有s区大小>50%吧，然后年龄>=N的对象会直接进入老年代



**回答：**

1、那个是示例，其实S可以搞的再大点，让存活对象小于S区的50% 



2、对的，后面有多处说明，就是你说的这个意思





**学员总结：**

新生代初始5M，最大5M，堆初始10M，总大小10M。Eden和Survivor区比例 8:1:1，即 4M:0.5M:0.5M，对象超过10M直接在老年代。 



垃圾回收算法: 新生代 ParNew + 老年代 CMS  

1. 第一次分配 1M 第二次第三次第四次, 失去指向, 存在3M垃圾, Eden还剩 1M可用空间

2. 分配 array2 为 2M Eden区空间不够

3. 需要对新生代进行youngGC

4. 回收垃圾大小为3M 和老年代剩余连续空间大小作比较 3M < 5 M, 不需要空间担保和Full GC

5. 新生代进行垃圾回收 STW

6. 将array2 放到 Eden区

   

**回答**：总结的很好





**学员评价：**

读完这节，以及本周的安排 我意识到老师的课程设计是我见过的最佳之一。 为什么这么说呢？ 



因为课程不仅由浅入深 一步一图，更是考虑到了 学而时习之 周期性回顾的重要性，节奏比速度更重要。 



可能有些老师会忽略一件事：就是以为学生的精力都放在他这一门课上，其实不是的



以我为例，我同时在学jvm、算法、石杉的架构(此处硬广)，精力那是要平衡分配的，如果某一门课一味求快 求多，可能最终是学完就忘，欲速则不达。



**回答：**是的，其实专栏类的东西，最好的就是在全流程里贯穿核心的知识体系，反复强化，不停的强化，适当的复习和总结，最终一个长周期后，彻底掌握这个技术的实战



**学员总结：**

整个堆的情况 Eden : 4m Survivor : 0.5m old : 5M 



正常来说的过程应该是这样的： 开始分配3m的对象，有2m是垃圾对象，此时分配2m的对象时发现eden空间不够， 根据空间担保规则，老年代5m大于新生代已占用内存3m，所以放心MinorGC， GC完了之后，新生代还有1M对象存活(array1引用)



此时发现survivor的一个 区域0.5m不足以放下存活的对象会将1m对象转移到老年代，接着新生代开始分配2m的对象 



对象分配完毕之后整个堆的情况：新生代2m，老年代1m。 事实上，经过我多次测试，运行这样的代码会产生2次MinorGC和一次Full GC。



这个结果可能根据每个人的电脑不一样也会产生误差(也有可能是在IDEA运行的原因)。 我的JDK版本为1.8.0.201 



另外根据GC日志分析，其实他计算的不单单是我们程序使用的内存，可能jvm本身使用的内存也计算上了。 



虽然我们heap大小设置为10m,但是GC日志中只有9728k，并不是10m，所以我认为在分析GC的时候，还是无法精确分析到每一个细节的，我们只能大致上来猜测GC的行为。

 



**学员思考题回答：**

深夜打卡。 

1、老年代5m空间大于3m，可以直接YoungGC，3M垃圾直接回收，Eden区清空，S1，S2也清空。但实际情况，根据日志，from space是占满了。 



2、根据日志，发现确实进行了一次Young GC。具体日志：0.116: [GC (Allocation Failure) 0.116: [ParNew: 3964K->512K(4608K), 0.0009533 secs] 3964K->549K(9728K), 0.0010680 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 



其中Allocation Failure应该表明了GC的原因（连续内存空间不足，内存空间分配失败），和具体的回收情况，可以看到内存空间被释放出来了，但却不是全部释放（可以看到原本的空间是3964K，而不是就三个数组的3072K）

 

**回答：**非常好



**问题：**

老师，请教一个问题，就是survivor区使用达到100%，按之前的规则一批对象占用survivor区超过50%，年龄大于等于这批对象的就进入老年代，好像这次gc没有触发，我要怎样才能模拟出这个规则的触发？

 

**回答：**他这一次达到Survivor 100%不会立马触发动态年龄判定机制，需要下一次GC的时候看你还是超过Survivor 50%，才会进行动态年龄判定，往后看，会有演示的



**问题：**

Java8 取消了PermGen。取而代之的是MetaSpace，方法区在java8以后移至MetaSpace。 Jdk8开始把类的元数据放到本地内存（native heap），称之为MetaSpace



理论上本地内存剩余多少，MetaSpace就有多大，当然我们也不可能无限制的增大MetaSpace，需要用-XX:MaxMetaSpaceSize来指定MetaSpace区域大小。 



关于used capacity commited 和reserved，在stackoverflow找到个比较靠谱的答案，我尝试翻译一下： MetaSpace由一个或多个Virtual Space（虚拟空间）组成。虚拟空间是操作系统的连续存储空间，虚拟空间是按需分配的。当被分配时，虚拟空间会向操作系统预留（reserve）空间，但还没有被提交（committed）。



MetaSpace的预留空间（reserved）是全部虚拟空间的大小。 虚拟空间的最小分配单元是MetaChunk（也可以说是Chunk）。



当新的Chunk被分配至虚拟空间时，与Chunk相关的内存空间被提交了（committed）。MetaSpace的committed指的是所有Chunk占有的空间。 



每个Chunk占据空间不同，当一个类加载器（Class Loader）被gc时，所有与之关联的Chunk被释放（freed）。这些被释放的Chunk被维护在一个全局的释放数组里。



MetaSpace的capacity指的是所有未被释放的Chunk占据的空间。 这么看gc日志发现自己committed是4864K，capacity4486K。有一部分的Chunk已经被释放了，代表有类加载器被回收了



可以这么理解吗老师？

 

附上原文链接：

https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout 

有一个示意图 有助于理解



**回答：**非常好，标准答案，优秀



**学员总结：**

这周实际操作的课程，只有周末才有时间试试。 懂了原理，会看 GC 日志，感觉这个垃圾回收的原理，基本没问题了。

 

**回答：**对的，吃透这些，jvm运行原理基本没问题了





**问题：**

可是minor gc不是会产生stw吗？ 那么stw是允许仅所有的垃圾回收线程运行？



即使是两个不同的正在运行的垃圾收集器，他们也是可以同时运行的，只不过工作线程无法一起运行罢了。请问是这样吗？



**回答**：stw，是说停止所有工作线程，不是垃圾回收线程





**问题：**

文中第二次发生gc的时候，清除了eden区域的对象，并判断from survivor的一岁的对象大于50%。然后准备将survivor所有对象移动至老年代。 然后第三次gc的时候，将survivor全部对象移动至老年代



但是为什么此时GC日志写的是（Allocation Failure）分配失败呢？



并且新生代那7017K的对象是哪里来的呢？不是前面一次gc后只剩下713K吗？期间就算有新对象生成也应该只有array4的2M对象？



求老师解惑



**回答：**

1、Allocation Failure，意思就是分配对象的时候内存不够触发了gc 



2、7000kb，不是文章里解释了吗，有一些是对象头，还有一些是未知对象





**问题：**

关于动态年龄判断的疑问：ParNew: 7017K->0K ，这次Young GC 没有Eden区的对象存活，此时Survivor区的存活对象年龄+1 变为2岁，按照文中的动态年龄判断逻辑不是应该“大于2岁”的对象进入老年代么？ 



如果按照专栏25讲描述的动态年龄判断逻辑倒是可以解释的通（一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代）

 

**回答：**对的，他就是同龄对象超过了Survivor的50%，所以进入老年代了





**问题：**

请问老师后续规划的 mysql 实战专栏，会包括分库分表部分吗？



**回答：**那是肯定的





**问题：**

老师，您好，请问，是不是不仅仅新生代eden区满了，会回收新生代，有时候，如果G1觉得region的个数可以满足200ms的时候，也会回收？那回收的是新生代吗？还是mixgc

 

**回答：**是的，g1感觉可以回收了也会回收，通常是新生代





**问题：**

老师，我接着上一条的评论发文。可能我说的不够清晰



我想问的是 对象移动至老年代的时候发生了两次GC。第一次GC是7260k--713k。然后紧接着又发生了一次GC是7017k--0k。



第一次GC是因为为array4分配内存的时候分配失败发生了一次gc。但是为什么紧接着又发生了一次GC？并且原因也是分配失败，明明堆内存此时只占用713K，是分配未知对象的时候分配失败了吗？而且这将近7M的对象都是未知对象吗？就算此时array4分配内存也才占用2M而已

 

**回答：**同学，你仔细看下文章，文章后面对代码做了改动的，他是两次触发了gc





**问题：**

G1的垃圾回收器，存不存在类似 P+CMS频繁的回收进而导致系统变慢？



看文章资料，G1变为单线程是因为region内存不够导致的。如果频繁的回收，那么内存应该是足够的，并且标记速度也很快。



**回答：**

g1可能会频繁回收，但是他每次回收时间可控，所以不会对系统造成太大影响





**学员思考题回答：**

代码改写如下： 

1、不改变年轻代的大小，改变SurvivorRatio=4，这样Eden区6912K，两个Survivor有1664K，避免一开始未知对象+128K超过S区的50%，触发动态年龄计算。 



2、代码如下： 

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/23439000_1566089777.png)



实际运行中，发现第15次gc后，日志输出：

[ParNew: 7223K->0K(8576K), 0.0011635 secs] concurrent mark-sweep generation total 10240K, used 675K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) 



**证明15岁之后，array2进入老年代。**

 

回答：很棒，优秀回答



# 050、动手实验：使用 jstat 摸清线上系统的JVM运行状况

2019-08-19 07:00:00

**1、前文回顾**

上周我们已经通过带着大家分析GC日志的方式，给大家重新回顾了一遍JVM的整体运行原理，包括对象优先在Eden区分配，Young GC的触发时机和执行过程，对象进入老年代的时机，Full GC的触发时机和执行过程，相信大家通过GC日志可以把JVM整体运行原理理解的更加的深入而且透彻。



本周我们就要带着大家开始用一个工具来分析运行中的系统，他的对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。





**2、功能强大的jstat**



平时我们对运行中的系统，如果要检查他的JVM的整体运行情况，比较实用的工具之一，就是jstat



他可以轻易的让你看到当前运行中的系统，他的JVM内的Eden、Survivor、老年代的内存使用情况，还有Young GC和Full gC的执行次数以及耗时。



通过这些指标，我们可以轻松的分析出当前系统的运行情况，判断当前系统的内存使用压力以及GC压力，还有就是内存分配是否合理。下面我们就一点点来看看这个jstat工具的使用。



**3、jstat -gc PID**



首先第一个命令，就是在你们的生产机器linux上，找出你们的Java进程的PID，这个大家自行百度一下即可，用jps命令就可以看到。



接着就针对我们的Java进程执行：jstat -gc PID。这就可以看到这个Java进程（其实本质就是一个JVM）的内存和GC情况了。



运行这个命令之后会看到如下列，给大家解释一下：



1. S0C：这是From Survivor区的大小

   

2. S1C：这是To Survivor区的大小

3. S0U：这是From Survivor区当前使用的内存大小

4. S1U：这是To Survivor区当前使用的内存大小

5. EC：这是Eden区的大小

6. EU：这是Eden区当前使用的内存大小

7. OC：这是老年代的大小

8. OU：这是老年代当前使用的内存大小

9. MC：这是方法区（永久代、元数据区）的大小

10. MU：这是方法区（永久代、元数据区）的当前使用的内存大小

11. YGC：这是系统运行迄今为止的Young GC次数

12. YGCT：这是Young GC的耗时

13. FGC：这是系统运行迄今为止的Full GC次数

14. FGCT：这是Full GC的耗时

15. GCT：这是所有GC的总耗时



不知道大家发现什么没有，其实这些指标都是非常实用的jvm gc分析指标，接下来我们一步一步告诉大家该怎么使用这个工具。



另外给大家说句题外话，接下来我们有两篇文章会给大家一段模拟出生产案例的程序，然后在windows本地电脑上运行，然后我们会带着大家用jstat工具去分析他的jvm运行情况。



但是jstat工具本身如果要在windows上运行需要使用专门针对windows的版本，所以后面的文章我们会教会大家怎么在windows上使用jstat工具的。



**4、其他的jstat命令**



除了上面的jstat -gc命令是最常用的以外，他还有一些命令可以看到更多详细的信息，如下所示：



1. jstat -gccapacity PID：堆内存分析

   

2. jstat -gcnew PID：年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄

3. jstat -gcnewcapacity PID：年轻代内存分析

4. jstat -gcold PID：老年代GC分析

5. jstat -gcoldcapacity PID：老年代内存分析

6. jstat -gcmetacapacity PID：元数据区内存分析



大家可以后面自己有机会尝试尝试这些命令，多看看，还是挺好玩儿的，但是其实最完整、最常用、最实用的还是jstat -gc命令，基本足够我们日常分析jvm的运行情况了。



**5、到底该如何使用jstat工具？**



接着教教大家一些jstat工具使用的小技巧，先明确一下，我们分析线上的JVM进程，最想要知道的信息有哪些？



包括如下：新生代对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。



只要知道了这些信息，其实我们就可以结合之前几周的文章分析过的JVMGC优化的方法，合理分配内存空间，尽可能让对象留在年轻代不进入老年代，避免发生频繁的Full GC。这就是对JVM最好的性能优化了！



因此我们一点点分析，通过jstat工具如何得到上述信息。





**6、新生代对象增长的速率**



如果认真看过之前几周文章的同学，应该都知道，我们平时对jvm第一个要了解的事儿，就是随着系统运行，每秒钟会在年轻代的Eden区分配多少对象。



要分析这东西，你只要在线上linux机器上运行如下命令：jstat -gc PID 1000 10



这行命令，他的意思就是每隔1秒钟更新出来最新的一行jstat统计信息，一共执行10次jstat统计



通过这个命令，你可以非常灵活的对线上机器通过固定频率输出统计信息，观察每隔一段时间的jvm中的Eden区对象占用变化。



比如给大家举个例子，执行这个命令之后，第一秒先显示出来Eden区使用了200MB内存，第二秒显示出来的那行统计信息里，发信Eden区使用了205MB内存，第三秒显示出来的那行统计信息里，发现Eden区使用了209MB内存，以此类推。



此时你可以轻易的推断出来，这个系统大概每秒钟会新增5MB左右的对象。



而且这里大家可以根据自己系统的情况灵活多变的使用，比如你们系统负载很低，不一定每秒都有请求，那么可以把上面的1秒钟调整为1分钟，甚至10分钟，去看你们系统每隔1分钟或者10分钟大概增长多少对象。



还有就是一般系统都有高峰和日常两种状态，比如系统高峰期用的人很多，此时你就应该在系统高峰期去用上述命令看看高峰期的对象增长速率。然后你再得在非高峰的日常时间段内看看对象的增长速率。



按照上述思路，基本上你可以对线上系统的高峰和日常两个时间段内的对象增长速率有很清晰的了解。





**7、Young GC的触发频率和每次耗时**



接着下一步我们就想知道大概多久会触发一次Young GC，以及每次Young GC的耗时了。



其实多久触发一次Young GC就很容易推测出来了，因为系统高峰和日常时候的对象增长速率你都知道了，那么非常简单就可以推测出来高峰期多久发生一次Young GC，日常期多久发生一次Young GC。



比如你Eden区有800MB内存，那么发现高峰期每秒新增5MB对象，大概高峰期就是3分钟会触发一次Young GC。日常期每秒新增0.5MB对象，那么日常期大概需要半个小时才会触发一次Young GC。



那么每次Young GC的平均耗时呢？



简单，之前给大家说过，jstat会告诉你迄今为止系统已经发生了多少次Young GC以及这些Young GC的总耗时。



比如系统运行24小时后共发生了260次Young GC，总耗时为20s。那么平均下来每次Young GC大概就耗时几十毫秒的时间。



你大概就知道每次Young GC的时候会导致系统停顿几十毫秒。





**8、每次Young GC后有多少对象是存活和进入老年代**



接着我们想要知道，每次Young GC后有多少对象会存活下来，以及有多少对象会进入老年代。



其实每次Young GC过后有多少对象会存活下来，这个没法直接看出来，但是有办法可以大致推测出来。



之前我们已经推算出来高峰期的时候多久发生一次Young GC，比如3分钟会有一次Young GC



那么此时我们可以执行下述jstat命令：jstat -gc PID 180000 10。这就相当于是让他每隔三分钟执行一次统计，连续执行10次。



此时大家可以观察一下，每隔三分钟之后发生了一次Young GC，此时Eden、Survivor、老年代的对象变化。



正常来说，Eden区肯定会在几乎放满之后重新变得里面对象很少，比如800MB的空间就使用了几十MB。Survivor区肯定会放入一些存活对象，老年代可能会增长一些对象占用。所以这里的关键，就是观察老年代的对象增长速率。



从一个正常的角度来看，老年代的对象是不太可能不停的快速增长的，因为普通的系统其实没那么多长期存活的对象。如果你发现比如每次Young GC过后，老年代对象都要增长几十MB，那很有可能就是你一次Young GC过后存活对象太多了。



存活对象太多，可能导致放入Survivor区域之后触发了动态年龄判定规则进入老年代，也可能是Survivor区域放不下了，所以大部分存活对象进入老年代。



最常见的就是这种情况。如果你的老年代每次在Young GC过后就新增几百KB，或者几MB的对象，这个还算情有可缘，但是如果老年代对象快速增长，那一定是不正常的。



所以通过上述观察策略，你就可以知道每次Young GC过后多少对象是存活的，实际上Survivor区域里的和进入老年代的对象，都是存活的。



你也可以知道老年代对象的增长速率，比如每隔3分钟一次Young GC，每次会有50MB对象进入老年代，这就是年代对象的增长速率，每隔3分钟增长50MB。





**9、Full GC的触发时机和耗时**



只要知道了老年代对象的增长速率，那么Full GC的触发时机就很清晰了，比如老年代总共有800MB的内存，每隔3分钟新增50MB对象，那么大概每小时就会触发一次Full GC。



然后可以看到jstat打印出来的系统运行起劲为止的Full GC次数以及总耗时，比如一共执行了10次Full GC，共耗时30s，每次Full GC大概就是需要耗费3s左右。





**10、本文总结**



通过本文对jstat命令的介绍，以及结合我们之前学习过的jvm运行原理，我们教给了大家这套分析线上系统jvm运行情况的技巧



大家完全可以灵活运行jstat这个实用的工具，轻而易举的掌控到线上jvm运行的详细情况，然后针对jvm的具体运行情况去进行有针对性的优化。



另外，很多同学会问了：老师，其实有很多其他的工具也特别好用啊，比如JConsole、VisualVM等可视化的监控工具，还有其他一些开源的监控系统，都是可视化的。



针对这个问题，其实我也没说不可以用那些可视化工具，下篇文章我们就要给大家介绍更多的可视化监控JVM的工具。



但是有一点要告诉大家，一个优秀、合格的工程师，他一定是可以非常灵活的运用各种命令行工具，在命令行就搞定一切的。



所以jstat作为一个最简单易用、高效实用的命令行jvm监控工具，其实绝对是值得大家首先掌握他的。因为每个人的公司情况不一样，万一你公司不支持你用各种可视化工具呢？那你就必须从最“low”最原始的命令行工具开始，快速上手实用，定位问题。



而且其实你理解了本文的思想之后，你用其他任何工具，都能轻松的把线上jvm的运行情况通过工具提供的数据分析清楚。





**11、今日思考题**

今天交给大家一个练习题，就是在自己线上负责的系统使用jstat命令，按照上述我们介绍的思路，把以下jvm运行情况全部摸出来：



- 新生代对象增长的速率
- Young GC的触发频率
- Young GC的耗时
- 每次Young GC后有多少对象是存活下来的
- 每次Young GC过后有多少对象进入了老年代
- 老年代对象增长的速率
- Full GC的触发频率
- Full GC的耗时



如果有分析心得的，可以发评论区里，跟其他同学一起分享，如果在落地过程中遇到任何问题，也欢迎大家在评论区踊跃发言提问。



# 051、动手实验：使用jmap和jhat摸清线上系统的对象分布

2019-08-20 07:00:00

**1、前文总结**

上一篇文章我们给大家介绍了一个平时工作中非常实用的工具，jstat。



用jstat就可以非常轻松便捷的了解到线上系统的运行状况，从新对象增速、Young GC触发频率以及耗时，再到对象进入老年代的增速以及Full GC触发频率以及耗时，可以完全摸清楚线上系统的JVM运行情况，为可能要做的优化做准备。



本文我们继续给大家介绍两个平时工作里非常实用的工具，jmap和jhat。



这两个工具可以帮助我们观察线上JVM中的对象分布，了解到你的系统平时运行过程中，到底哪些对象占据了主角位置，他们占据了多少内存空间，让你对你的系统运行有更加细致的了解。



**2、使用jmap了解系统运行时的内存区域**

其实如果单单只是要了解JVM的运行状况，然后去进行JVM GC优化，通常来说jstat就完全够用了



但是有的时候可能我们会发现JVM新增对象的速度很快，然后就想要去看看，**到底什么对象占据了那么多的内存。**



如果发现有的对象在代码中可以优化一下创建的时机，避免那种对象对内存占用过大，那么也许甚至可以去反过来优化一下代码。



当然，其实如果不是出现OOM那种极端情况，也并没有那么大的必要去着急优化代码。



但是这篇文章我们来学习一下如何了解线上系统jvm中的对象分布，也是有好处的，比如之前我们在上周的案例中就发现年轻代里总是有500kb左右的未知对象，大家是不是会很好奇？如果可以看到jvm中这500kb的对象到底是什么就好了，所以学习一下这个技巧是有用的。



先看一个命令：**jmap -heap PID**



这个命令可以打印出来一系列的信息，我们就不长篇大论的粘贴出来具体的信息了，因为内容篇幅太大了，其实也没太大意义，因为里面的东西大家自己看字面意思都能看懂的。我们就简单给大家说一下这里会打印出来什么东西。



大致来说，这个信息会打印出来堆内存相关的一些参数设置，然后就是当前堆内存里的一些基本各个区域的情况



比如Eden区总容量、已经使用的容量、剩余的空间容量，两个Survivor区的总容量、已经使用的容量和剩余的空间容量，老年代的总容量、已经使用的容量和剩余的容量。



但是这些信息大家会想了，其实jstat已经有了啊！对的，所以一般不会用jmap去看这些信息，毕竟他信息还没jstat全呢，因为没有gc相关的统计。



**3、使用jmap了解系统运行时的对象分布**

其实jmap命令比较有用的一个使用方式，是如下的：

**jmap -histo PID**



这个命令会打印出来类似下面的信息：



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/35587500_1566209316.png)



这个就很有意思了，各位同学看上述打印出来的东西，他会按照各种对象占用内存空间的大小降序排列，把占用内存最多的对象放在最上面。



所以如果你只是想要简单的了解一下当前jvm中的对象对内存占用的情况，只要直接用jmap -histo命令即可，非常好用



你可以快速了解到当前内存里到底是哪个对象占用了大量的内存空间。



**4、使用jmap生成堆内存转储快照**

但是如果你仅仅只是看一个大概，感觉就只是看看上述那些对象占用内存的情况，感觉还不够，想要来点深入而且仔细点的



那就可以用jmap命令生成一个堆内存快照放到一个文件里去，用如下的命令即可：



**jmap -dump:live,format=b,file=dump.hprof PID**



这个命令会在当前目录下生成一个dump.hrpof文件，这里是二进制的格式，你不能直接打开看的，他把这一时刻JVM堆内存里所有对象的快照放到文件里去了，供你后续去分析。



**5、使用jhat在浏览器中分析堆转出快照**

接着就可以使用jhat去分析堆快照了，jhat内置了web服务器，他会支持你通过浏览器来以图形化的方式分析堆转储快照



使用如下命令即可启动jhat服务器，还可以指定自己想要的http端口号，默认是7000端口号：



**jhat dump.hprof -port 7000**



接着你就在浏览器上访问当前这台机器的7000端口号，就可以通过图形化的方式去分析堆内存里的对象分布情况了。



这里我们先简单介绍一下，后面马上有两个案例，jstat、jmap、jhat我们都会带着大家动手来玩一下的。



**6、今日思考题**

今天留给大家的作业，就是自己去线上系统的机器上，用jmap -histo看看对象大致分布情况，然后用jmap生成一个堆转储快照，再用jhat分析一下堆转储快照，看看当前系统运行的时候，各种对象的分布情况。



大家可以到评论区里说说自己看堆转储快照的感受，是不是发现自己越来越了解JVM是如何运行的了呢？

**End**



# 052、从测试到上线：如何分析JVM运行状况及合理优化？

2019-08-21 07:00:00

**1、前文回顾**



前面两篇文章，已经给大家介绍了jstat、jmap、jhat等工具，可以非常轻松的分析出系统运行时的JVM状况，包括内存使用压力还有GC压力，包括内存中的对象分布情况。



这篇文章，我们结合之前介绍过的两个工具，给大家做一个实际开发、测试到上线的一个整体JVM优化的梳理。



**2、开发好系统之后的预估性优化**



大家平时如果在开发一个新系统的时候，完成开发之后，是不是就要经历测试以及上线的过程？



此时在系统开发完毕之后，实际上各位同学就应该参照之前我们多个案例中介绍的思路，对系统进行预估性的优化。



那什么叫做预估性的优化呢？



就是跟之前案例中说的一样，自行估算系统每秒大概多少请求，每个请求会创建多少对象，占用多少内存，机器应该选用什么样的配置，年轻代应该给多少内存，Young GC触发的频率，对象进入老年代的速率，老年代应该给多少内存，Full GC触发的频率。



这些东西其实是可以根据你自己写的代码，大致合理的预估一下的。



在预估完成之后，就可以采用之前多个案例介绍的优化思路，先给自己的系统设置一些初始性的JVM参数



比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值，等等。



优化思路其实简单来说就一句话：**尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。**



这个之前几周内容都在围绕这个核心在讲述，相信大家现在都理解的很清楚了。实际上这个过程应该是在新系统开发完毕之后必须有的一个环节。



**3、系统压测时的JVM优化**



通常一个新系统开发完毕之后，就会经过一连串的测试



从本地的单元测试，到系统集成测试，再到测试环境的功能测试，预发布环境的压力测试，要保证系统的功能全部正常



而且在一定压力下性能、稳定性和并发能力都正常，最后才会部署到生产环境运行。



这里非常关键的一个环节就是预发布环境的压力测试，通常在这个环节，会使用一些压力测试工具模拟比如1000个用户同时访问系统，造成每秒500个请求的压力，然后看系统能否支撑住每秒500请求的压力。同时看系统各个接口的响应延时是否在比如200ms之内，也就是接口性能不能太慢，或者是在数据库中模拟出来百万级单表数据，然后看系统是否还能稳定运行。



具体如何进行系统压测，不是我们这里要讲述的内容，大家自行百度一下“Java压力测试”，就会看到很多开源的工具，可以轻松模拟出N个用户同时访问你系统的场景，还能给你一份压力测试报告，告诉你系统可以支撑每秒多少请求，包括系统接口的响应延时。



在这个环节，通常压测工具会对系统发起持续不断的请求，持续很长时间，比如几个小时，甚至几天时间。



所以此时，大家完全就可以在这个环节，对测试机器运行的系统，采用jstat工具来分析在模拟真实环境的压力下，JVM的整体运行状态。



具体如何使用jstat来进行分析，之前都讲的很详细了，包括如何借助jstat的各种功能分析出来以下JVM的关键运行指标：新生代对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。



然后根据压测环境中的JVM运行状况，如果发现对象过快进入老年代，可能是因为年轻代太小导致频繁Young GC，然后Young GC的时候很多对象还是存活的，结果Survivor也太小，导致很多对象频繁进入老年代。当然也可能是别的什么原因。



此时就需要采用之前介绍的优化思路，合理调整新生代、老年代、Eden、Survivor各个区域的内存大小，保证对象尽量留在年轻代，不要过快进入老年代中。



之前很多人网上会胡乱搜索JMV优化的博客，看到里面人家怎么优化，你就怎么优化



比如很多博客说年轻代和老年代的占比一般是3:8，其实完全是片面的。每个系统都是不一样的，特点不同，复杂度不同。



大家记住一点：真正的优化，必须是你根据自己的系统，实际观察之后，然后合理调整内存分布，根本没什么固定的JVM优化模板。



当你对压测环境下的系统优化好JVM参数之后，观察Young GC和Full GC频率都很低，此时就可以部署系统上线了。



**4、对线上系统进行JVM监控**

当你的系统上线之后，你就需要对线上系统的JVM进行监控，这个监控通常来说有两种办法。



**第一种方法**会“low”一些，其实就是每天在高峰期和低峰期都用jstat、jmap、jhat等工具去看看线上系统的JVM运行是否正常，有没有频繁Full GC的问题。



如果有就优化，没有的话，平时每天都定时去看看，或者每周都去看看即可。



**第二种方法**在中大型公司里会多一些，大家都知道，很多中大型公司都会部署专门的监控系统，比较常见的有Zabbix、OpenFalcon、Ganglia，等等。



然后你部署的系统都可以把JVM统计项发送到这些监控系统里去。



此时你就可以在这些监控系统可视化的界面里，看到你需要的所有指标，包括你的各个内存区域的对象占用变化曲线，直接可以看到Eden区的对象增速，还会告诉你Young GC发生的频率以及耗时，包括老年代的对象增速以及Full GC的频率和耗时。



而且这些工具还允许你设置监控。也就是说，你可以指定一个监控规则，比如线上系统的JVM，如果10分钟之内发生5次以上Full GC，就需要发送报警给你。比如发送到你的邮箱、短信里，这样你就不用自己每天去看着了。



但是这些监控工具的使用不在我们专栏范畴里，因为这些内容并不一定每个公司都一样，也不一定每个公司都有



大家如果有兴趣，完全可以自行百度学习，比如“OpenFalcon监控JVM”，会看到很多资料。



对于我们而言，主要会带大家使用的就是JDK自身提供的命令行工具，包括jstat、jmap和jhat



其实把这些命令行用好了，基本线上系统的JVM监控和优化都能搞定了。而且我本人而言，还是非常推崇工程师平时除了要会用图形化工具，还必须得熟练使用命令行的工具，这才像一个“工程师”应该有的样子。



简单一句话总结：对线上运行的系统，要不然用命令行工具手动监控，发现问题就优化，要不然就是依托公司的监控系统进行自动监控，可视化查看日常系统的运行状态。





**5、今日思考题**



你们公司的系统开发流程里有压测环节吗？



如果有，你能否在自己的工作流程中加入一项，在开发之后先进行预估性JVM优化，然后再在压测环境进行测试性JVM优化。



此外，你们线上生产环境有没有JVM监控方案？



如果没有，建议在工作内容中引入一项，每天日常工作可以在固定时间段去线上机器里用命令行工具观察一下JVM运行状态，作为日常线上系统巡查的一个工作内容。



如果你们公司有类似Zabbix、OpenFalcon之类的监控系统，是否对线上系统都指定了JVM GC监控？如果JVM发生频繁Full GC能否及时通知到你？



专栏学习到这里，大家完全可以对自己负责的生产系统“**下手**”了。引入规范化、流程化的JVM监控和优化的工作内容，保障自己负责的系统的JVM性能是绝对良好的。



# 053、案例实战：每秒10万并发的BI系统，如何定位和解决频繁Young GC问题？

2019-08-22 07:00:00

**1、前文回顾**

不知道大家还记得之前我们给大家分析过的一个案例，就是一个BI系统因为负载很高所以触发了非常频繁的Young GC



**我们把这个案例的原文放在下面，因为隔了一段时间了，有的同学可能有些遗忘，咱们一起再来回顾一遍这个案例**



回顾之后，我们接着用代码模拟出这个案例的场景，然后用jstat来分析一下jvm的运行状态，带大家来实战一下jstat命令的使用。



**2、服务于百万级商家的BI系统是什么？**

先说一下我们线上一个真实的生产系统，是一个服务于百万级商家的BI系统。所谓BI系统，很多开发业务系统的同学可能没接触过，简单介绍一下他的背景。



简单来说，比如一个平台有数十万甚至上百万的商家在你的平台上做生意，会使用你的这个平台系统，此时一定会产生大量的数据



然后基于这些数据我们需要为商家提供一些数据报表，比如：每个商家每天有多少访客？有多少交易？付费转化率是多少？当然实际情况会比这个简单几句话复杂很多，我们这里就简单说个概念而已。



所以此时就需要一套BI系统，所谓BI，英文全称是“Business Intelligence”，也就是“商业智能”，听起来是不是特别的高大上？



其实也别想的太高大上了，说白了，就是把一些商家平时日常经营的数据收集起来进行分析，然后把各种数据报表展示给商家的一套系统。



所谓“商业智能”，指的就是给你看一些数据报表，然后让你平时能够更好的了解自己的经营状况，然后让老板“智能”的去调整经营策略，提升业绩。



所以类似这样的一个BI系统，大致的运行逻辑如下所示，首先从我们提供给商家日常使用的一个平台上会采集出来很多商家日常经营的数据，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/98182700_1566352981.cn/txdocpic/0/64a85974a95f162917f56c27734292f9/0)



接着就可以对这些经营数据依托各种大数据计算平台，比如Hadoop、Spark、Flink等技术进行海量数据的计算，计算出来各种各样的数据报表，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24088100_1566352982.cn/txdocpic/0/78d0d3d671ffe7167277b36188df951d/0)



然后我们需要将计算好的各种数据分析报表都放入一些存储中，比如说MySQL、Elastcisearch、HBase都可以存放类似的数据，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49649400_1566352982.cn/txdocpic/0/8df26d89ab5ec10da32a3d79c6134151/0)



最后一步，就是基于MySQL、HBase、Elasticsearch中存储的数据报表，基于Java开发出来一个BI系统，通过这个系统把各种存储好的数据暴露给前端，允许前端基于各种条件对存储好的数据进行复杂的筛选和分析，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/69345100_1566352982.cn/txdocpic/0/94a2fd799b14896a8f9e908b5e407edb/0)



**3、刚开始上线系统时候的部署架构**

我们在这里**重点****作为案例分析**的就是上述场景中的“BI系统，其他环节都跟大数据相关的技术是有关联的，暂时先不用care，未来有机会可以给大家出更多的课程来阐述那些技术。



刚开始的时候这个BI系统使用的商家是不多的，因为大家要知道，即使在一个庞大的互联网大厂里，虽然大厂本身积累了大量商家，但是要针对他们上线一个付费产品，刚开始未必所有人都买账，所以一开始系统上线大概就少数商家在使用，比如就几千个商家。



刚开始系统部署的非常简单，就是用几台机器来部署了上述的BI系统，机器都是普通的4核8G的配置



在这个配置之下，一般来说给堆内存中的新生代分配的内存都在1.5G左右，Eden区大概也就1G左右的空间，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92438600_1566352982.cn/txdocpic/0/ccb37c6e35533b8dff1c47ce882a0863/0)



**4、技术痛点：实时自动刷新报表 + 大数据量报表**

其实刚开始，在少数商家的量级之下，这个系统是没多大问题的，运行的非常良好



但是问题恰恰就出在突然使用系统的商家数量开始暴涨的时候，突然使用系统的商家开始越来越多，给大家举个例子，当商家的数量级达到几万的时候。



此时要给大家说明一个此类BI系统的特点，就是在BI系统中有一种数据报表，他是支持前端页面有一个JS脚本，自动每隔几秒钟就发送请求到后台刷新一下数据的，**这种报表称之为“实时数据报表”**，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12355200_1566352983.cn/txdocpic/0/60af57a050f134d2e1b508c55571a182/0)



那么大家可以设想一下，假设仅仅就几万商家作为你的系统用户，很可能同一时间打开那个实时报表的商家就有几千个



然后每个商家打开实时报表之后，前端页面都会每隔几秒钟发送请求到后台来加载最新数据



基本上会出现你BI系统部署的每台机器每秒的请求会达到几百个，这里我们假设就是每秒500个请求吧。



然后每个请求会加载出来一张报表需要的大量数据，因为BI系统可能还需要针对那些数据进行内存中的现场计算加工一下，才能返回给前端页面展示。



根据我们之前的测算，每个请求大概需要加载出来100kb的数据进行计算，因此每秒500个请求，就需要加载出来50MB的数据到内存中进行计算，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27585400_1566352983.cn/txdocpic/0/fa9d08c6b4b3a1cf29c17b390511869a/0)



**5、没什么大影响的频繁Young GC**

其实大家都已经发现上述系统的问题了，在上述系统运行模型下，基本上每秒会加载50MB的数据到Eden区中



只要区区20s，就会迅速填满Eden区，然后触发一次Young GC对新生代进行垃圾回收。



当然1G左右的Eden进行Young GC其实速度相对是比较快的，可能也就几十ms的时间就可以搞定了



所以之前也分析过，其实对系统性能影响并不大，而且上述BI系统场景下，基本上每次Young GC后存活对象可能就几十MB，甚至是几MB。



所以如果仅仅只是这样的话，那么大家可能会看到如下场景，BI系统运行20s过后，就会突然卡顿个10ms，但是对终端用户和系统性能几乎是没有影响的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/57167800_1566352983.cn/txdocpic/0/5b40474a48e743fbc7a8bd7781ea4149/0)





**6、模拟代码的JVM参数设置**

接着我们会用一段程序来模拟出上述BI系统那种频繁Young GC的一个场景，此时JVM参数如下所示：



-XX:NewSize=104857600 -XX:MaxNewSize=104857600 -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3145728 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log



大家只要注意一下上述我们把堆内存设置为了200MB，把年轻代设置为了100MB，然后Eden区是80MB，每块Survivor区是10MB，老年代也是100MB。



我们把案例中的内存大小适当缩小了一些，这样方便大家在本地windows电脑来运行试验。



**7、示例程序**

下面是我们的示例程序：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/63758600_1566353021.png)



针对这段示例程序给大家做一点说明。



首先看第一行代码：Thread.sleep(30000); 



为什么刚开始先休眠30s？



因为一会儿会告诉大家，程序刚启动，必须得先让我们找到这个程序的PID，也就是进程ID，然后再执行jstat命令来观察程序运行时JVM的状态。



接着看loadData()方法内的代码，其实非常简单，他会循环50次，模拟每秒50个请求



然后每次请求会分配一个100KB的数组，模拟每次请求会从数据存储中加载出来100KB的数据。接着会休眠1秒钟，模拟这一切都是发生在1秒内的。



其实这些对象都是短生存周期的对象，所以方法运行结束直接对象都是垃圾，随时可以回收的。



然后在main()方法里有一个while(true)循环，模拟系统按照每秒钟50个请求，每个请求加载100KB数据的方式不停的运行，除非我们手动终止程序，否则永不停歇。



**8、如何在windows上执行命令？**

这里交给大家一个windows上做实验特别好用的工具，就是Git for Windows



大家可能疑惑，这跟Git有什么关系？他不是一个版本管理工具吗？



没错，但是这个Git for Windows，你主要安装之后，就可以在windows上启动一个Git Bash的窗口，然后你可以随意执行各种命令，非常的好用。



所以推荐给大家这个工具的官网：https://gitforwindows.org/



大家自己到官网里下载最新版本即可，安装和使用非常的简单。



在你安装完毕之后，在windows桌面上右击的时候，会看到一个“Git Bash Here”的选项，此时选择他，就可以直接打开一个命令行窗口，里面可以随意执行命令。



当然，其实如果你不想那么麻烦，也可以直接打开windows自己的命令行窗口，在里面也可以执行jps、jstat等命令，这也是没问题的。只不过我习惯于通过Git for Windows来执行一些命令。



**9、通过jstat观察程序的运行状态**

接着我们使用预订的JVM参数启动程序，此时程序会先进入一个30秒的休眠状态，此时尽快执行jps命令，查看一下我们启动程序的进程ID，如下图所示：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80921000_1566352983.cn/txdocpic/0/9d634f210850bb925bbcfcfc8d99406d/0)



此时会发现我们运行的Demo1这个程序的JVM进程ID是51464。



然后尽快执行下述jstat命令：**jstat -gc 51464 1000 1000**



他的意思就是针对51464这个进程统计JVM运行状态，同时每隔1秒钟打印一次统计信息，连续打印1000次。



然后我们就让jstat开始统计运行，每隔一秒他都会打印一行新的统计信息，过了几十秒后可以看到如下图所示的统计信息：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/7949400_1566352984.cn/txdocpic/0/7b3993b060b1a6ad3c8d7fc85d21881b/0)



接着我们一点点来分析这个图。首先我们先看如下图所示的一段信息：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29471600_1566352984.cn/txdocpic/0/352b172f3e2708f8d11f211ea15f1ed8/0)



这个EU大家应该还记得，就是之前我们所说的Eden区被使用的容量，可以发现他刚开始是3MB左右的内存使用量



接着从我们程序开始运行，会发现每秒钟都会有对象增长，从3MB左右到7MB左右，接着是12MB，17MB，22MB，每秒都会新增5MB左右的对象。



这个跟我们写的代码是完全吻合的，我们就是每秒钟会增加5mB左右的对象。



然后当Eden区使用量达到70多MB的时候，再要分配5MB的对象就失败了，此时就会触发一次Young GC，然后大家继续看下面的图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54035700_1566352984.cn/txdocpic/0/19ed1ca1630e1a5de6a00a56473ca830/0)

 

**注意看上面红圈里的内容**，大家会发现，Eden区的使用量从70多MB降低为了1MB多，这就是因为一次Young GC直接回收掉了大部分对象。



所以我们现在就知道了，针对这个代码示例，可以清晰的从jstat中看出来，对象增速大致为每秒5MB左右，大致在十几秒左右会触发一次Young GC



这个就是Young GC的触发频率，以及每次Young GC的耗时，大家看下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73385900_1566352984.cn/txdocpic/0/faaced3f84e7df0bc252a85264323545/0)



上图清晰告诉你了，一次Young GC回收70多MB对象，大概就1毫秒，所以大家想想，Young GC其实是很快的，即使回收800MB的对象，也就10毫秒那样。



所以你想如果是线上系统，他Eden区800MB的话，每秒新增对象50MB，十多秒一次Young GC，也就10毫秒左右，系统卡顿10毫秒，几乎没什么大影响的。



所以我们继续推论，在这个示例中，80MB的Eden区，每秒新增对象5MB，大概十多秒触发一次Young GC，每次Young GC耗时在1毫秒左右。



那么每次Young GC过后存活的对象呢？



简单看上上图，S1U就是Survivor中被使用的内存，之前一直是0，在一次Young GC过后变成了675KB，所以一次Young GC后也就存活675KB的对象而已，轻松放入10MB的Survivor中。



而且大家注意上上图中的OU，那是老年代被使用的内存量，在Young GC前后都是0



这说明这个系统运行良好，Young GC都不会导致对象进入老年代，这就几乎不需要什么优化了。因为几乎可以默认老年代对象增速为0，Full  GC发生频率趋向于0，对系统无影响。



所以大家回顾一下，通过一个示例程序的运行，是不是可以通过jstat分析出来以下信息：



- 新生代对象增长的速率
- Young GC的触发频率
- Young GC的耗时
- 每次Young GC后有多少对象是存活下来的
- 每次Young GC过后有多少对象进入了老年代
- 老年代对象增长的速率
- Full GC的触发频率
- Full GC的耗时





**10、今日思考题**

大家可以让这个程序多运行一段时间，反复观察其每次Young GC之后的Eden、Survivor、Old区的内存变化



然后多思考思考，对一个运行中的系统，到底要观察些什么东西？



# 054、案例实战：每日百亿数据量的实时分析引擎，如何定位和解决频繁Full GC问题？

2019-08-23 07:00:00

**1、前文回顾**



大家应该还记得之前我们有一篇文章，分析了一个实时计算系统因为负载过高导致了非常频繁的Full GC



这里先在下面贴出来之前的内容，大家先看一下回顾回顾，接着我们会给出示例代码，运行起来之后通过jstat来观察其运行中的问题。



然后我还会优化一下JVM参数配置，再次运行系统，通过jstat来观察JVM优化以后的效果。



**2、一个日处理上亿数据的计算系统**



先给大家说一下这个系统的案例背景，当时我们团队里自己研发的一个数据计算系统，日处理数据量在上亿的规模。



为了方便大家集中注意力理解这个系统的生产环境的JVM相关的东西，所以对系统本身就简化说明了。



简单来说，这个系统就是会不停的从MySQL数据库以及其他数据源里提取大量的数据加载到自己的JVM内存里来进行计算处理，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65947900_1566437961.cn/txdocpic/0/a2a44346a04ac9e835c45bc763f5fbe2/0)



这个数据计算系统会不停的通过SQL语句和其他方式从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。



但这是一套分布式运行的系统，所以生产环境部署了多台机器，每台机器大概每分钟负责执行100次数据提取和计算的任务。



每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间



然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87602200_1566437961.cn/txdocpic/0/0f1c80d13cc35c5a59e006c125ab6471/0)



**3、这个系统到底多快会塞满新生代？**



现在明确了一些核心数据，接着我们来看看这个系统到底多快会塞满新生代的内存空间？



既然这个系统每台机器上部署的实例，每分钟会执行100次数据计算任务，每次是1万条数据需要计算10秒的时间，那么我们来看看每次1万条数据大概会占用多大的内存空间？



这里每条数据都是比较大的，大概每条数据包含了平均20个字段，可以认为平均每条数据在1KB左右的大小。



那么每次计算任务的1万条数据就对应了10MB的大小。所以大家此时可以思考一下，如果新生代是按照8:1:1的比例来分配Eden和两块Survivor的区域，那么大体上来说，Eden区就是1.2GB，每块Survivor区域在100MB左右，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10293200_1566437962.cn/txdocpic/0/27013616e76c608d90f90c4aa8839ad0/0)



基本上按照这个内存大小而言，大家会发现，每次执行一个计算任务，就会在Eden区里分配10MB左右的对象



一分钟大概对应100次计算任务，基本上一分钟过后，Eden区里就全是对象，基本就全满了。



所以说，回答这个小节的问题，新生代里的Eden区，基本上1分钟左右就迅速填满了。



**4、触发Minor GC的时候会有多少对象进入老年代？**

此时假设新生代的Eden区在1分钟过后都塞满对象了，然后在接着继续执行计算任务的时候，势必会导致需要进行Minor GC回收一部分的垃圾对象。



那么上篇文章给大家讲过这里在执行Minor GC之前会先进行的检查。



首先第一步，先看看老年代的可用内存空间是否大于新生代全部对象？



看下图，此时老年代是空的，大概有1.5G的可用内存空间，新生代的Eden区大概算他有1.2G的对象好了。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/37883800_1566437962.cn/txdocpic/0/0c9b3fef4480068f6596d7e497b69f43/0)



此时会发现老年代的可用内存空间有1.5GB，新生代的对象总共有1.2GB，即使一次Minor GC过后，全部对象都存活，老年代也能放的下的，那么此时就会直接执行Minor GC了。



那么此时Eden区里有多少对象还是存活的，无法被垃圾回收呢？



大家可以考虑一下之前说的那个点，每个计算任务1万条数据需要计算10秒钟，所以假设此时80个计算任务都执行结束了，但是还有20个计算任务共计200MB的数据，还在计算中，那么此时就是200MB的对象是存活的，不能被垃圾回收掉，然后有1GB的对象是可以垃圾回收的，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/72500800_1566437962.cn/txdocpic/0/2c9dd6de204132c1782abb9befc0108f/0)



此时一次Minor GC就会回收掉1GB的对象，然后200MB的对象能放入Survivor区吗？



**不能**！



因为任何一块Survivor区实际上就100MB的空间，此时就会通过空间担保机制，让这200MB对象直接进入老年代去，占用里面200MB内存空间，然后Eden区就清空了，大家看下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89647100_1566437962.cn/txdocpic/0/595cc6ef34ae543070f7c2a199041ada/0)



**5、系统运行多久，老年代大概就会填满？**

那么大家想一下，这个系统大概运行多久，老年代会填满呢？



按照上述计算，每分钟都是一个轮回，大概算下来是每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，然后大概都会有200MB左右的数据进入老年代。



那么大家可以想一下，假设现在2分钟运行过去了，此时老年代已经有400MB内存被占用了，只有1.1GB的内存可用，此时如果第3分钟运行完毕，又要进行Minor GC会做什么检查呢？



如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4860700_1566437963.cn/txdocpic/0/5b5b675f627b6e4079b5a25c51fd7489/0)



此时会先检查老年代可用空间是否大于新生代全部对象，此时老年代可用空间1.1GB，新生代对象有1.2GB，那么此时假设一次Minor GC过后新生代对象全部存活，老年代是放不下的，那么此时就得看看一个参数是否打开了 。



如果“-XX:-HandlePromotionFailure”参数被打开了，当然一般都会打开，此时会进入第二步检查，就是看看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。



我们已经计算过了，大概每分钟会执行一次Minor GC，每次大概200MB对象会进入老年代。



那么此时发现老年代的1.1GB空间，是大于每次Minor GC后平均200MB对象进入老年代的大小的，所以基本可以推测，本次Minor GC后大概率还是有200MB对象进入老年代，1.1G可用空间是足够的。



所以此时就会放心执行一次Minor GC，然后又是200MB对象进入老年代。



转折点大概在运行了7分钟过后，7次Minor GC执行过后，大概1.4G对象进入老年代，老年代剩余空间就不到100MB了，几乎快满了，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/25705000_1566437963.cn/txdocpic/0/4858e3f283323859740672320cd34233/0)



**6、这个系统运行多久，老年代会触发1次Full GC？**

大概在第8分钟运行结束的时候，新生代又满了，执行Minor GC之前进行检查，此时发现老年代只有100MB内存空间了，比之前每次Minor GC后进入老年代的200MB对象要小，此时就会直接触发一次Full GC。



Full GC会把老年代的垃圾对象都给回收了，假设此时老年代被占据的1.4G空间里，全部都是可以回收的对象，那么此时一次性就会把这些对象都给回收了，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42748500_1566437963.cn/txdocpic/0/dfa1aa67d11adc2344b6eaf6b8f0afe5/0)



然后接着就会执行Minor GC，此时Eden区情况，200MB对象再次进入老年代，之前的Full GC就是为这些新生代本次Minor GC要进入老年代的对象准备的，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/56983000_1566437963.cn/txdocpic/0/ff8e4614f20b8854780172685c53ea1c/0)



按照这个运行模型，基本上平均就是七八分钟一次Full GC，这个频率就相当高了。因为每次Full GC速度都是很慢的，性能很差



**7、该案例应该如何进行JVM优化？**



相信通过这个案例，大家结合图一路看下来，对新生代和老年代如何配合使用，然后什么情况下触发Minor GC和Full GC，什么情况下会导致频繁的Minor GC和Full GC，大家都有了更加深层次和透彻的理解了。



对这个系统，其实要优化也是很简单的，因为这个系统是数据计算系统，每次Minor GC的时候，必然会有一批数据没计算完毕，但是按照现有的内存模型，最大的问题，其实就是 每次Survivor区域放不下存活对象。



所以当时我们就是对生产系统进行了调整，增加了新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代



这样Survivor区大概就是200MB，每次刚好能放得下Minor GC过后存活的对象了，如下图所示。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75365200_1566437963.cn/txdocpic/0/c6dd4fa67166c92a852d81497602b4bd/0)



只要每次Minor GC过后200MB存活对象可以放Survivor区域，那么等下一次Minor GC的时候，这个Survivor区的对象对应的计算任务早就结束了，都是可以回收的了，此时比如Eden区里1.6GB空间被占满了，然后Survivor1区里有200MB上一轮 Minor GC后存活的对象，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/91714600_1566437963.cn/txdocpic/0/1529a0eb09d15c59499ee08fdaf539a7/0)



然后此时执行Minor GC，就会把Eden区里1.4GB对象回收掉，Survivor1区里的200MB对象也会回收掉，然后Eden区里剩余的200MB存活对象会放入Survivor2区里，如下图。



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15684700_1566437964.cn/txdocpic/0/6ea6749024c342adef6918b21d3751f6/0)



以此类推，基本上就很少对象会进入老年代中，老年代里的对象也不会太多的。



通过这个分析和优化，定时我们成功的把生产系统的老年代Full GC的频率从几分钟一次降低到了几个小时一次，大幅度提升了系统的性能，避免了频繁Full GC对系统运行的影响。





**8、运行程序用的示例JVM参数**



下面的参数唯一修改的就是“**-XX:PretenureSizeThreshold**”，把大对象阈值修改为了20MB，避免我们程序里分配的大对象直接进入老年代。



-XX:NewSize=104857600 -XX:MaxNewSize=104857600 -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log



**9、示例程序**



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75959300_1566438021.png)



简单给大家解释一下上面的程序



大概意思其实就是，每秒钟都会执行一次loadData()方法，他会分配4个10MB的数组，但是都立马成为垃圾，但是会有data1和data2两个10MB的数组是被变量引用必须存活的，此时Eden区已经占用了六七十MB空间了，接着是data3变量依次指向了两个10MB的数组，这是为了在1s内触发Young GC的。



**10、基于jstat分析程序运行的状态**



接着我们基于jstat分析程序运行的状态，启动程序后立马采用jstat监控其运行状态可以看到如下的信息：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36963200_1566437964.cn/txdocpic/0/f74cde8c1c0293bc12e99e53003d2043/0)



接着我们一点点来分析这个jvm的运行状态。首先我们先看如下一行截图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53564300_1566437964.cn/txdocpic/0/c73e70396eea1345f393591f49e23833/0)



在这里最后一行，可以清晰看到，程序运行起来之后，突然在一秒内就发生了一次Young GC，这是为什么呢？



很简单，按照我们上述的代码，他一定会在一秒内触发一次Young GC的。



Young GC过后，我们发现S1U，也就是一个Survivor区中有587KB的存活对象，这应该就是那些未知对象了。



然后我们明显看到在OU中多出来了30MB左右的对象，因此可以确定，在这次Young GC的时候，有30MB的对象存活了，此时因为Survivor区域放不下，所以直接进入老年代了。



我们接着看下面的截图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70142300_1566437964.cn/txdocpic/0/273760104da7ff6bbdb1de96e7571f23/0)



大家看上图中红圈的部分，很明显每秒会发生一次Young GC，都会导致20MB~30MB左右的对象进入老年代



因为每次Young GC都会存活下来这么多对象，但是Survivor区域是放不下的，所以都会直接进入老年代。



此时看到老年代的对象占用从30KB一路到60MB左右，此时突然在60MB之后下一秒，明显发生了一次Full GC，对老年代进行了垃圾回收，因为此时老年代重新变成30MB了。



为啥会这样？



很简单，老年代总共就100MB左右，已经占用了60MB了，此时如果发生一次Young GC，有30MB存活对象要放入老年代的话，你还要放30MB对象，明显老年代就要不够了，此时必须会进行Full GC，回收掉之前那60MB对象，然后再放入进去新的30MB对象。



所以大家可以看到，按照我们的这段代码，几乎是每秒新增80MB左右，触发每秒1次Young GC，每次Young GC后存活下来20MB~30MB的对象，老年代每秒新增20MB~30MB的对象，触发老年代几乎三秒一次Full GC，是不是跟我们上面的案例中分析的场景很类似？Young GC太频繁，而且每次GC后存活对象太多，频繁进入老年代，频繁触发老年代的GC。



那么Young GC和Full GC的耗时呢？看下图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/90116500_1566437964.cn/txdocpic/0/144953ec5db13d3c365a124860d5bd64/0)



大家看上图，有没有发现Young GC特别坑爹，28次Young GC，结果耗费了180毫秒，平均下来一次Young GC要6毫秒左右。但是14次Full GC才耗费34毫秒，平均下来一次Full GC才耗费两三毫秒。这是为什么呢？



很简单，按照上述程序，每次Full GC都是由Young GC触发的，因为Young GC过后存活对象太多要放入老年代，老年代内存不够了触发Full GC，所以必须得等Full GC执行完毕了，Young GC才能把存活对象放入老年代，才算结束。这就导致Young GC也是速度非常慢。



**11、对JVM性能进行优化**



接着我们按照之前学习的思路对JVM进行优化，很简单，他最大的问题就是每次Young GC过后存活对象太多了，导致频繁进入老年代，频繁触发Full GC



我们只需要调大年轻代的内存空间，增加Survivor的内存即可，看如下JVM参数：



-XX:NewSize=209715200 -XX:MaxNewSize=209715200 -XX:InitialHeapSize=314572800 -XX:MaxHeapSize=314572800 -XX:SurvivorRatio=2  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log



我们把堆大小调大为了300MB，年轻代给了200MB，同时“-XX:SurvivorRatio=2”表明，Eden:Survivor:Survivor的比例为2:1:1，所以Eden区是100MB，每个Survivor区是50MB，老年代也是100MB。



接着我们用这个JVM参数运行程序，用jstat来监控其运行状态如下：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10722700_1566437965.cn/txdocpic/0/5ec8345ef77514a6f87fec74c3a81b69/0)



在上述截图里，大家可以清晰看到，每秒的Young gC过后，都会有20MB左右的存活对象进入Survivor，但是每个Survivor区都是50MB的大小，因此可以轻松容纳，而且一般不会过50%的动态年龄判定的阈值。



我们可以清晰看到每秒触发Yuong GC过后，几乎就没有对象会进入老年代，最终就600KB的对象进入了老年代里，其他就没有对象进入老年代了。



再看下面的截图：



![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/23684900_1566437965.cn/txdocpic/0/d7495599d2ad7d1f88eba015739abd62/0)



我们可以看到，只有Young GC，没有Full GC，而且11次Young GC才不过9毫秒，平均一次GC1毫秒都不到，没有Full GC干扰之后，Young GC的性能极高。



所以，其实这个案例就优化成功了，同样的程序，仅仅是调整了内存分配比例，立马就大幅度提升了JVM的性能，几乎把Full GC给消灭掉了。





**12、今日思考题**



这周内容学完之后，大家不用多说，直接自己按照文章的思路，写出来模拟代码，尝试用jstat去观察一下运行状态



尤其是今天的文章，需要你去亲自动手写代码，观察优化前频繁full gc的问题，然后优化jvm参数之后，再看看优化后的效果，相信大家基本从实操层面就完全明白jvm的优化方法了。



# 055、第8**周作业**

第8周作业：

思考题，结合你们系统的业务来分析，遇到频繁GC该怎么处理？



本周的作业非常简单，学完了这周内容，希望大家务必制定好自己公司从开发、测试到上线的全流程的JVM优化规范，每个环节都需要进行JVM优化。



同时对生产环境的系统需要制定好JVM监控方案，无论是手动监控，还是基于监控系统，都需要有。



同时去对你们生产系统按照本周教的方法观察一下运行状态，有问题的话可以尝试优化一下，亲自动手实战一下。

# 056、第8周答疑：本周问题答疑汇总

**问题：**

我觉得有点虚了，我从今儿早上回来就一直试(工作准备加班完成了)，3个实验gc都和老师不一样，现在版本换成和老师的一样了，同样是不一样，老师的gc日志明显是老年代只有2m，我的不知道为什么gc后有5m。百思不得其解，这到底是为什么呢，是否有同学测试出来的结果和老师的一样？



**回答：**

别着急，说实话，细微的差别都是正常的，千万不要在jvm实验中钻牛角尖。因为eclipse、intellij idea、包括笔记本硬件、操作系统，其实都会对实验结果产生影响的。核心是理解我讲解的原理，然后结合自己的实验结果去分析大的原理，而不是扣细微的细节，jvm自身内置会产生一些对象，所以对象占用之类的，都是不一样的





**问题：**

实验了一下，又颠覆了我昨天的认知：触发了YoungGC，判断存活对象是否大于老年代剩余，即晋升失败 -ParNew (promotion failed)。如果晋升失败，这时触发Old GC，且所有的存活对象都会直接晋升到老年代。不管Survivor区放不放的下部分存活对象。而昨天提到的“部分晋升”的前提是晋升过程中不会触发Old GC



**回答：**

非常好，多动手试验





**问题：**

今天的课程有点颠覆我以前的认知了。。。我一直认为是发生OldGC后，一次性怼这个6M多的数据进入老年代的，按照老师你的讲解，它是分批进入老年代的呀



**回答：**

不是的，就是直接放入老年代，我分步骤讲解，是拆解那个过程给你理解的，不要认为是拆分开来走的



**学员思考题回答：**

系统如何尽量减少FULL GC？ 

一、首先说明什么情况下发生 full gc：

**1、Minor GC 前：**

1. 年轻代对象大小>老年代可用内存&&没开通内存分配担保情况 
2. 年轻代对象大小>老年代可用内存&&开通内存分配担保情况下，历次年轻代GC进入老年代大小平均值>老年代可用内存大小 

**2、Minor GC 后**，老年代放不下GC后存活的对象 



二、为了避免full gc：使每次minor gc后，存活的对象尽量能放在s区，不要放到老年代： 

1. 可以调大survivor区的大小。考虑到动态年龄判断，如果系统资源比较足，可以估算每次minor gc后，存活对象的大概大小，将survivor区内存设置为这个内存的一倍 
2. 如果系统运算时间比较长，导致对象的年龄比较大，可以适当调大"-XX:MaxTenuringThreshold"，使对象年龄大一些再进入老年代，这样也可以减少进入老年代的对象





**问题：**

老师你好，今天实验又发现个新情况：eden区放满触发了young GC，结果晋升的对象太多，触发了CMS，并把老年代放满了。后续又放入的对象把eden区占满了，再放入对象就直接放在了S区，而不是再次触发Young GC。



我花了好多时间去看gc log，然后推测 gc的算法，好费时间啊。老师有没有详细的垃圾收集算法，这样我就不用去推测了。推测了这么多，实际工作中好像又不太会遇到这种情况，挺浪费时间，但不搞清楚又不甘心



**回答：**你一定要明白一点，jvm的算法你永远没法完全搞明白，只要跟着文章理解大致思路和原理就行了。每个版本的算法都有区别，你要对你线上jvm的算法理解细节，只能一点一点的做测试和尝试





**问题：**

？？疑问，当晋升失败 - [ParNew (promotion failed): 15615K->19502K(20480K)，触发了OLd GC - [CMS: 5123K->5120K(6144K) ..]，这时全部的幸存对象进入老年代，S区是空的。



请问老师，此时回收的执行顺序是什么样的？ 本该放到S区的对象，现在是怎么处理的？



**回答：**先回收老年代，然后让young gc的幸存对象放入老年代中





**问题：**

回看这篇帖子，我终于知道我的疑问到底是什么了，也知道怎么提问了。 不想钻牛角尖，但是还是想大概明白这个问题是咋回事，希望能得到老师的指点。 所以我想问三个问题： 



1.在宏观上，其实仍然存在Eden+2S，举一个例子，现在Eden区满了，触发了一次新生代GC，于是把存活对象放到S1所属的Region。第二次，Eden区又满了，于是会触发第二次新生代GC，那么会把Eden+S1的幸存对象放入S2。 



那么第一个问题来：此时会清空S1的所有Region吗？ 



2.第二个问题：在宏观上，Eden区和S区是有比例的，比如默认的8：1：1，有800个属于Eden区的Region，那么理应有100个属于S1的Region和100个属于S2的Region。 



现在有一个新生代大小为2G的堆内存，每个Region大小为2m，Eden区占用了800个Region，两个S分别占用了100个Region。



比如在一次新生代GC过后，存活对象为100m，所以就会占用其中一个S区的50个Region。



那么为了符合Eden：S1：S2=8：1：1的比例，Eden区的Region是否应该变为400个Region，然后800-400=400的另外400个Region就成为了空闲的Region？ 



3.根据以上，是否可以得出一个结论：Survivor区是否随着Eden区的增长而变大？



**回答：**

1、当然会清空S1 

2、是有比例的 

3、对的，S会自然变大





**问题：**

大神，我之前统计系统内存就是直接使用jmeter去压测，把客户要求的tps（加了2倍去测试）。 

1. 1使用 top 监控一段时间进程使用的内存大小 
2. 2监控一段时间的 GC频率 
3. 3统计结果（客户接受这样测试结果） 



请问一下大神们，这样简单暴力的方式有什么坑吗？



**回答：**其实没大坑，基本上可以看出来系统的具体情况





**学员总结：**

打卡，前面已经学习了上线前如何预估系统的压力，现在直接通过工具分析更加准确，感谢老师提供这么好的思路，现在感觉自己越来越接近具备解决生产问题的能力了，有点小激动。



**回答：**后面全部是大量的代码实战案例，结合各种工具分析线上生产问题，然后做出优化的实战，加油





**问题：**

动态年龄判断里，“年龄1+年龄2+年龄n”这句是不是指从最小年龄的对象开始依次向上与大龄对象累加大小？



比如累加到10岁的对象时，对象累加大小总和大于survivor区空间大小的50%了，那么survivor区里大于等于10岁的对象都移到老年代里



**回答：**没错的





**问题：**

在同一台机器上，启动一个java项目，就启动一个JVM进程，同一个项目项目，都运营在同一个JVM进程中，老师是这样吗？



**回答：**对的，就是你理解的这样子





**问题：**

老师，在Tomcat中启动一个war，这是启动了一个JVM进程吗，还是多个？



**回答：**Tomcat自己就是一个JVM进程，我们写的war包不过就是一些类而已，Tomcat加载到自己的JVM进程里去执行类的代码逻辑





**问题：**

看第二遍的想法： 判断是否是垃圾对象都是从GC ROOT出发的，老年代为什么没有像eden区那样一步到位把全部对象标出是否是垃圾对象？ 



是因为年轻代绝大部分的对象通过年像老年代初始标识阶段就能知道是否垃圾对象了，即通过直接引用的判断就能知道是否是垃圾对象，剩下极少部分对象是需要追踪间接引用（耗时少），所以年轻代一步到位去标识。而老年代刚好相反，很多对象是直接引用，也有很多是间接引用（比较耗时），所以分了多个阶段。



请问老师，这样理解对吗？



**回答：**老年代那么做是因为他不能直接stop the world去回收，那样太慢了，他要尽可能把一些环节跟工作线程并行运行，这样可以适当减轻gc对工作线程的影响





**学员思考题总结：**

本地实践下来，除了长期存活的那几百K对象经过15次GC进入老年代，之后每次Young GC存活对象都为0.所以频繁YoungGC，但就是触发不了FullGC。 其实这里感觉应该将年轻代调大，老年代设的小一点。比如年轻代150，老年代50，这样YoungGC频率也就可以相对低一点了，而且依然不会触发OldGC。



**回答：**对的，思路正确



**学员总结：**

非常有意思，实验有小小不同，第一次ygc之后，有8b不知道啥东西晋升老年代了，不过这个无关大雅。



**问题：**java项目一般都是运营在Tomcat中的，设置参数的时候，是不是只配置Tomcat的即可，还是要在程序中单独配置。 还有，这这些参数配置的作用范围是什么，是当前的JVM进程吗？



**回答：**对的，一般就是配置tomcat的jvm参数的，作用范围就是tomcat的jvm进程





**问题：**

老师我这 S0C 、S1C 的值为什么一直变化呢，他的含义是Survivor0的容量，这个容量不应该是一个定值吗



**回答：**正常啊，程序运行，一直触发young gc，每次gc过后存活对象先进入S0，然后下一次gc后存活对象进入S1，不就来回交替了，看来之前的文章内容还是没理解透，可以回过头二刷以前的文章





**问题：**

根据文章开始的例子，from和to区域只有100m，每次young gc后，会有200m的存活对象，优化后把from和to调整到200m，young gc后，存活的对象可以放到fro区域了。



那么问题来了，动态年龄判断啥时候触发啊？200m的from区，200m的存活对象，不会触发动态年龄判断吗？



**回答：**你可以观察文章里的情况，优化过后，一般不会触发动态年龄判定，因为S区没到50%





**问题：**

单单通过改变SurvivorRatio为2也可以了，只不过YGC更频繁而已；老师我这里有个问题，我本机用CMS，老年代达到50%，最多到80%就开始垃圾回收了。



我通过设置CMSInitiatingOccupancyFraction改变占比也还是老样子，这种情况算正常吗？最郁闷的一点是这个垃圾回收触发的占比通过jstat来看，每次都有点不固定，最低50%，最高80%触发。。



**回答：**其实也是正常的，因为看那几个条件，可能你历次升入老年代的平均对象大小会不停改变，那么自然触发老年代GC的时机不一样了



**问题：**

请问一下我的JDK版本是1.8.0_91, 配置-XX:+HandlePromotionFailure 时报错“Unrecognized VM option 'HandlePromotionFailure' Did you mean '(+/-)PromotionFailureALot'?”，请问是哪里配置的不对吗？



**回答：**那个参数在JDK 1.6之后就不需要了，可以忽略了，他默认只需要比较历次young gc后升入老年代的平均对象大小和老年代的可用空间大小就可以了，把那个参数删除就可以了





**问题：**

老师您好，问下G1回收器什么情况下会自动降级成parnew+cms，反过来升级的情况也可能发生嘛？



**回答：**G1一般不会自动降级，这个用什么垃圾回收器，都是你自己决定的



**问题：**

老师有个问题，我看我们生产服务器配的堆大小2g，其他都是默认。jmap看新生代eden区和survivor区的比例为8，按这比例，survivor区应该是新生代的10分之一，但是eden区有680m,survivor区却只有10m,而且每次yonggc后，eden区和survivor区的总大小都在变化，为什么呢？



**回答：**

那你们肯定是允许堆大小动态调整了，那个需要禁止掉的，就是-Xmx和-Xms需要一样的值



**问题：**

在创建对象是在eden和survivor1中随机分配内存的么？不是的话，那顺序是什么？



猜想是在eden分配，慢慢晋升到survivor1中，最后yongGC后存活的1%转移到survivor2中，对么？



**回答：**在eden里分配对象，gc后存活对象放入Survivor中



# 057、案例实战：每秒十万QPS的社交APP 如何优化GC性能提升3倍？

**1、引子**



这篇文章开始，我们会开始用一系列真实的生产案例给大家还原出来各种各样不同的JVM优化场景



力求让大家在不同的业务背景下，对不同的原因产生的JVM性能问题进行分析和处理，进而积累出来大量不同场景下的JVM性能优化经验。



所有的JVM优化案例都是基于之前几十篇文章教给大家的核心原理以及优化手段来展开的，因此大家可以认为，之前几十篇文章学习完过后，你就已经有能力在生产系统上手进行JVM的性能分析以及优化了。



只不过大家如果再经过几十个真实的生产案例的锤炼，就能够有能力对未来自己可能遇到的各种不同的情况下的JVM生产问题进行分析和处理。



因为这些案例都是真实的生产案例，所以有的案例我们会用一些模拟代码还原出来当时的故障场景，并且带着大家用各种工具来进行分析，然后进行优化。



但是有的案例我们很难用模拟代码还原出来，此时还会延续采用一步一图的方式，尽量用大量的手绘图让大家理解JVM故障的产生背景、发生原因以及优化的手段。



跟之前一样，我们开始先用两三个较为简单的案例引入，让大家找找感觉，接着再切入比较复杂的案例。





**2、案例背景**



本案例的背景是一个有高峰期每秒十万QPS的社交APP，这是我曾经帮助一个朋友的公司处理过的一个JVM优化的案例。



大家都知道，其实现在社交APP有很多种，不光是大家熟悉的微信、QQ之类的，还有很多细分领域的明星社交APP，诸如陌生人社交，基于地理位置的社交，等等。



其实很多明星创业社交APP产品，也有每日数百万的日活用户，尤其在晚上高峰期的时候，APP的QPS也是很高的。



附带一句，可能有的同学不知道QPS是什么，其实英文全称就是“Query Per Second”，也就是每秒钟的查询数量，大致可以理解为是APP每秒钟的访问数量。



对于这个APP而言，流量最大的是哪个功能模块？



不知道大家有没有玩儿过陌生人社交类的APP，在这种APP中操作最多的就是浏览某个陌生人的个人页面。



一般这类APP都会通过各种方式来给你推荐一些周边的陌生人，然后你可能会看到一些感兴趣的人，就会进入他/她的个人主页去看一看。个人主页里可能就包含了那个人的一些自我介绍，照片之类的东西。



所以这类APP，在晚上高峰期，流量最大的一个模块，其实就是个人主页模块



会有大量的活跃用户在一个集中的时间段内频繁的访问各种个人主页数据，而且这类数据的量还通常很大，要包含很多的信息，通常一个个人主页的数据甚至可能有几MB。



随便给大家举个例子，一个个人主页里，可能有这个人每天发的一些心情、感悟之类的东西



那么一旦要把这个个人主页加载出来，必然会加载出来这个人最近N多天发的一些心情感悟之类的文字，这个文字的量还是比较多的。



所以我们大致可以认为，一次个人主页的查询，就会加载出来比如5MB的数据。



而且一般在高峰期内，有可能一些活跃用户他可能会连续不断的去点击他感兴趣的人的个人主页，比如连续1个小时都在不停的点击。



所以其实这类社交APP他的高峰期QPS时很高的。在当时的场景中，这个社交APP流量最大的个人主页模块高峰期最多每秒会有10万+的QPS。



当然在底层存储中，这些个人主页数据一定是基于缓存来存放的，也就是基于Redis缓存来查询这些个人主页数据。



所以，综合我们分析出来的这个背景，我们在这里可以用下面一幅图来让大家了解一下这个社交APP的一个情况。

![01.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70688900_1566838051.png)





**3、高并发查询导致对象快速进入老年代**



之前已经用大量的图示给大家分析过了JVM的运行原理了，所以在这个案例中就不再给大家描述的过于细节。



这里就直接给大家分析一下当时案例发生的一个场景，因为这个社交APP的日活用户涨的很快，所以导致他的高峰期QPS很快就飙升到了10万。



正是因为每秒并发量太高，这也直接导致了这个系统在高峰期的时候，年轻代的Eden区会迅速的被填满，并且频繁的触发Young GC，如下图所示。



![02.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/82132300_1566838051.png)



而且每次在Young GC的时候，实际上还有很多请求是没处理完毕的，没办法，因为每秒请求量太多了，所以在你触发Young GC的时候，就这一瞬间，必然有很多请求是还没处理完毕的。



这就导致Eden区中其实每次触发Young GC的时候，都有很多对象是需要存活下来的



如下图所示：

![03.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92778800_1566838051.png)



因此在高峰期的时候，其实经常会出现Young GC过后存活对象较多，在Survivor区中放不下的问题，如下图所示。



![04.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8606200_1566838052.png)



所以此时必然会导致大量的对象快速的进入老年代中，如下图所示。



![05.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/19499700_1566838052.png)





**4、老年代必然会触发频繁GC**



其实根据之前学过的知识，大家都清楚了一点，那就是一旦在高并发场景下Young GC后存活对象过多，导致对象快速进入老年代，必然会频繁触发老年代的GC，对老年代进行垃圾回收。



所以在上述社交APP高峰期高并发场景下，必然会导致个人主页服务对应的JVM频繁的发生老年代的GC，如下图所示。



![06.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33958400_1566838052.png)





**5、优化前的线上系统JVM参数**



其实大家都知道，针对上述场景，最核心的优化点，主要应该是增加机器，尽量让每台机器承载更少的并发请求，减轻压力。



同时，给年轻代的Survivor区域更大的内存空间，让每次Young GC后的存活对象务必停留在Survior中，别进入老年代。



但是在这里我们先不考虑上述优化，在优化前的线上系统中，对JVM有两个比较关键的参数大家可以看一下：



-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5



大家可以看到这个是什么意思，其实非常明显，我们之前讲过这两个参数的含义。CMS垃圾回收器默认是采用标记-清理算法，所以是会造成大量的内存碎片的。



什么叫内存碎片？我们再来看下图回顾一下



比如现在老年代内存里有一些垃圾对象。



![07.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/48826600_1566838052.png)



然后CMS垃圾回收器一次垃圾回收过后，回收掉了一些垃圾对象，此时可能内存里看起来跟下面这样：



![08.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/66319600_1566838052.png)



大家注意上面那个红圈的地方，因为回收掉了一个对象，所以那里出现了一个内存碎片



虽然这里是空白内存，但是假如此时你要是要分配一个对象比较大，没法再上面红圈处放进去呢？那么红圈的那个内存碎片不就没任何意义了？



所以CMS正常垃圾回收，因为使用标记-清理算法，所以必然导致大量的内存碎片。



所以“-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5”两个参数的含义，就是在5次Full GC之后会触发一次Compaction操作，也就是压缩操作



这个操作会把存活对象放到紧邻在一起，避免大量的内存碎片，如下图所示。



![09.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/81068700_1566838052.png)



大家看下上图，是不是发现两个存活对象被挤压在一起了？然后红圈地方是不是多出来一大块连续可用的内存空间？不再是之前的一小片内存碎片了吧？





**6、频繁Full GC导致的大量内存碎片**



但是大家现在要明白一点，上述两个参数“-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5”是设置的5次Full GC之后才会进行一次压缩操作，解决内存碎片的问题，空出来大片的连续可用内存空间。



所以这就直接导致在这5次Full GC的过程中，每一次Full GC之后都会产生大量的内存碎片。



大量的内存碎片会导致很多问题，其中一个问题，就是提高Full GC的频率。



为什么呢？因为大家之前应该还记得我们讲过，触发老年代GC的一个非常重要的条件，就是Young GC后的存活对象无法放入Survivior，就要放入老年代。



但是此时老年代假设也没足够内存放这些对象了，就必须触发Full GC了。



所以大家考虑一个场景，假设如下图所示，一次Full GC过后，老年代中有一部分内存里都是大量的内存碎片，没法放入完整的一些大对象了，只有部分内存是连续可用的内存空间。



如下图所示：



![10.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/93111600_1566838052.png)



这个时候，随着大量对象快速进入老年代，会导致一旦老年代的那块连续可用内存满了，此时很多内存碎片是无法放入更多对象的，就会立马触发下一次Full GC。



比如老年代有2G的内存，其中1.5G是连续可用内存，0.5G是很多内存碎片。



本来老年代如果都是连续空内存的话，那么可能可以对象占用到将近2G才会触发Full GC。



结果现在就是对象占用到了1.5G就需要触发Full GC了，剩下0.5G是没法放任何对象的。

所以这就会导致随着一次一次Full GC导致老年代产生更多的内存碎片，连续可用内存越来越少，触发下一次FUll GC的速度就会越快。



直到几次Full GC之后，才会触发一次Compaction操作去整理内存碎片。





**7、这个案例如何进行优化？**

其实对这个案例进行优化，非常的简单，无法就是用之前讲过的jstat分析一下各个机器上的jvm的运行状况，判断出来每次Young GC后存活对象有多少，然后就是增加Survivor区的内存，避免对象快速进入老年代。



另外一个，在当时对那个系统优化之后，增加了年轻代和Survivor区的大小，但还是会慢慢的有对象进入老年代里，毕竟系统负载很高，彻底让对象不进入老年代也很难做到。所以当时调优过后每小时还是会有一次Full GC。



所以当时第二个参数的优化就是针对CMS内存碎片问题的



在降低了Full GC频率之后，务必设置如下参数“-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”，每次Full GC后都整理一下内存碎片。



否则如果每次Full GC过后，都造成老年代里很多内存碎片，那么必然导致下一次Full GC更快到来，因为内存碎片会导致老年代可用内存变少。



也许第一次Full GC是一小时才有，第二次Full GC也许是40分钟之后，第三次Full GC可能就是20分钟之后，要是不解决CMS内存碎片问题，必然导致Full GC慢慢变得越来越频繁。





**8、今日思考题**



今天给大家留一个小的思考题：去看看你们线上系统的JVM参数，如果用的是CMS垃圾回收器的话，压缩这块是如何设置的？



考虑一下如果不是每次FUll GC后都压缩一次解决内存碎片，会对你们的系统有什么影响？



# 058、案例实战：垂直电商APP后台系统，如何对Full GC进行深度优化？

**1、垂直电商业务背景**



今天给大家讲的这个案例，是我协助另外一个朋友的公司进行全公司级别的JVM性能优化的案例，很多核心的思想其实也跟之前是相同的，只不过在优化的过程中会带出来一些比较高级的参数的调优。



先给大家说一下这个公司的大致业务背景，这是一个垂直电商公司，做的是一个垂直电商APP



之前的文章里给大家提过，其实现在除了淘宝、京东、天猫、唯品会这些超大型的电商平台之外，国内还是有很多中小型的垂直类电商公司的。



他们做的主要是一些细分领域的电商业务，比如说有的APP专门做消费分期类的电商业务，在他们的APP里你主要是进行购物，然后可以分期付费。



还有的APP，他专门是做服装定制的，他可能是会在APP里让你选购商品，然后有人上门给你定制化的测量身体，然后给你做定制的衬衫或者西装之类的。



还有的APP，他是做时尚潮流服饰的，就是专门售卖针对年轻人的一些潮牌、设计师的品牌，等等。



所以这个朋友的公司就是类似上述的那种垂直电商APP，专门做某个细分领域的。



说实话，这个垂直电商APP大致注册用户量有就数百万的规模，不算多大，而且每日活跃用户数量也就几十万而已，每天APP的整体请求量也就小几千万的级别，也并不大。高峰期的QPS也就每秒数百请求罢了。



但即使如此的一个普通APP的后台系统，感觉上压力一点儿都不大，是不是真的就没有JVM的性能问题呢？



当然不是了，这个APP虽然不大，但是他同样有JVM相关的性能问题，而且也需要一些细致的优化才可以。





**2、垂直电商APP的JVM性能问题**



那么类似这样的一个垂直电商APP，他的JVM性能问题在哪里呢？



很简单，问题就出在类似这样的一个创业型互联网公司，虽然有少数几个技术比较好的架构师，但是架构师往往没那么大精力把控到特别细节的地方



所以大部分的一线普通工程师可能都对JVM这块没有那么的精通，起码说对我们的专栏里讲解的JVM相关原理和优化手段，都没了解。



所以这直接导致一个很大的问题，那就是大部分的一线工程师开发完一个系统之后，部署生产环境的时候往往就不会对JVM进行什么参数的设置，可能很多时候就是用一些默认的JVM参数。



默认的JVM参数绝对是系统负载逐渐增高的时候一个最大的问题



如果你不设置-Xmx、-Xms之类的堆内存大小的话，你启动一个系统，可能默认就给你几百MB的堆内存大小，新生代和老年代可能都是几百MB的样子。



所以当时这个垂直电商APP的很多后台系统，基本都是用的默认JVM参数部署启动的，前期是没什么问题，但是中后期开始，当有一定用户量，有一定负载了，此时就会出现一些问题了。



大家通过之前大量的学习，哪怕现在不画图，脑子里都有一个概念了，那就是新生代内存过小，会导致Survivor区域内存过小，同时Eden区域也很小。



Eden区域过小，自然会导致频繁的触发Young GC，Survivor区域过小，自然会导致经常在Young GC之后存活对象其实也没多少，但就是Survivor区域放不下。



此时必然会导致对象经常进入老年代中，因此也必然会导致老年代过一段时间就放满了，然后就会触发Full GC。



所以当时这个垂直电商APP的各个系统通过jstat分析JVM GC之后发现，基本上高峰期的时候，Full GC每小时都会发生好几次。



Full GC一般在正常情况下，都是以天为单位发生的，比如每天发生一次，或者是几天发生一次Full GC。



要是每小时都发生几次Full GC，那么就会导致系统每小时都卡顿好几次。这个时候必然是不行的。



在这个背景下，当时我的朋友是那家公司的架构师，找到我帮忙，在分析系统情况过后，定制了一套公司级别的JVM参数模板



在大部分工程师都对JVM优化不是很精通的情况下，通过推行一个JVM参数模板，让各个系统短时间内迅速就优化了JVM的性能。





**3、公司级别的JVM参数模板**



其实这个公司级别的或者团队级别的JVM参数模板，是一个很有用的东西，因为大家要知道，并不是每个人都会来学习我们的这个JVM专栏，也就意味着并不是每个人都是可以比较精通JVM的核心运行原理和性能优化的。



所以如果你是一个团队的leader，或者是一个中小型公司的架构师，那么必然是需要为团队或者公司定制一套基本的JVM参数模板的



然后尽量让大部分系统套用这个模板，基本保证JVM性能别太差，避免很多初中级工程师直接使用默认的JVM参数，可能一台8G内存的机器上，JVM堆内存就分配了几百MB。



下面我们可以来看看当时我和那位朋友一起定制出来的适合他们公司的JVM参数模板：



-Xms4096M -Xmx4096M -Xmn3072M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0



为什么如此定制JVM参数模板呢？



首先，8G的机器上给JVM堆内存分配4G就差不多了，毕竟可能还有其他进程会使用内存，一般别让JVM堆内存把机器内存给占满。



然后年轻代给到3G，之所以给到3G的内存空间，就是因为让年轻代尽量大一些，进而让每个Survivor区域都达到300MB左右。



根据当时对这个业务系统的分析，假设用默认的JVM参数，可能年轻代就几百MB的内存，Survivor区域就几十MB的内存



那么每次垃圾回收过后存活对象可能会有几十MB，这是因为在垃圾回收的一瞬间可能有部分请求没处理完毕，此时会有几十MB对象是存活的，所以很容易触发动态年龄判定规则，让部分对象进入老年代。



所以在分析过后，给年轻代更大内存空间，让Survivor空间更大，这样在Young GC的时候，这一瞬间可能有部分请求没处理完毕，有几十MB的存活对象，这个时候在几百MB的Survivor空间中可以轻松放下，绝对不会进老年代。



基本上在这个内存分配之下，对于这个垂直电商APP的大部分后台业务系统，都是可以轻松hold住的



不同的系统运行时的情况略有不同，但是基本上都是在每次Young GC过后存活几MB~几十MB的对象，所以此时在这个参数模板下，都可以抗住。



只要把内存分配完毕，那么对象进入老年代的速度是极慢极慢的，经过这个参数模板在朋友公司全部系统的重新部署和上线，各个团队通过jstat观察，基本上发现各个系统的Full GC都变成了几天才会发生一次。



此时在参数模板里还会加入Compaction相关的参数，保证每次Full GC之后都会执行一次压缩，解决内存碎片的问题。



关于内存碎片的影响和优化，上一篇文章刚刚分析过，那是为另外一个朋友的公司专门做优化的时候调整的参数。





**4、如何优化每次Full GC的性能？**



这里给大家再介绍一下当时帮那位朋友做优化的时候调整的另外两个参数，这个两个参数可以帮助优化FUll GC的性能，把每次Full GC的时间进一步降低一些。



一个参数是“-XX:+CMSParallelInitialMarkEnabled”，这个参数会在CMS垃圾回收器的“初始标记”阶段开启多线程并发执行。



大家应该还记得初始标记阶段，是会进行Stop the World的，会导致系统停顿，所以这个阶段开启多线程并发之后，可以尽可能优化这个阶段的性能，减少Stop the World的时间。



另外一个参数是“-XX:+CMSScavengeBeforeRemark”，这个参数会在CMS的重新标记阶段之前，先尽量执行一次Young GC。



**这样做有什么作用呢？**



其实大家都记得，CMS的重新标记也是会Stop the World的，所以所以如果在重新标记之前，先执行一次Young GC，就会回收掉一些年轻代里没有人引用的对象。



所以如果先提前回收掉一些对象，那么在CMS的重新标记阶段就可以少扫描一些对象，此时就可以提升CMS的重新标记阶段的性能，减少他的耗时。



所以当时在JVM参数模板中，同样加入了这两个参数：



-Xms4096M -Xmx4096M -Xmn3072M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark





**5、垂直电商APP全公司采用JVM参数模板之后的效果**



上述JVM参数模板，推广到了朋友公司的全部系统中，因为当时公司里几乎一线工程师对JVM优化的理解都达不到这个专栏讲解的水准，很多人都理解非常粗浅的，所以这套JVM模板参数是全部推行的。



经过各个团队采用jstat观察JVM GC情况，发现明显有了很大的好转，基本上各个系统的Young GC都在几分钟一次，或者十几分钟一次，每次耗时就几十毫秒而已。



Full GC基本都在几天一次，每次耗时在几百毫秒的样子。



基本上各个系统的JVM达到这个性能，就对线上系统没多大影响了。哪怕是不太懂JVM优化的普通工程师只要套用这个模板，对一些普通的业务系统，都能保证其JVM性能不会出现大的问题，比如频繁的Young GC和Full GC导致的系统频繁卡顿。





**6、今日思考题**



今天让大家思考一下：



- 你们公司有没有类似这里讲的JVM参数模板？



- 假如你是公司的架构师，结合你们公司的大部分业务系统的实际情况，会如何定制一套JVM参数模板？

  

- 是否你们公司有各种不同配置的机器？

  

- 针对不同配置的机器如何定制JVM参数模板？

  

- 你们公司有没有那种特例的系统，比如并发量特别高或者数据量非常大？

  

- 对特例系统该如何进行优化?

# 059、案例实战：新手工程师不合理设置JVM参数，是如何导致频繁Full GC的？

  2019-08-29 07:00:00

**1、本文背景**



本文会给大家讲解一个比较特殊的JVM优化案例，这个优化案例本身是因为新手工程师对JVM优化可能了解了一个半吊子，然后不知道从哪里找来了一个非常特殊的JVM参数错误的设置了一下，就导致线上系统频繁的出现Full GC的问题。



但是我们后续大量的优化案例其实都是各种各样奇形怪状的场景，因为正是各种奇怪场景才能让大家逐步积累出来较为丰富的JVM优化实战经验



了解的场景越多，自己未来在处理JVM性能问题的时候才能更是得心应手。







**2、问题的产生**



这个场景的发生大致如下过程：某天团队里一个新手工程师大概是心血来潮，觉得自己网上看到了某个JVM参数，以为学会了绝世武功秘籍，于是就在当天上线一个系统的时候，自作主张设置了一个JVM参数



这个参数是什么呢？



不用急，跟着看下面的案例分析即可，现在只要知道他设置了一个奇怪的参数，接着事故就发生了。



因为一般中大型公司都是接入类似Zabbix、OpenFalcon或者公司自研的一些监控系统的，监控系统一般都做的很好，可以让你的系统直接接入进去，然后在上面可以看到每台机器的CPU、磁盘、内存、网络的一些负载。



而且可以看到你的JVM的内存使用波动折线图，还有你的JVM GC发生的频率折线图。包括如果你自己上报某个业务指标，也可以在监控系统里看到。



而且一般都会针对线上运行的机器和系统设置一些报警，比如说，你可以设置如果10分钟内发现一个系统的JVM发生了超过3次Full GC，就必须发送报警给你，可以发送给你的短信、邮箱或者是钉钉之类的IM工具。



类似这样的监控系统不在我们的专栏范畴内，建议大家自己可以去查阅资料，其实基于我们讲解的命令行工具，比如jstat，你可以通过linux上的一些命令，让jstat自动对jvm进行监控，把监控结果可以输出到机器的某个文件里去。



然后第二天你就可以去查阅那个文件，也可以看到那台机器的jvm的一些gc统计。



所以说，没有可视化工具，用最简单的命令行工具，其实同样可以起到类似的效果。



所以那天那个工程师设置了一个JVM参数之后，直接导致线上频繁接到JVM的Full GC的报警，大家就很奇怪了，于是就开始排查那个系统了。







**3、查看GC日志**



之前已经给大家讲解过如何在启动系统的时候让他输出GC日志，所以一旦发现报警，直接登录到线上机器，然后就看到对应的GC日志了。



此时我们看到在GC日志中有大量的Full GC的记录。



那么是为什么导致的Full GC呢？



在日志里，看到了一个“Metadata GC  Threshold”的字样，类似于如下日志：



【Full GC（Metadata GC  Threshold）xxxxx, xxxxx】



从这里就知道，这频繁的Full GC，实际上是JDK 1.8以后的Metadata元数据区导致的，也就是类似我们之前说的永久代。



这个Metadata区域一般是放一些加载到JVM里去的类的。



所以此时就很奇怪了，为什么会因为Metadata区域频繁的被塞满，进而触发Full GC？而且Full GC大家都知道，会带动CMS回收老年代，还会回收Metadata区域本身。



我们先看看下图：

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/14758900_1566981015.cn/txdocpic/0/0736b7cba40d8420b1b9f685f8e7c737/0)             

**4、查看Metaspace内存占用情况**



接着我们当然是想看一看Metaspace区域的内存占用情况了，简单点你可以通过jstat来观察，如果有监控系统，他会给你展示出来一个Metaspace内存区域占用的波动曲线图，类似下面这种。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54213500_1566981015.cn/txdocpic/0/a6542d9da6fbe98fc0a10c48be4adea9/0)            



看起来Metaspace区域的内存呈现一个波动的状态，他总是会先不断增加，达到一个顶点之后，就会把Metaspace区域给占满，然后自然就会触发一次Full GC，Full GC会带着Metaspace区域的垃圾回收，所以接下来Metaspace区域的内存占用又变得很小了。







**5、一个综合性的分析思路**



看到这里，相信大家肯定有一点感觉了，这个很明显是系统在运行过程中，不停的有新的类产生被加载到Metaspace区域里去，然后不停的把Metaspace区域占满，接着触发一次Full GC回收掉Metaspace区域中的部分类。



然后这个过程反复的不断的循环，进而造成Metaspace区域反复被占满，然后反复导致Full GC的发生，如下图所示。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/82068200_1566981015.cn/txdocpic/0/1f8023779c2a550de4c4009f0474f720/0)            



**6、到底是什么类不停的被加载？**



接着我们就有点奇怪了，到底是什么类不停的被加载到JVM的Metaspace区域里去？



这个时候就需要在JVM启动参数中加入如下两个参数了：



“-XX:TraceClassLoading -XX:TraceClassUnloading”



这两个参数，顾名思义，就是追踪类加载和类卸载的情况，他会通过日志打印出来JVM中加载了哪些类，卸载了哪些类。



加入这两个参数之后，我们就可以看到在Tomcat的catalina.out日志文件中，输出了一堆日志，里面显示类似如下的内容：



【Loaded sun.reflect.GeneratedSerializationConstructorAccessor from __JVM_Defined_Class】



明显可以看到，JVM在运行期间不停的加载了大量的所谓“GeneratedSerializationConstructorAccessor”类到了Metaspace区域里去



如下图所示

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13175700_1566981016.cn/txdocpic/0/4fe746fdece2588511a2fc35d46a6673/0)      



相信就是因为JVM运行期间不停的加载这种奇怪的类，然后不停的把Metaspace区域占满，才会引发不停的执行Full GC的。



**这是一个非常实用的技巧，各位同学一定要掌握**，频繁Full GC不光是老年代触发的，有时候也会因为Metaspace区域的类太多而触发。



到此为止，已经慢慢接近真相了。





**7、为什么会频繁加载奇怪的类？**



接着遇到类似这种问题，我们就应该找一下Google或者是百度了，当然推荐是用Google。你完全可以看看那种不停加载的类，到底是什么类，是你自己写的类？还是说JDK内置的类？



比如上面的那个类，如果你查阅一些资料，很容易就会搞明白，那个类大概是在你使用Java中的反射时加载的，所谓反射代码类似如下所示。



Method method = XXX.class.getDeclaredMethod(xx,xx);

method.invoke(target,params);



友情提示一下，反射是Java中最最基础的一个概念，不懂的朋友自己查一下资料。



简单来说，就是通过XXX.class获取到某个类，然后通过geteDeclaredMethod获取到那个类的方法。



这个方法就是一个Method对象，接着通过Method.invoke可以去调用那个类的某个对象的方法，大概就这个意思。



在执行这种反射代码时，JVM会在你反射调用一定次数之后就动态生成一些类，就是我们之前看到的那种莫名其妙的类



下次你再执行反射的时候，就是直接调用这些类的方法，这是JVM的一个底层优化的机制。



看到这里，有的小伙伴是不是有点蒙？



其实这倒无所谓，这段话看的蒙丝毫不影响你进行JVM优化的



**你只要记住一个结论：如果你在代码里大量用了类似上面的反射的东西，那么JVM就是会动态的去生成一些类放入Metaspace区域里的。**



所以上面看到的那些奇怪的类，就是由于不停的执行反射的代码才生成的，如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47066800_1566981016.cn/txdocpic/0/60712831855deba847abf7e93314a137/0)             

**8、JVM创建的奇怪类有什么玄机？**



那么接下来我们就很奇怪一件事情，就是JVM为什么要不停的创建那些奇怪的类然后放入Metaspace中去？



其实这就要从一个点入手来分析一下了，因为上面说的那种JVM自己创建的奇怪的类，他们的Class对象都是SoftReference，也就是软引用的。



大家可千万别说连类的Class是什么都没听说过？简单来说，每个类其实本身自己也是一个对象，就是一个Class对象，一个Class对象就代表了一个类。同时这个Class对象代表的类，可以派生出来很多实例对象。



举例来说，Class Student，这就是一个类，他本身是由一个Class类型的对象表示的。



但是如果你走一个Student student = new Student(），这就是实例化了这个Student类的一个对象，这是一个Student类型的实例对象。



所以我们这里所说的Class对象，就是JVM在发射过程中动态生成的类的Class对象，他们都是SoftReference软引用的。



所谓的软引用，最早我们再一篇文章里说过，正常情况下不会回收，但是如果内存比较紧张的时候就会回收这些对象。



那么SoftReference对象到底在GC的时候要不要回收是通过什么公式来判断的呢？



是如下的一个公式：**clock - timestamp <= freespace \* SoftRefLRUPolicyMSPerMB**。



这个公式的意思就是说，“clock - timestamp”代表了一个软引用对象他有多久没被访问过了，freespace代表JVM中的空闲内存空间，SoftRefLRUPolicyMSPerMB代表每一MB空闲内存空间可以允许SoftReference对象存活多久。



举个例子，假如说现在JVM创建了一大堆的奇怪的类出来，这些类本身的Class对象都是被SoftReference软引用的。



然后现在JVM里的空间内存空间有3000MB，SoftRefLRUPolicyMSPerMB的默认值是1000毫秒，那么就意味着，此时那些奇怪的SoftReference软引用的Class对象，可以存活3000 * 1000 = 3000秒，就是50分钟左右。



当然上面都是举例而已，大家都知道，一般来说发生GC时，其实JVM内部或多或少总有一些空间内存的，所以基本上如果不是快要发生OOM内存溢出了，一般软引用也不会被回收。



所以大家就知道了，按理说JVM应该会随着反射代码的执行，动态的创建一些奇怪的类，他们的Class对象都是软引用的，正常情况下不会被回收，但是也不应该快速增长才对。





**9、为什么JVM创建的奇怪的类会不停的变多？**



那么究竟为什么JVM创建的那些奇怪的类会不停的变多呢？



原因很简单，因为文章开头那个新手工程师不知道从哪里扒出来了SoftRefLRUPolicyMSPerMB这个JVM启动参数，他直接把这个参数设置为0了。



他想的是，一旦这个参数设置为0，任何软引用对象就可以尽快释放掉，不用留存，尽量给内存释放空间出来，这样不就可以提高内存利用效率了么？



**真是想的很傻很天真。**



实际上一旦这个参数设置为0之后，直接导致clock - timestamp <= freespace * SoftRefLRUPolicyMSPerMB这个公式的右半边是0，就导致所有的软引用对象，比如JVM生成的那些奇怪的Class对象，刚创建出来就可能被一次Young GC给带着立马回收掉一些。



如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79082200_1566981016.cn/txdocpic/0/c86edc96839d4a9d0faf1f01a0ced8d8/0)            



比如JVM好不容易给你弄出来100个奇怪的类，结果因为你瞎设置软引用的参数，导致突然一次GC就给你回收掉几十个类



接着JVM在反射代码执行的过程中，就会继续创建这种奇怪的类，在JVM的机制之下，会导致这种奇怪类越来越多。



也许下一次gc又会回收掉一些奇怪的类，但是马上JVM还会继续生成这种类，最终就会导致Metaspace区域被放满了，一旦Metaspace区域被占满了，就会触发Full GC，然后回收掉很多类，接着再次重复上述循环，如下图所示。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10869600_1566981017.cn/txdocpic/0/f5c56edb0355e350898a96633dcc9089/0)            



其实很多人会有一个疑问，到底为什么软引用的类因为错误的参数设置被快速回收之后，就会导致JVM不停创建更多的新的类呢？



其实大家不用去扣这里的细节，这里有大量的底层JDK源码的实现，异常复杂，要真的说清楚，得好几篇文章才能讲清楚JDK底层源码的这些细节。



大家只要记住这个结论，明白这个道理就好。







**10、如何解决这个问题？**



虽然底层JDK的一些实现细节我们没分析，但是大致梳理出来了一个思路，大家也很清楚问题所在和原因了



解决方案很简单。在有大量反射代码的场景下，大家只要把



-XX:SoftRefLRUPolicyMSPerMB=0



这个参数设置大一些即可，千万别让一些新手同学设置为0，可以设置个1000，2000，3000，或者5000毫秒，都可以。



提高这个数值，就是让反射过程中JVM自动创建的软引用的一些类的Class对象不要被随便回收，当时我们优化这个参数之后，就可以看到系统稳定运行了。



基本上Metaspace区域的内存占用是稳定的，不会来回大幅度波动了。







**11、今日思考题**



结合昨天的内容，**大家思考一下这个线上事故的本质是什么？**



其实说白了不是JVM的问题，是人的问题。



大家可以考虑一下，如果你是公司的架构师，是否应该严格审核各个系统的生产环境JVM参数？



比如完全可以推行一套JVM参数模板，如果有人要做定制的JVM优化，是不是应该先在测试环尝试一下，然后还得交给你们高级别的架构师来审核？



如果有人审核，那么就不会发生类似之类的血案了。

# 060、案例实战：一次线上系统每天数十次Full GC导致频繁卡死的优化实战！

**1、案例开始前的说明**



今天的这个案例也是我们之前线上系统经历过的一个真实的生产JVM优化案例，这个优化的过程比较复杂，经过了多次优化，当然核心原理和知识其实还是之前给大家讲解过的那些东西。



只不过这个真实生产系统优化的过程大家如果能理解透彻，那么对于大家利用学过的知识和掌握的工具自己去进行JVM优化的时候，肯定是大有好处的。



这个线上系统是一个团队开发的，那个团队开发完一个新系统上线之后发现一天的Full GC次数多大数十次，甚至有的时候会上百次，大家可想而知这是什么概念！



通常来说，我们建议的一个比较良好的JVM性能，应该是Full GC在几天才发生一次，或者是最多一天发生几次而已。



所以当时这个新系统在线上的表现非常不好，明显是有经常性的卡顿的，因此针对这个系统，我们进行了一连串的排查、定位、分析和优化



下面就给大家分析一下整个优化的过程。





**2、未优化前的JVM性能分析**



大家还记得之前带着大家动手实操过的jstat工具吧？那个工具是非常好用，非常实用，也是非常常用的一个工具。



因为很多中小型公司都没上那种可视化的监控平台，没法直接可视化的看到JVM各个区域的内存变化，GC次数和GC耗时。



当然，如果有办法的话，我建议大家可以给自己所在公司推荐一下类似Zabbix、Ganglia、Open-Falcon、Prometheus之类的可视化监控平台，其实接入都非常简单，如果把线上系统接入了这些平台，可以直接图形化看到JVM的表现。



但是哪怕你有了可视化监控平台，有时候直接对线上系统进行分析的时候，还是jstat更加好用和直接。



所以当时我们通过监控平台+jstat工具分析，直接得出当时没优化过的系统的JVM性能表现大致如下：



- 机器配置：2核4G
- JVM堆内存大小：2G
- 系统运行时间：6天
- 系统运行6天内发生的Full GC次数和耗时：250次，70多秒
- 系统运行6天内发生的Young GC次数和耗时：2.6万次，1400秒



综合分析一下，就可以知道，大致来说每天会发生40多次Full GC，平均每小时2次，每次Full GC在300毫秒左右；



每天会发生4000多次Young GC，每分钟会发生3次，每次Young GC在50毫秒左右。



上述数据对任何一个线上系统，用jstat可以轻松看出来，因为jstat显示出来的Full GC和Young GC的次数都是系统启动以来的总次数，耗时都是所有GC加起来的总耗时，所以直接可以拿到上述数据，略微分析一下就知道具体情况了。



基本看起来，这个系统的性能是相当差了，每分钟3次Young GC，每小时2次Full GC，这种系统是必须得进行优化的。







**3、未优化前的线上JVM参数**



下面是未优化前的线上JVM参数，大致如下：



-Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=5 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=68 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC



其实基本上跟我们之前看到的参数没多大的不同，一个4G的机器上，给JVM的堆内存是设置了1.5G的大小，其中新生代是给了512M，老年代是1G。



比较关键的是“-XX:SurvivorRatio”设置为了5，也就是说，Eden:Survivor1:Survivor2的比例是5:1:1



所以此时Eden区域大致为365M，每个Survivor区域大致为70MB。



而且这里有一个非常关键的参数，那就是“-XX:CMSInitiatingOccupancyFraction”参数设置为了68



所以一旦老年代内存占用达到68%，也就是大概有680MB左右的对象时，就会触发一次Full GC。



此时整个系统的内存模型图如下所示：



​      ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/22735200_1567089586.cn/txdocpic/0/cc767188e28d05a62acc1801460915e6/0)            

**4、根据线上系统的GC情况倒推运行内存模型**



接着我们可以根据系统的内存模型以及GC情况，直接根据学习过的知识推导出系统运行时的内存模型了。



首先我们知道每分钟会发生3次Young GC，说明系统运行20秒就会让Eden区满，也就是产生300多MB的对象，平均下来系统每秒钟会产生15~20MB的对象，如下图所示。



​      ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45597600_1567089586.cn/txdocpic/0/c1a252d79fd3c30f4c8ea8e9b7ac1541/0)            



所以20秒左右就会导致Eden区满，然后触发一次Young GC。



接着我们根据每小时2次Full GC推断出，30分钟会触发一次Full GC



根据“-XX:CMSInitiatingOccupancyFraction=68”参数的设置，应该是在老年代有600多MB左右的对象时大概就会触发一次Full GC，因为1GB的老年代有68%空间占满了就会触发CMS的GC了。



所以系统运行30分钟就会导致老年代里有600多MB的对象，进而触发CMS垃圾回收器对老年代进行GC，如下图。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/75931400_1567089586.cn/txdocpic/0/b1e23c04edc338a5c0e63f52997afed6/0)            

所以基本上我们就能根据推导出的运行内存模型得出一个结论：



每隔20秒会让300多MB的Eden区满触发一次Young GC，一次Young GC耗时50毫秒左右。



每隔30分钟会让老年代里600多MB空间占满，进而触发一次CMS的GC，一次Full GC耗时300毫秒左右。



但是到这里大家先暂停一下，有的朋友可能立马会推断了，他会说，是不是因为Survivor区域太小了，导致Young GC后的存活对象太多放不下，就一直有对象流入老年代，进而导致30分钟后触发Full GC？



实际上仅仅只是分析到这里，绝对不能草率下这个判断的。



因为老年代里为什么有那么多的对象？有可能是每次Young GC后的存活对象较多，Survivor区域太小，放不下了



也有可能是有很多长时间存活的对象太多了，都积累在老年代里，始终回收不掉，进而导致老年代很容易就达到68%的占比触发GC。



所以仅仅分析到这里，绝对不能轻易下结论。





**5、老年代里到底为什么会有那么多的对象？**



分析到这里，说句实话，仅仅根据可视化监控和推论是绝对没法往下分析了，因为我们并不知道老年代里到底为什么会有那么多的对象



此时就完全可以用jstat在高峰期观察一下JVM实际运行的情况。



通过jstat的观察，我们当时可以明确看到，每次Young GC过后升入老年代里的对象很少



一般来说，每次Young GC过后大概就存活几十MB而已，那么Survivor区域因为就70MB，所以经常会触发动态年龄判断规则，导致偶尔一次Young GC过后有几十MB对象进入老年代。



我们看下图的图示。



​      ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3525000_1567089587.cn/txdocpic/0/d6c042b0833f47495b08b88f0cffcbd9/0)            



因此分析到这里很奇怪，因为通过jstat追踪观察，并不是每次Young GC后都有几十MB对象进入老年代的，而是偶尔一次Young GC才会有几十MB对象进入老年代，记住，是偶尔一次！



所以正常来说，应该不至于30分钟就导致老年代占用空间达到68%。



那么老年代里到底为什么有那么多对象呢？



这个时候我们通过jstat运行的时候就观察到一个现象，就是老年代里的内存占用在系统运行的时候，不知道为什么系统运行着运行着，就会突然有几百MB的对象占据在里面，大概有五六百MB的对象，一直占据在老年代中



大家看下图。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38876000_1567089587.cn/txdocpic/0/b5f28da60d71dd64ee40ed5f3c90d34b/0)            



正是因为系统运行的时候，不知道为什么突然有有几百MB对象进入老年代中，所以才导致Young GC偶尔一次让几十MB对象升入老年代，平均30分钟左右就会触发一次Full GC！！！



那么我们就很奇怪了，为什么系统运行着会突然有几百MB的对象进入老年代？



答案已经呼之欲出了，**大对象！**



一定是系统运行的时候，每隔一段时间就会突然产生几百MB的大对象，直接进入老年代，不会走年轻代的Eden区域。



然后再配合上年轻代还偶尔会有Young GC后几十MB对象进入老年代，所以才会30分钟触发一次Full GC！



大家看如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/71526400_1567089587.cn/txdocpic/0/a6fcc129ee368c8fda0a3b45ce157d9d/0)             



**6、定位系统的大对象**



分析到这里，就很简单了，我们只需要采用之前给大家介绍的jmap工具，通过后台jstat工具观察系统，什么时候发现老年代里突然进入了几百MB的大对象，就立马用jmap工具导出一份dump内存快照。



接着可以采用之前说过的jhat，或者是Visual VM之类的可视化工具来分析dump内存快照



关于Visual VM之类的工具，大家自行百度即可，非常简单易用，其实本质就是让你分析导出的内存快照。



通过内存快照的分析，直接定位出来那个几百MB的大对象，就是几个Map之类的数据结构，这是什么东西？直接让负责写那个系统代码的几个同学分析了一下，明显是从数据库里查出来的！



因为那个系统仅仅就是操作数据库而已，不存在别的什么特殊操作。



然后这个时候也没太好的办法了，直接笨办法，几个人地毯式排查这个系统的所有SQL语句，结果还真的有一个人发现，自己的一个SQL居然在某种特殊的场景下，会类似如下所示：



select * from tbl。



这是啥意思？就是没有where条件！



没有where条件，就代表这个SQL可能会把表中几十万条数据直接全部查出来！



正是因为这个代码层面的bug，导致了每隔一段时间系统会搞出几个上百MB的大对象，这些对象是会全部直接进入老年代的！



然后过一会儿随着偶尔几次Young GC有几十MB对象进入老年代，所以平均几十分钟就会触发一次Full GC！！！





**7、针对本案例的JVM和代码优化**



其实分析到这里，这个案例如何优化已经呼之欲出了！



非常简单，分成两步走



第一步，让开发同学解决代码中的bug，避免一些极端情况下SQL语句里不拼接where条件，务必要拼接上where条件，不允许查询表中全部数据。彻底解决那个时不时有几百MB对象进入老年代的问题。



第二步，年轻代明显过小，Survivor区域空间不够，因为每次Young GC后存活对象在几十MB左右，如果Survivor就70MB很容易触发动态年龄判定，让对象进入老年代中。所以直接调整JVM参数如下：



-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=5 -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC



直接把年轻代空间调整为700MB左右，每个Surivor是150MB左右，此时Young GC过后就几十MG存活对象，一般不会进入老年代。



反之老年代就留500MB左右就足够了，因为一般不会有对象进入老年代。



而且调整了参数“-XX:CMSInitiatingOccupancyFraction=92”，避免老年代仅仅占用68%就触发GC，现在必须要占用到92%才会触发GC。



最后，就是主动设置了永久代大小为256MB，因为如果不主动设置会导致默认永久代就在几十MB的样子，很容易导致万一系统运行时候采用了反射之类的机制，可能一旦动态加载的类过多，就会频繁触发Full GC。



这几个步骤优化完毕之后，线上系统基本上表现就非常好了，基本上每分钟大概发生一次Young GC，一次在几十毫秒；



Full GC几乎就很少，大概可能要运行至少10天才会发生一次，一次就耗时几百毫秒而已，频率很低。







**8、今日小思考题**



今天这个案例的特点，是搭配上了大对象的问题排查，当你发现Young GC过后并不是每次都有很多存活对象进入老年代的时候，就得从别的角度考虑一下到底为什么会有那么多的对象进入老年代了。



希望大家可以自己结合这个案例的思路，动手画画图，对这个案例进行一定的分析和推导，自己动手做一下分析，一定可以让你i积累出来JVM优化的思路和经验的！

# 062、第9周作业

2019-09-01 10:00:44

复习题，自己总结本周生产案例的问题定位、原因分析以及解决思路！

# 063、第9周答疑以及学员思考题总结汇总

**问题：**

老师，我这边发生第一次Full GC的时间是在老年代占满50M的时候，请问是为什么？还是说jstat打印出来的第一个FGC=1不算的。。我理了几个会触发FullGC的条件都不成立，第二次Full GC就能理解。

**回答：**

是的，第一次full gc是不太靠谱的，其实没太大必要，可以忽略掉他，关注第二次开始就好了



**问题：**

老师，stw的时候，系统停止，请求发生阻塞。那么老年代比如stw时间比较长，阻塞了很多请求。等这一次垃圾回收完之后，被阻塞的请求开始处理，又会创建很多对象，对jvm造成压力，然后老年代又要gc。所以stw时间久的话，会变相的给系统制造更高的并发，我的理解对吗？

**回答：**

也可以这么来理解，因为阻塞了很多请求，确实会造成瞬时处理请求过多



**问题：**

老师想请问下,2核4G，4核8G的linux机器，能够分配给堆内存的大小最大能有多少呢?

**回答：**

一般不能给到最大，操作系统和其他进程都要占用一些，比如4G的机器，给JVM个2G~3G，8G的机器，给JMV个4G左右，就差不多了



**问题：**

1.老师，g1对于大对象的判定规则是超过region的50%，有参数可以指定超过60%吗，还是通过参数指定region大小从而来指定大对象大小？ 

2.老师，这样理解对吗，parnew回收器和serial回收器的步骤是一样的，只不过parnew是并行的，g1的younggc也跟它们一样，不过它可以指定停顿时间，这中间是串行还是并行呢

**回答：**

1、g1有参数可以控制大对象的，但是建议不要改变 

2、对的，你理解没错，其实都是类似的，多线程的话是并发回收的



**问题：**

像照片这类的图片我们一般都存在阿里云的OSS上，在数据库里只保存一个地址，这样的话个人主页只是文字和连接，最多也就1k吧，请问案例中为啥个人主页的数据会有几MB？

**回答：**

其实文章里解释了，个人主页除了图片还有大量文字，就是每天发的心情说说之类的东西



**问题：**

有一个有趣的现象，为什么 -XX:CMSFullGCsBeforeCompaction=5是大部分公司的设置呢？

我看了下我们公司也是设置为5，据我所知，这个参数模式是0的吧。设置为5这个“规则”是在那本书或者那个文章说出来，然后大家都遵守的吗？感觉是是不是误导了大家。

**回答：**

是的，是有人推荐设置为5，但是其实要考虑一下，如果通过优化之后，让full gc的频率很低，其实就完全可以让他每次full gc之后都compaction一次，那一次fullgc慢点而已，但是不至于大量内存碎片导致下一次fullgc提前到来







**问题：**

老师，访问量和PV这个我可以理解，但是QPS和TPS就区分不出来了。百度了一下，感觉说的都一样，太官方了，看不明白。您可以大白话详细说说QPS和TPS区别吗？ 用压测工具对一个接口压测，出来的是QPS还是TPS

**回答：**

压测工具的是QPS，就是你每秒多少个请求，TPS是每秒的事务量，这个一般用于数据库层面，就是数据库每秒多少个事务





**问题：**

测试服务器，1G的新生代，1G老年代，E区和S区6:2，项目启动的时候，进行了6次YGC,4次FGC，感觉太难优化了

**回答：**

启动就多次gc，一般就是启动的时候系统内置对象太多，只能考虑增加机器内存了，分配更大内存空间



**问题：**

如果用G1回收，它选择回收一部分region，会不会在老年代中对象块与块之间存在空缺部分（块1和块3之间的块2被回收了），下次在分配对象时发现块与块之间的空隙部分放不下新对象（这空隙部分算不算碎片）？

**回答：**

是选择一部分的region，不是选择region中的一部分对象来回收，所以g1是没有碎片问题的。任何一个region回收的时候，都是复制算法，他会把region里的存活对象拷贝到其他region区，然后直接清空这个reigon剩余的垃圾对象。



**问题：**

分析了下我们的系统，服务器不接受任何请求的情况下，大概16分钟左右1次YGC，1.5天左右1次FGC，每次YGC大概8M左右对象进入老年代。但是服务器每次启动都会有3-4次FGC，不知道怎么样去优化

**回答：**

服务器启动的时候很多内置对象，初始化之类的，那个不需要优化，核心是运行期间的优化



**问题：**

例子还是忽略了200M大小大于了S区百分之五十，从而下一次minor gc触发后，会直接把200M放入old的情况吧？

**回答：**

不是的，当时是举例子，你可以把Survior认为是调整更大一些，不触发动态年龄判定



**问题：**

老师，QPS跟TPS的关系是什么?是不是可以说一个TPS可能包含对个QPS

**回答：**

其实一般系统都说QPS，TPS一般用于数据库里的概念，数据库层面每秒多少个事务



**问题：**

所以说高并发加慢处理是导致full gc的元凶之一，从而带来更多的性能问题

**回答：**

对的，其实后续大量的案例都是围绕这个中心点来展开的，反复用大量的案例把最根本的jvm优化原理强化到你们的大脑里去



**问题：**

老师，你有遇到过压测系统的时候，响应时间很慢，但是此时单独打开浏览器访问却很快的情况吗？这个是什么道理，请教下，谢谢

**回答：**

压测的时候慢是因为最高负载把你的机器资源打满了，包括网络和CPU，此时当然系统响应速度变慢了



**问题：**

请教一下 G1相对其他回收器有什么劣势吗，还是说很多地方不用G1只是因为没必要呢

**回答：**

G1未来会成为一个默认的垃圾回收器，好处就是只要指定一个垃圾回收的停顿时间，就可以让g1自动优化了，你一般不用过渡优化。

坏处是你没法精准把控内存分配、使用、垃圾回收，所以有的时候优先使用cms+parnew，如果没问题就不一定用g1。





**问题：**

这些心情啥的我感觉也是是不是也应该分页展示，比如先加载十条，下拉再加载十条这样，感觉这样一次好像也就几k就够了

**回答：**很多时候他会一次性加载出来一大批，那也是够多的了



**问题：**

老师，大堆使用G1 但是设为了不影响系统性能，g1设置了回收允许停顿的时间，每次回收不多少内存， 也就是腾出来的内存并不多，这样会不会提现不出大堆的优势

**回答：**

不会的，大堆你可以尽情的用，但是每次回收一小部分而已，保证垃圾回收不要影响太大



**问题：**

CMS不是扫描老年代的对象吗？那在重新标记之前进行一次YGC，YGC回收年轻代的对象，对提升重新标记的性能有所帮助吗？

**回答：**

CMS扫描老年代的对象是没错的，但是有的时候年轻代和老年代之间的对象有引用关系呢？是不是就会扫描到年轻代去了？

所以提前young gc一次，可以清理掉一些年轻代对象，是有助于提升CMS的重新标记阶段的性能的



**问题：**

不同的机器配置应该是给出不同的jvm参数的 

1、JVM内存超过4G且对系统响应时间敏感的是不是应该采用G1？ 

2、对高并发，容易产生阻塞的系统，是不是考虑减小SurvivorRatio的值？这样可以给S区分配更大的空间，避免短命的对象进入老年代。这样可能会导致YGC会更频繁些，但YGC很快，关系不太大

**回答：**

1、没错，作为架构师或者team leader应该在团队内或者公司内推行统一的jvm参数模板 

2、超过4G还不至于必须用G1，一般超过16G以上的机器可以考虑用G1，普通的机器都是2C4G，或者4C8G的，哪怕是CMS+ParNew也没问题的 

3、高并发、大数据量的系统，建议是让系统负责人根据实际情况去优化各种参数，具体方法参加之前我们讲解的那套理论和思路即可



**学员总结：**

对并发高且核心的系统，还是应该采用之前文章讲授的方法：预估系统的并发量 ---选择合适的服务器配置 ---根据JVM内存模型---设定初始参数---对系统进行压测---观察高峰期对象的增长速率 、GC频率、GC后的存活

然后根据实际的情况来设定jvm参数 --- 最后做好线上jvm监控 。 我能想到的就这么多，请老师补充

**回答：**对的，核心系统一定是要走一整套思路来优化JVM参数的





**问题：**

学到这里我有个想法，就是把老师讲授的优化思路做成一个监控系统，系统通过jstat获取数据，然后给出jvm参数设置建议值，并给出这么设置的理由。不知道有没有这个必要？我感觉还挺好的

**回答：**

其实一般没必要，用一个统一的jvm参数模板就能解决80%的系统问题了，一般合理的参数可以让普通系统都没什么JVM的性能问题。但是如果要做一个类似的工具也没问题的



**学员总结：**

打卡。以前没有注意有个倒序的按钮，每次都要下拉好久，经过老师点评，今天进来就倒排，很方便。

今日思考题来说，目前没有通用设置JVM模板，基本都是默认参数，可能是用户量并不大的缘故吧。不过学习这个专栏以后，可以注意很多细节，学习的知识到下个公司就成了救火队长了，哈哈哈。

**回答：**

非常好，你其实可以根据你们公司各个系统的情况，去线上看一看，尽量站在架构师的角度给出一个较为合理的JVM参数模板，这样无论是对于实际的工作还是跳槽面试都是很有好处的





**问题：**

CMSScavengeBeforeRemark这个参数本意是希望在CMS GC remark之前做一次YGC，正常情况下其实是会做一次YGC的

这个参数的好处是如果YGC比较有效果的话是能有效降低remark的时间长度，可以简单理解为如果大部分新生代的对象被回收了，那作为根的部分少了，从而提高了remark的效率

**回答：**对的，理解正确





**问题：**

动态年龄判断是超过了Survivor区域的50%.请问这区域是指两个Survivor的50%，也就是一个Survivor的内存容量还是一个Survivor的50%？

**回答：**是指代的一个Survivor区域的50%





**问题：**

可能年轻代的某个 GC Root，它引用了老年代的某个对象，这个对象就不能清除，所以CMS应该也要扫描年轻代GC Root，再进行一次YGC就可以减少扫描的年轻代GC链路。

另外G1基于Region收集，通过RememberSet记录引用关系来避免全堆扫描。 不知道我解答的对不对，老师看到的话麻烦补充下。

**回答：**解答的基本没什么问题，很好



**学员总结：**

到了这里和以前的零散经验链接起来了。由于CMS remark阶段需要扫描新生代(原因太长，不说了)，所以整个堆中数量会影响remark阶段的耗时，所以remark之前添加一次可中断的并发预清理(其实就是继续执行并发标记)

另外为了防止并发预清理阶段等太久都不发生young gc，提供了CMSMaxAbortablePrecleanTime 参数来设置等待多久没有等到young gc就强制remark。默认是5s。

但是最终一劳永逸的办法是，添加参数CMSScavengeBeforeRemark，让remark之前强制Minor GC

**回答：**是的，总结的非常好





**问题：**

为什么重标记的时候提前做一次young gc会提高效率？重标记不是只针对老年代的对象进行标记的吗？就算young gc减少了部分对象，重标记也不会去新生代里查找的呀



**回答：**

老年代扫描的时候要确认老年代里哪些对象是存活的，这个时候必然会扫描到年轻代，因为有些年轻代的对象可能引用了老年代的对象，所以提前做young gc可以把年轻代里一些对象回收掉，减少了扫描的时间，可以提升性能



**问题：**

老师看到这里我又产生很多问题了

1.文章中提到大量matedata的软引用经过young gc就回收了。之前我们都很清楚young gc,old gc的触发条件，那么matedata什么时候触发呢？

2.文中的案例中，虽然反射会不断的创建各种奇怪的类，难道每次调反射都会创建不一样的奇怪类吗？如果不是的话，他直接引用已经创建过的奇怪类，也不至于内存一直暴涨啊。

3.这是一个比较非常规的案例，老师对于这种非常规的情况，我们的分析思路与之前要有所改变吗？

**回答：**

1、metadata区域的gc就是他自己满了就触发 

2、从jdk底层实现机制而言，他会创建各种不同的类 

3、其实非常规案例，你们也得了解一下，但是排查思路没什么变化，看文章里的思路，其实还是一步一步去排查的





**问题：**

请问老师，每次Full GC都会回收永久代么？还是说永久代满触发的FullGC才会回收永久代？1.8前的永久代和1.8的Metadata区域的回收时机是一样的么？

**回答：**

无论是old区满了触发的full gc，还是metadata区域满了触发的full gc，都会执行metadata区域的gc





**问题：**

老师，动态生成的类是什么类加载器加载的呀？是系统类加载器吗，是的话，那之前不是说一个class的回收需要加载他的类加载器已经回收了，这个时候系统类加载器是回收了吗？



**回答：**对的，已经回收了





**问题：**

打卡。今天这个案例应该是反射生产的软引用类在触发young gc时实例对象被立刻回收了，而方法区的类对象还在，下次再反射调用的时又得重新加载这个类对象并在年轻代实例化，这样就导致方法区同样的类对象越来越多，很快就需要进行垃圾回收。是这样吗？

如果不是这样那方法区为什么会一直在增长？这些增长的类对象都是不同反射调用的产生的吗？好多疑问。



**回答：**感觉你可能还是没完全理解透彻，可以把本文多看两遍，他其实讲的是对类的回收，类自己本身就是一个Class对象



**问题：**

打卡 本篇内容应该讲的是因为设置了这个参数 ，导致young gc时直接回收了大部分反射时jvm创建的软引用对象 ，导致下一次调用反射继续创建类 和class 。而class被放在元空间，导致元空间很快就满了，接着就是full gc



**回答：**对的，你理解的完全正确







**学员实践总结：**

非常感谢老师的回复。排查了survivor 区放不下的原因，并把 survivor 加大了内存，然后从新捋了一下问题

项目刚启动之后对象都在 Eden区( 很大一部分是永久存活的对象 )，压测之后永久存活的对象达到条件进入老年代了

老年代我分了20M，发生第一次FullGC 之后老年代基本满了(基本都是永久存活的对象，快放不下的感觉)

后面继续触发所有的 MinorGC 时，符合的条件: 老年代可用空间小于历次进入老年代总对象平均大小，所以导致一直是 FullGC

针对这个问题，我把老年代设置成了 100M(足够存永久存活的对象了), 继续压力测试，对象正常走 E-S0-S1 了，使用 jstat 看情况，感觉没有10天半个月都不会触发 fullgc 了。

**回答：**非常好，活学活用，直接就优化上自己的系统了



**问题：**

老师，这个系统运行逻辑是这样吗。比如我点击某个用户的个人主页，如果在redis缓存中存在，则直接返回，如果不存在，则去数据库请求，这个过程会创建一系列对象，多达几m，然后放到redis缓存去。

由于方法生成这些对象后出栈，从而让堆对象成了垃圾对象，以此类推来塞满堆从而触发gc。这样理解对吗老师

**回答：**

是的，就是你理解的这个样子



**问题：**

这篇看了几遍还是比较疑惑： 

1、正常加载的class与文章所说通过反射加载的class，全部都是软引用吗？ 

2、“奇怪的Class对象”是指XXX.class？还是类似GeneratedSerializationConstructorAccessor.class？ 

3、Young GC为什么也会带着回收metaspace里的class对象？ 

4、即使gc后反复重新创建，不是应该只创建不存在的class对象吗？也不会超过最开始的100啊？难道会重复创建相同的class对象？

**回答：**

1、这里仅仅说的是JVM自己生成的Class是软引用 

2、是指那个很长名字的类，其实除了那个类以外还有别的类似的生成的奇怪的类 

3、GC的时候会去检查软引用这种特殊的对象，如果满足条件就会回收，那些Class都是软引用的 

4、对的，因为JDK源码里的实现有一些问题，所以导致并发环境下会重复创建一些Class





**问题：**

老师，这个例子是不是理解下来就是对full gc由metaspace触发的场景讲解。使得我们明白full gc触发不仅仅只是堆空间的old区域不足导致。而原理都是一样，都是对应的区域放满了，放不下了新的对象触发full gc。只是这里的情况是反射导致的对class对象软引用是引用的在非堆的方法区？

如理解有误，望老师指出，指正，谢谢

**回答：**对的，你理解的没错



**问题：**

老师好，后面自己试了下，补了下课。简单来说是不是可以理解为，对于反射的大量，多次调用，会因为nativemethodaccessor的次数影响，默认15次，从而生成最终的generateXXXaccessorXXX的类

这个类的作用在于反射的方法调用转化为本地调用，提升性能。但对于该类的method方法的软引用被回收了，所以导致元数据区多次生成相同的类。导致full gc。感觉这块讲不清楚了。。。

**回答：**其实你理解的没问题，就是这个意思





**学员总结：**

初始标记：标记由4种gc roots直接关键的对象。 

并发标记：对老年代所有的对象进行trace，看是否能与gc roots建立间接关系，我就是gc roots是否可达。 

最终标记：标记并发标记阶段引用变动的对象。 

并发清理：并发清理掉可回收的内存，但是因为用户线程依旧在运行，所以每次full gc都会清理不干净，产生浮动垃圾。 

**回答：**总结的很好



**问题：**

你好，软引用对象的回收，为什么会导致下一次调用反射会继续创建类呢，这里的class放在元空间是说的class还是class对象?

**回答：**Class就是Class对象，具体为什么会因为软引用回收之后继续有新的Class生成，其实是JDK内部本身的一个缺陷，他会在这个场景下生成很多的Class。

具体JDK源码我没分析，因为那个太繁琐，大家其实在这里记住反射场景下的这个问题即可



**问题：**

请问一下dmp打印的内容怎么分析,我用jhat命令查看得到的是下面这样的结果,对象后面只有一个地址,没有显示对象大小,点进去看一个对象的详情也没有显示对象的大小

而且新生代和老年代的对象都混在一起, 那从哪些信息可以判断老年代的哪个对象占用的空间最大

**回答：**jhat是显示出来对象数量和大小的，后面案例中我们会分析MAT、Visual VM之类的更好的工具，别着急



**学员总结：**

1.分析机器情况（机器配置，堆内存大小，运行时长，FullGC次数、时间，YoungGC次数、时间） 

2.查看具体的jvm参数配置 

3.然后根据JVM参数配置梳理出JVM模型，每个区间的大小是多少，画出来JVM模型（考虑每个设置在申请情况下会执行GC） 

4.结合jstat查看的GC情况，在结合JVM模型进行二次分析 

5.jmap dump内存快照，通过jhat或者Visual VM之类的工具查看具体的对象分类情况 

6.根据分析的情况再具体到问题（Bug、或者参数设置等问题） 

7.修复Bug，优化JVM参数

**回答：**总结的非常好



# 064、案例实战：一次线上大促营销活动导致的内存泄漏和Full GC优化

**1、线上故障场景**



先简单说一下业务背景：一次我们线上推了一个大促销活动，大致就是类似于在某个特定节日里，突然给所有用户发短信、邮件、APP Push消息，说现在有个特别优惠的活动，如果参与的话肯定可以得到很大的实惠！



这类大促活动一般都会吸引比平时多几倍的用户短时间内突然登录APP来参与，所以系统一般在这个时候压力会比平时大好几倍。



但是因为从系统的整体设计角度而言，其实给的一些数据库、缓存和机器的资源都是足够的，所以通常而言不该有什么问题。



但是那次大促活动开始之后，直接导致线上一个系统的CPU使用率飙升，而且因为CPU使用率太高，导致系统几乎陷入卡死的状态，无法处理任何请求！



在重启系统之后，会好一段时间，但是很快又立马发现机器的CPU使用率飙升，继续导致系统卡死！



这就是那次大促活动开始之后，那个系统在线上的一个真实的情况。



有人可能会问，那么CPU使用率是怎么观察到飙升的？怎么收到报警的？



其实这个之前已经说过很多次了，中大型公司都会有Zabbix、Open-Falcon、Prometheus之类的监控和告警系统，一旦机器的CPU使用率过高，会直接发送报警给你的短信、邮箱和IM工具（比如钉钉）



所以上面说的大促活动开始之后，某个线上系统的CPU使用率飙升，其实就是得到了报警才知道的，然后在监控系统上还可以去观察CPU的负载曲线，是一个折线图，可以看到CPU负载很高。







**2、初步排查CPU负载过高的原因**



这里给大家说一下线上系统的机器CPU负载过高的两个常见的场景。



第一个场景，是你自己在系统里创建了大量的线程，这些线程同时并发运行，而且工作负载都很重，过多的线程同时并发运行就会导致你的机器CPU负载过高。



第二个场景，就是你的机器上运行的JVM在执行频繁的Full GC，Full GC是非常耗费CPU资源的，他是一个非常重负载的过程



所以一旦你的JVM有频繁的Full GC，带来的一个明显的感觉，一个是系统可能时不时会卡死，因此Full GC会带来一定的“Stop the World”问题，一个是机器的CPU负载很高。



所以一旦知道CPU负载过高的两个原因，就很容易进行排查了。



大家完全可以使用排除法来做，首先看一下JVM Full GC的频率，通过jstat也好，或者是监控平台也好，很容易看到现在Full GC的频率。如果Full GC频率过高，那么就是Full GC引起的CPU负载过高。



那么如果JVM GC频率很正常呢？那就肯定是你的系统创建了过多线程在并发执行负载很重的任务了！



所以当时我们直接通过监控平台就可以看到，JVM的Full GC频率突然变得极为频繁，几乎是每分钟都有一次Full GC。



大家都知道，每分钟一次Full GC，一次至少耗时几百毫秒，这个系统性能绝对很糟糕，而且对机器的CPU负载也是很高的！



既然发现了频繁Full GC了，那肯定就不用去怀疑是系统自己创建过多线程了！







**3、初步排查频繁Full GC的问题**



大家通过之前大量的案例和文章已经初步可以得到结论，如果有频繁Full GC的问题，一般可能性有三个：

1. 内存分配不合理，导致对象频繁进入老年代，进而引发频繁的Full GC；
2. 存在内存泄漏等问题，就是内存里驻留了大量的对象塞满了老年代，导致稍微有一些对象进入老年代就会引发Full GC；
3. 永久代里的类太多，触发了Full GC



当然还有之前案例说过，如果上述三个原因都不存在，但是还是有频繁Full GC，也许就是工程师错误的执行“System.gc()”导致的



但是这个一般很少见，而且之前讲过，JVM参数中可以禁止这种显式触发的GC。



所以一般排查频繁Full GC，核心的利器当然是jstat了，之前我们有大量文章带大家做过jstat分析JVM的实战，这里就不赘述了。



当时我们用jstat分析了一下线上系统的情况，发现并不存在内存分配不合理，对象频繁进入老年代的问题，而且永久代的内存使用也很正常，所以上述三个原因中的两个就被排除掉了。



**那么我们来考虑最后一个原因：老年代里是不是驻留了大量的对象给塞满了？**



对，当时系统就是这个问题！



我们明显发现老年代驻留了大量的对象，几乎快塞满了，所以年轻代稍微有一些对象进入老年代，很容易就会触发Full GC！而且Full GC之后还不会回收掉老年代里大量的对象，只是回收一小部分而已！



所以很明显老年代里驻留了大量的本不应该存在的对象，才导致频繁触发Full GC的。接下来就是要想办法找到这些对象了



之前我们介绍过jmap+jhat的组合来分析内存里的大对象，今天我们介绍另外一个常用的强有力的工具，**MAT**。



因为jhat适合快速的去分析一下内存快照，但是功能上不是太强大，所以一般其实常用的比较强大的**内存分析工具**，就是MAT。







**4、对线上系统导出一份内存快照**



既然都发现线上系统的老年代中驻留了过多的对象的问题，那么肯定要知道这些对象是谁！



所以先用jmap命令导出一份线上系统的内存快照即可：



jmap -dump:format=b,file=文件名 [服务进程ID]



拿到了内存快照之后，其实就是一份文件，接着就可以用jhat、MAT之类的工具来分析内存了。







**5、MAT是如何使用的？**



不少人是通过Eclipse集成的MAT插件来使用的，但是很多人其实开发是用IntelliJ IDEA的，所以这个时候可以直接下载一个MAT来使用即可



给大家官网的下载地址：



https://www.eclipse.org/mat/downloads.php



在这个地址中，就可以下载MAT的最新版本了。



大家选择自己的笔记本电脑的操作系统对应的版本就可以了，他是支持Windows、Mac、Linux三种操作系统的。



下载好MAT后，在他的安装目录里，可以看到一个文件名字叫做：MemoryAnalyzer.ini



这个文件里的内容类似如下所示：



-startup

../Eclipse/plugins/org.eclipse.equinox.launcher_1.5.0.v20180512-1130.jar

--launcher.library

../Eclipse/plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.1.700.v20180518-1200

-vmargs

-Xmx1024m

-Dorg.eclipse.swt.internal.carbon.smallFonts

-XstartOnFirstThread



大家务必要记得，如果dump出来的内存快照很大，比如有几个G，你务必在启动MAT之前，先在这个配置文件里给MAT本身设置一下堆内存大小，比如设置为4个G，或者8个G，他这里默认-Xmx1024m是1G。



接着大家直接启动MAT即可，启动之后看到的界面中有一个选型是：Open a Heap Dump，就是打开一个内存快照的意思，选择他，然后选择本地的一个内存快照文件即可。







**6、基于MAT来进行内存泄漏分析**



使用MAT打开一个内存快照之后，在MAT上有一个工具栏，里面有一个按钮，他的英文是：Leak Suspects，就是内存泄漏的分析。



接着MAT会分析你的内存快照，尝试找出来导致内存泄漏的一批对象。



这时明显可以看到他会显示给你一个大的饼图，这里就会提示你说，哪些对象占用内存过大。



这个时候直接会看到某种自己系统创建的对象占用量过大，这种对象的实例多达数十万个，占用了老年代一大半的内存空间。



接着当然是找开发工程师去排查这个系统的代码问题了，为什么会创建那么多的对象，而且始终回收不掉？



**这就是典型的内存泄漏！**即系统创建了大量的对象占用了内存，其实很多对象是不需要使用的，而且还无法回收掉。



后来找到了一个原因，是在系统里做了一个JVM本地的缓存，把很多数据都加载到内存里去缓存起来，然后提供查询服务的时候直接从本地内存走。



但是因为没有限制本地缓存的大小，并且没有使用LRU之类的算法定期淘汰一些缓存里的数据，导致缓存在内存里的对象越来越多，进而造成了内存泄漏。



解决问题很简单，只要使用类似EHCache之类的缓存框架就可以了，他会固定最多缓存多少个对象，定期淘汰删除掉一些不怎么访问的缓存，以便于新的数据可以进入缓存中。









**7、今日文章总结**



之前给大家讲过，我们的文章会不停的在后面的案例中重复一些之前案例里的内容，原因是学习周期很长，通过这种方式可以定期帮助大家复习和总结。



这篇文章就给大家分析总结了一下之前学习过的几种频繁Full GC的原因，以及分析的方法和思路，这个可以看做是一个复习性的文章。



同时给大家初步介绍了一下MAT这种内存分析的工具，其使用是非常简单的，里面有很多的功能。



而今天之所以没有给大家很多截图，一步一步教大家来用这个工具，就是希望给大家课后留一个作业。



今天的作业就是，希望大家可以自己动手玩一玩MAT，你可以自己运行一段代码，模拟生成一种对象特别多的实例，然后导出一份内存快照，基于MAT来分析一下，就可以看到他是如何清晰的告诉你系统中哪种对象实例过多了！



另外，之后我们会有更多案例，我会带着大家一步一图，使用MAT、Visual VM等工具来深度分析JVM的内存快照，找到一些内存泄漏的问题，后续都会有，咱们一步步来，敬请期待。



#   065、案例实战：百万级数据误处理导致的频繁Full GC问题优化

**1、事故场景**



有一次一个线上系统进行了一次版本升级，结果升级过后才半小时，突然之间收到运营和客服雪花般的反馈，说这个系统对应的前端页面无法访问了，所有用户全部看到的是一片空白和错误信息。



这个时候通过监控报警平台也收到雪花般的报警，发现线上系统所在机器的CPU负载非常高，持续走高，甚至直接导致机器都宕机了。所以系统对应的前端页面当然是什么都看不到了。







**2、CPU负载高原因分析**



上篇文章已经给大家总结过CPU负载高的原因了，这里我们直接说结论，看了一下监控和jstat，发现Full GC非常频繁，基本上两分钟就会执行一次Full GC，而且每次Full GC耗时非常长，在10秒左右！



所以直接入手尝试进行Full GC的原因定位。







**3、Full GC频繁的原因分析**



上篇文章也给大家总结过Full GC频繁的几种常见原因了，其实分析Full GC频繁的原因，最好的工具不是监控平台，就是最实用的jstat工具，直接看线上系统运行时候的动态内存变化模型，什么问题都立马出来了。



基于jstat一分析发现了很大的问题，当时这个系统因为主要是用来进行大量数据处理然后提供数据给用户查看的，所以当时可是给JVM的堆分配了20G的内存，其中10G给了年轻代，10G给了老年代，如下图所示：

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/63367600_1567431277.cn/txdocpic/0/44bb9d1ba2f981ebc546e8b7a4b49418/0)      



这么大的年轻代，结果大家能猜到jstat看到什么现象吗？Eden区大概1分钟左右就会塞满，然后就会触发一次Young GC，而且Young GC过后有几个GB的对象都是存活的会进入老年代！



如下图所示。

​          ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/91659500_1567431277.cn/txdocpic/0/8050e38ea4b660d31b3585c3ad3d6918/0)             

这说明什么？这说明系统代码运行的时候在产生大量的对象，而且处理的极其的慢，经常在1分钟过后Young GC以后还有很多对象在存活，才会导致大量对象进入老年代中！这真是让人非常的无奈。



所以就是因为这个内存运行模型，才导致了平均两分钟就会触发一次Full GC，因为老年代两分钟就塞满了，而且老年代因为内存量很大，所以导致一次Full GC就要10秒的时间！



大家想象一下，系统每隔2分钟就要暂停10秒，对用户是什么感觉！



更有甚者，普通的4核机器根本撑不住这么频繁，而且这么耗时的Full GC，所以这种长时间Full GC直接导致机器的CPU频繁打满，负载过高，也导致了用户经常无法访问系统，页面都是空白的！







**4、以前那套GC优化策略还能奏效吗？**



那么大家想一下，以前我们给大家说过的那套GC优化策略此时还能奏效吗？



即把年轻代调大一些，给Survivor更多的内存空间，避免对象进入老年代。



明显不行，这个运行内存模型告诉我们，即使你给年轻代更大空间，甚至让每块Survivor区域达到2GB或者3GB，但是一次Young GC过后，还是会因为系统处理过慢，导致几个GB的对象存活下来，你Survivor区域死活都是放不下的！



所以这个时候就不是简单优化一下JVM参数就可以搞定的。



这个系统明显是因为代码层面有一定的改动和升级，直接导致了系统加载过多数据到内存中，而且对过多数据处理的还特别慢，在内存里几个GB的数据甚至要处理一分多钟，才能处理完毕。



这是明显的代码层面的问题了，其实要优化这个事故，就必须得优化代码，而不是简单的JVM参数！



我们需要避免代码层面加载过多的数据到内存里去处理，这是最核心的一个点。







**5、复杂的业务逻辑，自己都看不懂了怎么办？**



说优化代码，说起来很简单，但是实际做起来呢？



有很多系统的代码都特别的复杂，别说别人看不懂了，自己可能写的代码过了几个月自己都看不懂了！所以直接通过走读代码来分析问题所在是很慢的！



我们必须有一个办法可以立马就定位到系统里到底是什么样的对象太多了占用了过多的内存，这个时候就得使用一个工具了：**MAT**



这个工具我们上篇文章介绍过，今天给大家深入讲讲他的使用，给出一些界面的截图出来。







**6、准备一段示范用的代码**



现在我们来准备一段示范用的代码，在代码里创建一大堆的对象出来，然后我们尝试获取他的dump内存快照，再用MAT来进行分析。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/77054100_1567431390.png)



这段代码大家可以看到，非常的简单，就是在代码里创建10000个自定义的对象，然后就陷入一个阻塞状态就可以了，大家可以把这段代码运行起来。







**7、获取jvm进程的dump快照文件**



先在本地命令行运行一下jps命令，查看一下启动的jvm进程的PID，如下所示：



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/14502800_1567431278.cn/txdocpic/0/78ecb291957d1826cd6e1cfd8df8d5cc/0)            



明显能看到，我们的Demo1这个类的进程ID为1177



接着执行下面的jmap命令可以导出dump内存快照：

jmap -dump:live,format=b,file=dump.hprof 1177





**8、使用MAT分析内存快照**



大家在下一个步骤，务必要注意到，如果是线上导出来的dump内存快照，很多时候可能都是几个GB的



比如我们这里就是8个多GB的内存快照，所以就务必按照上节课所说的，在MAT的MemoryAnalyzer.ini文件里，修改他的启动堆大小为8GB。



接着就是打开MAT软件，如下图所示：



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/46857300_1567431278.cn/txdocpic/0/c47c43c700c1786b76e41824f3517a77/0)            



然后选择其中的“Open a Heap Dump”打开自己的那个dump快照即可



接着会看到下图的样子，大家如果跟我一样用的是最新版本的MAT，那么打开dump快照的时候就会提示你，要不要进行内存泄漏的分析，就是Leak Suspects Report，你一般勾选是即可。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/88704100_1567431278.cn/txdocpic/0/2e9e48b9bb07614c1f096527c8b5d1cc/0)            



接着大家会看到如下的图：



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27828700_1567431279.cn/txdocpic/0/1adbf543a5979acc4a8f5ee81904c410/0)            

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/72331000_1567431279.cn/txdocpic/0/2f5687367037df7f243124d08262afff/0)            



从上面图里可以很清晰的看到了，别人都告诉你了，可能存在的内存泄漏的问题，尤其是第一个问题，“Problem Suspect 1”，他的英文里很清晰的告诉你了，java.lang.Thread main，就是说main线程，通过局部变量引用了占据24.97%内存的对象。



而且他告诉你那是一个java.lang.Object[]数组，这个数组占据了大量的内存。



那么大家肯定想要知道，到底这个数组里是什么东西呢？



大家可以看到上面的“Problem Suspect 1”框框的里面最后一行是一个超链接的“**Details**”，大家点击进去就可以看到详细的说明了。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20773100_1567431280.cn/txdocpic/0/e379fb6eb87cb776ae77e2eba726a039/0)            



通过这个详细的说明，尤其是那个“Accumulated Objects in Dominator Tree”，在里面我们可以看到，java.lang.Thread main线程中引用了一个java.util.ArrayList，这里面是一个java.lang.Object[]数组，数组里的每个元素都是Demo1$Data对象实例。



到此为止，就很清楚了，到底是什么对象在内存里占用了过大的内存。所以大家通过这个小小的范例就可以知道，你的系统中那些超大对象到底是什么，用MAT分析内存是非常方便的。







**9、追踪线程执行堆栈，找到问题代码**



一旦发现某个线程在执行过程中创建了大量的对象之后，就可以尝试找找这个线程到底执行了哪些代码才创建了这些对象



如下图所示，先点击页面中的一个“See stacktrace”，可然后就会进入一个线程执行代码堆栈的调用链：



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65348400_1567431280.cn/txdocpic/0/6aaab2d098e3a724e808a6fe4e2b8ef9/0)            



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/1804200_1567431281.cn/txdocpic/0/ce3e0342c2fdedc817671972933e35c0/0)            



在当时而言，我们就是按照这个方法追踪到了线上系统某个线程的执行堆栈，最终发现的是这个线程执行“String.split()”方法导致产生了大量的对象



那么到底是为什么呢？接着我们来分析一下“String.split()”这个方法。







**10、为什么“String.split()”会造成内存泄漏？**



其实原因很简单，当时这个线上系统用的是JDK 1.7。



在JDK 1.6的时候，String.split()方法的实现是这样子的，比如你有一个字符串，“Hello World Ha Ha”，然后你按照空格来切割这个字符串，应该会出来四个字符串“Hello”“World”“Ha”“Ha”，大家应该理解这个吧？



那么JDK 1.6的时候，比如“Hello World Ha Ha”这个原始字符串底层是基于一个数组来存放那些字符的



比如[H,e,l,l,o,,W,o,r,l,d,,H,a,,H,a]这样的数组。然后切割出来的“Hello”字符串他不会对应一个新的数组，而是直接映射到原来那个字符串的数组，采用偏移量表明自己是对应原始数组中的哪些元素。



比如说“Hello”字符串可能就是对应[H,e,l,l,o,,W,o,r,l,d,,H,a,H,a]数组中的0~4位置的元素。



但是JDK 1.7的时候，他的实现是给每个切分出来的字符串都创建一个新的数组，比如“Hello”字符串就对应一个全新的数组，[H,e,l,l,o]。



所以当时那个线上系统的处理逻辑，就是加载大量的数据出来，可能有的时候一次性加载几十万条数据，数据主要是字符串



然后对这些字符串进行切割，每个字符串都会切割为N个小字符串。



这就瞬间导致字符串数量暴增几倍甚至几十倍，这就是系统为什么会频繁产生大量对象的根本原因！！！



因为在本次系统升级之前，是没有String.split()这行代码的，所以当时系统基本运行还算正常，其实一次加载几十万条数据量也很大，当时基本上每小时都会有几次Full GC，不过基本都还算正常。



只不过系统升级之后代码加入了String.split()操作，瞬间导致内存使用量暴增N倍，引发了上面说的每分钟一次Young GC，两分钟一次Full GC，根本原因就在于这行代码的引入。







**11、代码如何进行优化？**



后来紧急对这段代码逻辑进行了优化，避免对几十万条数据每一条都执行String.split()这行代码让内存使用量暴增N倍，然后再对那暴增N倍的字符串进行处理。



就当时而言，其实String.split()这个代码逻辑是可用可不用的，所以直接去除就行了。



但是如果从根本而言，说白了，还是这种大数据量处理的系统，一次性加载过多数据到内存里来了，所以后续对代码还是做了很多的优化



比较核心的思路，就是开启多线程并发处理大量的数据，尽量提升数据处理完毕的速度，这样到触发Young GC的时候避免过多的对象存活下来。







**12、今日思考题**



今天给大家留一个小作业，可以去自己线上系统dump一个内存快照出来，用MAT练习一下分析自己系统的内存



看看都有哪些较大的对象，什么线程创建的，看看线程执行堆栈，体验一下分析内存的感觉。



#   066、阶段性复习：JVM运行原理和GC原理你真的搞懂了吗？

**1、阶段性复习**



最近三天会进行一个阶段性的复习，因为我们已经把完整的JVM运行原理、GC原理以及GC优化的原理，还有线上发生GC问题的各种优化案例，都给大家完整的分析完了，所以到这里务必停一停脚步，整理一下学习过的知识脉络，让大家进行一点复习。反复的复习，才能让大家真正吃透和消化掉这些知识。



这几篇文章我们不会把之前文章的东西大幅度的整理出来，主要是给大家提点一些思路，给你一些引导，希望每个人看到这里的时候，都停一停脚步，顺着我们带出来的思路，把过往学习过的知识，自己整理一下。







**2、JVM和GC的运行原理，你都能搞懂了吗？**



对于JVM的学习，首先大家务必要搞清楚一点，JVM是如何运行起来的。



相信大家认真看过之前文章的，应该都清楚一点，JVM的内存区域划分，最核心的就是这么几块了：年轻代、老年代、Metaspace（也就是以前的永久代）。



其中年轻代又分成了Eden和2个Survivor，默认比例是8：1：1，如下图。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38494600_1567498553.cn/txdocpic/0/bb6655f072e34c41aa772f971d2458f2/0)            



接着我们来思考一下，我们写好的系统会不停的运行，运行的时候是不是就会不停的在年轻代的Eden区域中创建各种对象？



如下图所示。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/64415100_1567498553.cn/txdocpic/0/7f6fef7647898896bb621af83e9b368f/0)            



而且一般创建对象都是在各种方法里执行的，一旦方法运行完毕，方法局部变量引用的那些对象就会成为Eden区里的垃圾对象，就是可以被回收的状态，大家务必要清楚这个过程



如下图。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85859300_1567498553.cn/txdocpic/0/0a11a961ea67fee98ddc4e48d5d1f98b/0)             

接着随着Eden区不断的创建对象，就会逐步的塞满，当然这个时候可能塞满Eden区的对象里大多数都是垃圾对象。一旦Eden区塞满之后，就会触发一次Young GC。



Young GC会采用复制算法，从GC Roots（方法的局部变量、类的静态变量）开始追踪，标记出来存活的对象。



然后把存活对象都放入第一个Survivor区域中，也就是S0区域，如下图所示。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/22091300_1567498554.cn/txdocpic/0/4b1f88fbd0cde29f7904c8857d5ec053/0)            

接着垃圾回收器就会直接回收掉Eden区里剩余的全部垃圾对象，在整个这个垃圾回收的过程中全程会进入Stop the Wold状态，也就是暂停系统工作线程，系统代码全部停止运行，不允许创建新的对象



只有这样，才能让垃圾回收器专心工作，找出来存活对象，回收掉垃圾对象，如下图所示。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42558500_1567498554.cn/txdocpic/0/21120a5883b9f8584bea513c00a09054/0)            



一旦垃圾回收全部完毕之后，也就是存活对象都进入了Survivor区域，然后Eden区都清空了，那么Young GC执行完毕，此时系统恢复工作，继续在Eden区里创建对象，如下图所示。



​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67099400_1567498554.cn/txdocpic/0/6dd5f6f0f5a6dbca2e6ffca5d2418df3/0)             

下一次如果Eden区满了，就会再次触发Young GC，把Eden区和S0区里的存活对象转移到S1区里去，然后直接清空掉Eden区和S0区中的垃圾对象



当然这个过程中系统是禁止运行的，处于Stop the World状态，如下图所示。



​         ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/88931900_1567498554.cn/txdocpic/0/029ae7686d8cfc2c0092bae085654fce/0)             

负责Young GC的垃圾回收器有很多种，但是常用的就是ParNew垃圾回收器，他的核心执行原理就如上所述，只不过他运行的时候是基于多线程并发执行垃圾回收的，大家只要记得这点就可以。



这就是最基本的JVM和GC的运行原理，大家都搞懂了吗？





**3、对象什么时候进入老年代？**



但是大家觉得光是一块年轻代和Young GC配合起来，就足够JVM来使用了吗？



No！



实际JVM运行过程中，有很多意外的情况会发生的，会导致对象进入老年代区域中，如下所述几种情况，反复给大家总结过，务必要记得很清晰：



1. 一个对象在年轻代里躲过15次垃圾回收，年龄太大了，寿终正寝，进入老年代

   

2. 对象太大了，超过了一定的阈值，直接进入老年代，不走年轻代

   

3. 一次Young GC过后存活对象太多了，导致Survivor区域放不下了，这批对象会进入老年代

   

4. 可能几次Young GC过后，Surviovr区域中的对象占用了超过50%的内存，此时会判断如果年龄1+年龄2+年龄N的对象总和超过了Survivor区域的50%，此时年龄N以及之上的对象都进入老年代，这是动态年龄判定规则



上面4个条件就是最常见的对象进入老年代的情况，那种长期存活的躲过15次Young GC的对象毕竟是少数的，大对象一般在特殊情况下会有，对于那种加载大量数据长时间处理以及高并发的场景，很容易导致Young GC后存活对象过多的。



所以对于这些情况，都会导致对象进入老年代中，老年代对象可能会越来越多，如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/19134800_1567498555.cn/txdocpic/0/d1de14e8754e8892bf79a5ae76a402e7/0)            



**4、老年代的GC是如何触发的？**



一旦老年代对象过多，就可能会触发Full GC，Full GC必然会带着Old GC，也就是针对老年代的GC



而且一般会跟着一次Young GC，也会触发永久代的GC。



大家还记得Full GC触发的几个条件吗？



1. 老年代自身可以设置一个阈值，有一个JVM参数可以控制，一旦老年代内存使用达到这个阈值，就会触发Full GC，一般建议调节大一些，比如92%

   

2. 在执行Young GC之前，如果判断发现老年代可用空间小于了历次Young GC后升入老年代的平均对象大小的话，那么就会在Young GC之前触发Full GC，先回收掉老年代一批对象，然后再执行Young GC。

   

3. 如果Young GC过后的存活对象太多，Survivor区域放不下，就要放入老年代，要是此时老年代也放不下，就会触发Full GC，回收老年代一批对象，再把这些年轻代的存活对象放入老年代中





触发Full GC几个比较核心的条件就是这几个，总结起来，其实就是老年代一旦快要搞满了，空间不够了，必然要垃圾回收一次。



老年代的垃圾回收通常建议走CMS垃圾回收器，回收机制比较复杂，此处建议大家自行复兴和总结一下



总之，Old GC的速度是很慢的，少则几百毫秒，多则几秒。所以一旦Full GC很频繁，就会导致系统性能很差，因为频繁要停止系统工作线程，导致系统看起来一直有卡顿的现象。



而且频繁Full GC还会导致机器CPU负载过高，导致机器性能下降，处理请求能力降低。



所以优化JVM的核心就是减少Full GC的频率。





**5、正常情况下的系统**



正常情况下的系统，会有一定频率的Young GC，一般在几分钟一次Young GC，或者几十分钟一次Young GC，一次耗时在几毫秒到几十毫秒的样子，都是正常的。



正常的Full GC频率在几十分钟一次，或者几个小时一次，这个范围内都是正常的，一次耗时应该在几百毫秒的样子。



所以大家如果观察自己线上系统就是这个性能表现，基本上问题都不太大。



当然，实际线上系统很多时候回遇到一些JVM性能问题，就是Full GC过于频繁，每次还耗时很多的情况，此时就需要一些优化了。



明天我们会继续总结Full GC优化的一些常用手段以及生产环境下的GC优化的方法。

# 067、阶段性复习：JVM性能优化到底该怎么做？

**0、写在前面的话**



最近有个别同学后台留言问为什么最近的文章的一些顺序和标题，跟大纲里的有点出入，我在这里解释一下。



因为在实际写作的过程中，会把一些文章的顺序做一些交换，比如之前把Week 10里的内容放到了Week 9。



同时Week 9里有一些案例，在写作过程中考虑了一下，感觉有些东西没太大必要了，所以替换成了别的几个案例放在了Week 10里，因此有一些案例的标题上会有一些变更。



另外Week 10里把原定的3个案例替换为了3讲内容用来进行阶段性的复习，这个也是因为发现很多同学对我们专栏里的阶段性定时复习，定时停下脚步做点总结和梳理，非常的好评和认可，因此我们临时在这里加入了3讲内容进行阶段性梳理、总结和复习。



相信大部分人都认可一个观点：学习不是不停的学习新的内容，更重要的是在学新内容的同时，要经常性的停下脚步来复习之前的内容，这样反复的周期性的复习和总结，不断的重复和强化一些核心的东西，最后在三四个月的专栏学习完毕之后，才能彻底吃透和消化掉这块知识。



这就是我对原定大纲做出一些顺序变换以及少数案例替换为阶段性复习的原因和说明，希望大家理解我的良苦用心，好好学新内容，也好好复习老内容，消化成自己的东西，最后才真正有所收获。





**1、一个新系统开发完毕之后如何设置JVM参数？**



之前花费了很多的精力给大家介绍，在一个新系统开发完毕之后，到底该如何预估性的合理设置JVM参数？



毕竟直接用默认的JVM参数部署上线再观察，是非常的不靠谱的。很多公司也没有所谓的JVM参数模板。



首先大家应该估算一下自己负责的系统每个核心接口每秒多少次请求，每次请求会创建多少个对象，每个对象大概多大，每秒钟会使用多少内存空间？



这样接着就可以估算出来Eden区大概多长时间会占满？



然后就可以估算出来多长时间会发生一次Young GC，而且可以估算一下发生Young GC的时候，会有多少对象存活下来，会有多少对象升入老年代里，老年代对象增长的速率大概是多少，多久之后会触发一次Full GC。



通过一连串的估算，就可以合理的分配年轻代和老年代的空间，还有Eden和Survivor的空间



原则就是：尽可能让每次Young GC后存活对象远远小于Survivor区域，避免对象频繁进入老年代触发Full GC。



最理想的状态下，就是系统几乎不发生Full GC，老年代应该就是稳定占用一定的空间，就是那些长期存活的对象在躲过15次Young GC后升入老年代自然占用的。然后平时主要就是几分钟发生一次Young GC，耗时几毫秒。





**2、在压测之后合理调整JVM参数**



任何一个新系统上线都得进行压测，此时在模拟线上压力的场景下，可以用jstat等工具去观察JVM的运行内存模型：



- Eden区的对象增长速率多块？
- Young GC频率多高？
- 一次Young GC多长耗时？
- Young GC过后多少对象存活？
- 老年代的对象增长速率多高？
- Full GC频率多高？
- 一次Full GC耗时？





压测时可以完全精准的通过jstat观察出来上述JVM运行指标，让我们对JVM运行时的情况了如指掌。然后就可以尽可能的优化JVM的内存分配，尽量避免对象频繁进入老年代，尽量让系统仅仅有Young GC。







**3、线上系统的监控和优化**



系统上线之后，务必进行一定的监控，高大上的做法就是通过Zabbix、Open-Falcon之类的工具来监控机器和JVM的运行，频繁Full GC就要报警。



比较差一点的做法，就是在机器上运行jstat，让其把监控信息写入一个文件，每天定时检查一下看一看。



一旦发现频繁Full GC的情况就要进行优化，优化的核心思路是类似的：通过jstat分析出来系统的JVM运行指标，找到Full GC的核心问题，然后优化一下JVM的参数，尽量让对象别进入老年代，减少Full GC的频率。







**4、线上频繁Full GC的几种表现**



其实通过之前的各种案例，大家可以总结出来，一旦系统发生频繁Full GC，大概看到的一些表象如下：



- 机器CPU负载过高；
- 频繁Full GC报警；
- 系统无法处理请求或者处理过慢



所以一旦发生上述几个情况，大家第一时间得想到是不是发生了频繁Full GC。







**5、频繁Full GC的几种常见原因**



之前给大家分析过多个案例，通过那些案例的总结和归纳，可以得出下面几个常见的频繁Full GC的原因：



1. 系统承载高并发请求，或者处理数据量过大，导致Young GC很频繁，而且每次Young GC过后存活对象太多，内存分配不合理，Survivor区域过小，导致对象频繁进入老年代，频繁触发Full GC。

   

2. 系统一次性加载过多数据进内存，搞出来很多大对象，导致频繁有大对象进入老年代，必然频繁触发Full GC

   

3. 系统发生了内存泄漏，莫名其妙创建大量的对象，始终无法回收，一直占用在老年代里，必然频繁触发Full GC

   

4. Metaspace（永久代）因为加载类过多触发Full GC

   

5. 误调用System.gc()触发Full GC



其实常见的频繁Full GC原因无非就上述那几种，所以大家在线上处理Full GC的时候，就从这几个角度入手去分析即可，核心利器就是jstat。



如果jstat分析发现Full GC原因是第一种，那么就合理分配内存，调大Survivor区域即可。



如果jstat分析发现是第二种或第三种原因，也就是老年代一直有大量对象无法回收掉，年轻代升入老年代的对象病不多，那么就dump出来内存快照，然后用MAT工具进行分析即可



通过分析，找出来什么对象占用内存过多，然后通过一些对象的引用和线程执行堆栈的分析，找到哪块代码弄出来那么多的对象的。接着优化代码即可。



如果jstat分析发现内存使用不多，还频繁触发Full GC，必然是第四种和第五种，此时对应的进行优化即可。





**6、一个统一的JVM参数模板**



为了简化JVM的参数设置和优化，建议各个公司和团队leader做一份JVM参数模板出来，设置一些常见参数即可



核心就是一些内存区域的分配，垃圾回收器的指定，CMS性能优化的一些参数（比如压缩、并发，等等），常见的一些参数，包括禁止System.gc()，打印出来GC日志，等等。



这些常见的参数，之前基本都讲过了，建议大家自行整理出来一份模板即可。



# 068、如何为你的面试准备自己负责的系统中的JVM优化案例？

2019-09-06 07:00:00

**1、面试中关于JVM的一些痛点**



很多人都跟我以及我的一些朋友反馈过一些自己面试中对于JVM这块的一些痛点，一些常见的理论知识，比如JVM内存模型，垃圾回收算法，垃圾回收器，类加载，这些常见的知识，都背的滚瓜烂熟。



但是呢？面试官常问的就是，说说你平时在工作中如何进行JVM优化的？



此时很多人直接两眼发蒙。原因很简单，在我们这个JVM专栏推出之前，平心而论，国内Java工程师中，真的懂JVM优化的仅仅是少数人而已。



大部分工程师对JVM的掌握仅仅停留在JVM的一些理论知识，但是这些理论知识在你的系统运行时候的运行模型和原理，以及跟GC的各种关系，完全没有串联起来，也就是从理论到实践完全是脱节的。



而且对线上系统如何监控JVM GC以及如何定位、分析以及解决频繁GC问题，完全没任何成体系的思路。之前仅仅看过网上一些凌乱的博客，看过一些所谓的JVM优化参数，仅仅就是背参数而已，以为设置了一些参数就一定没问题了。



上述问题，跟国内缺乏JVM实战性的资料有很大的关系。因此很多人出去面试的时候，一旦问到自己平时如何在生产环境进行JVM生产优化，根本不知道怎么回答，这就是最大的痛点！





**2、现在的你应该如何在面试中回答JVM生产优化问题？**



现在的你已经学习了这么多的内容，应该如何在面试中回答JVM生产优化问题？



一种比较常见的做法，就是把之前学习过的知识，归纳总结出来一套通用的方法付论，然后面试的时候就聊这套通用方法论即可。



这个方法没有问题，很多面试官其实听到这套回答已经眼前一亮了，因为国内很少有人能把JVM生产优化的方法论总结的如此之系统的。



但是还不够，因为面试官想听的，实际上是你自己负责的系统是如何进行JVM优化的！





**3、如果你的系统访问量和数据量暴增10倍或者100倍**



所以你在这里应该思考的一个问题，就是你负责的系统，假设数据量和访问量暴增10倍，或者100倍，此时会不会出现频繁Full GC的问题？



利用学习过的知识去倒推一下，其实很可能的，在有限的机器资源下，一旦压力增长，很可能因为内存分配不合理，导致频繁Full GC的！



上面我们说过好几种频繁Full GC的触发条件，你是不是都可以放在自己的系统里去思考一下，自己的系统有没有可能会发生上述几种场景下的频繁Full GC？



如果会的话，那么一旦发生了，如何定位、分析和解决？



你应该把频繁Full GC问题和你自己的业务系统结合起来，自己深度思考，自己整理出来几个自己系统可能发生的JVM性能问题，然后整理出一套解决方案出来。



未来在面试的时候，应该结合自己的系统去跟面试官聊，说自己的系统可能在哪些情况下发生频繁Full GC，在压测的时候就发现了这些问题，然后你是如何进行JVM性能优化的！



这样面试官一定会认可你对JVM这块技术的掌握和实践经验的！





**4、最后提点一句JVM的优化注意点**



网上有很多博客会让你设置一些非常少见的JVM参数，比如之前有个案例就讲了，有人设置了软引用的一个参数，还有一些奇怪的参数，比如pagecache的参数之类的，以为JVM优化就是调节奇怪的参数，搞的很牛一样。



其实完全不是如此，真正的JVM优化，就是一些内存分配+垃圾回收器的选择（ParNew、CMS、G1）+垃圾回收器的常见参数设置，还有就是一些代码层面的内存泄漏问题，其实搞定这些问题，99%的JVM性能问题你都能搞定了！



所以大家千万别胡乱设置一些奇怪的参数，很可能会适得其反！



我们这个专栏后面还有很多内容是关于JVM OOM的，JVM平时最容易产生的就是两类问题，JVM频繁GC和JVM OOM，所以我们专栏也专注在这两块内容的实战上。当大家把专栏全部内容都学习完毕之后，日常生产环境里的问题基本都能搞定了。



# 069、关于作业的说明

2019-09-07 07:00:00

不知不觉，JVM实战专栏已更新10周



通过每天在后台回复大家的留言，在和大家的互动中，也了解到了更多的典型问题，我会根据这些问题对咱们的专栏内容进行微调，目标只有一个，让所有购买了专栏的同学最大限度的吃透课程。



其中决定对专栏做的一个调整，就是取消掉每周六的作业，因为从后台的数据看，每周看过作业的同学实在是少的可怜，10分之1都不到



后来我想了一下，每周5篇干货文章，加上一篇答疑，这个量已经足够了，况且布置作业这种方式看上去太重，不如每天文末留下的，看起来更轻的思考题。



大家可以看了文章，立即思考，马上讨论，这样的短平快的过程，我认为效果是更好的



所以从本周开始，周六的作业都取消，大家就认真吃透每周5篇干货文章，思考每篇文章末尾留下的思考题，坚持4个月，你一定能成为jvm实战高手！



# 070、第10周答疑汇总

2019-09-08 07:00:00



**学员总结：**

总结一下老师这几天提交的参数：

- -XX:+CMSParallelInitialMarkEnabled表示在初始标记的多线程执行，减少STW；
- -XX:+CMSScavengeBeforeRemark：在重新标记之前执行minorGC减少重新标记时间；
- -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，降低STW；
- -XX：CMSInitiatingOccupancyFraction=92和-XX:+UseCMSInitiatingOccupancyOnly配套使用，如果不设置后者，jvm第一次会采用92%但是后续jvm会根据运行时采集的数据来进行GC周期，如果设置后者则jvm每次都会在92%的时候进行gc；
- -XX:+PrintHeapAtGC:在每次GC前都要GC堆的概况输出



**回答：**总结的非常好

====================================================

**问题：**

这问题看似简单，其实我也碰到过，当时使用jxl导出excel的时候，jxl会默认调用gc方法，当时花了不少时间才发现原来是这个问题...



**回答：**

是的，就是如此，还有的同学一时手痒会自己去执行这行代码，就怕有的人自己瞎玩儿

====================================================

**问题：**

果然精短轻松?，之前我还在想这个参数的意义在哪里。老师，像这种情况jstick里会有什么异常吗？



**回答：**

jstat其实是用在死锁里的，一般可以是看死锁哪里线程卡住的

====================================================

问题：

老师，永久带里面存放的类信息具体是一些什么样的信息，可以给讲解几种吗？谢谢



回答：

这个具体类的信息，其实你可以理解为就是类所带的一些变量和方法

====================================================



总结：

当多个服务需要竞争一个单体资源时，可以考虑加上分布式锁。如果并发量高的话，可以考虑拆分掉那个单体资源，50个拆成5个10个资源，从而缩小锁的粒度，提高吞吐量。



总结的很好

====================================================



总结：

一般redis的分布式锁都可以使用redisson框架来做。 使用：直接lock("key") 



原理：当lock的时候，当前客户端会生成一串lua脚本发送到redis服务端。服务端根据这个key是否存在以及key的value状态判断是否已被加锁。



如果加锁成功（有效期30s）：生成的value里面带有当前客户端的id，实现可重入效果。然后在这个线程执行过程中，一旦加锁成功还会有一个watch dog每10s去刷新锁的状态。直到释放或者宕机，如果当前线程死锁或阻塞，那么这个锁就一起死锁。如果加锁失败：自旋到获取锁。



总结的很好

====================================================

问题：

老师，我有个关于锁的问题。在我看来，所有锁都是基于一个互斥量，这个互斥量可以随意选取为一个支持加锁或者原子操作的第三方组件。那么经常使用zk/redis去是实现分布式锁，而不使用db去加锁。是因为db的吞吐量太低了吗，还是有其他考虑？



回答：

db不适合配合系统做加锁，从功能层面，db就不是干这个的

====================================================



学员思考题回答：

出现原因：

因为redis主从异步复制的实现方式是可能出现在主节点宕机时未完成同步而出现的锁丢失。 这个时候watch dog发现了也没办法，只能说是自己停掉了。 



解决办法：

因为主从异步复制出现的问题，那么保证主从写强一致就可以了。但是如果写强一致的话，那么吞吐量就会因为这些实时同步而急剧降低。



另外出现了C，那么A这个可用性就会受到一定的影响，因为在实时同步的时候，要是失败了，这个服务可能暂时就无法提供正常的服务。



回答：

总结的很好

====================================================



总结：

zk一般使用curator去实现分布式锁。 原理：向zk发起请求，在一个目录（/locks/pd_1_stock）下，创建一个临时节点，也是带有自己客户端的id。



如果目录是空的，自己创建出来的节点就是第一个节点，那么加锁成功。如果成功执行则释放（节点删除）。



如果宕机了，基于zk的心跳机制，那个临时节点也会被删除。第二个客户端请求锁时，也创建一个节点，如果不是第一节点，那么向上一节点加一个watcher监听器。如果上一节点被删除立马会感知到，然后在判断自己是不是第一节点，如果不是再监听上一级（公平实现）。完事后陷入等待，直到获取锁。



总结的很好

====================================================

总结： 

羊群效应：当几十个节点争抢同一把基于zk的锁时，如果都是监听第一个节点，那么当释放锁时，zk会同时反向通知所有客户端又来重新增强。 



影响：

主要是多了很多没必要的请求，从而会加重网络的负载。 



解决：

就基于curator去做就好了，通过监听上一级节点，降低了争抢次数，还实现了公平锁。 



redis：redis因为是客户端自己主动隔一段时间去尝试加锁，所以羊群效应影响不大，因为请求都错开了，而不是一群一拥而上。



总结的很好

====================================================

问题：

老师，关于g1我有个疑惑，就是如果选择减小gc耗时，那是不是意味gc的次数会增多。那选择减少时间是因为它的收益大于gc次数的增加。



回答：

是的，你理解的没问题，gc频率多点，但是每次gc耗时很短，没事的

====================================================

问题：

老师能不能对 这种类型的问题上一课 最近金九银十 肯定有很多同学要面试 比如这个题目 凌晨三点发生了一次oom 怎么追踪解决

回答：

这个问题很好，这个在后面的OOM相关案例里会分析的

====================================================

问题：

老师好，刚才看到有同学的总结： 

1. G1，新生代未达到60%，老年代未达到45%，则不进行GC 您的回答是没问题，但是从您的文章中找到的，新生代不到60%，只要ygc时间接近预设GC时间时就会进行GC。

2.  看了一下我们的线上系统，发现ygc之后，survivor区已经达到了将近90%，但是没有对象进入老年代，这是不是意味着要么所有对象都是同岁的，要么至少41%的对象是大年龄且同岁的。

   

回答：

有的回复可能是没看清楚他们的问题，G1的话，有可能达到预期的gc时间后他就会触发gc，不是固定的

====================================================

问题：

看到老年代驻留大量对象，想到的竟然是老年代空间太小，需要扩大，而不是其他问题，看来还是没学到家呀



回答：

是的，所以要多学案例，积累经验

====================================================

问题：

打卡，今天讲解了cpu负载高的原因，复习了频繁fullGC的原因，给了一个分析堆内存的实用工具MAT。给力。



回答：

是的，今天其实以复习为主

====================================================

问题：

老师我非常激动，今天出现一个问题，我发现和上周的案例基本一致，就是极端情况下，SQL中in条件语句包含十几万个ID，一个SQL语句的String对象很大，导致Full GC，然后还有一种场景in条件是空 ，SQL是select * from DB的(代码我写的，非常惭愧)一下加载十几万的数据出来，导致full gc。



除了这两个问题，今天的例子也和我们系统很想：通过cat观察cms管理的内存平时一般都在800m左右，但是最近一直涨到1300m左右，持续了很久都不会降低，老年代2000m，68%就会触发Full GC，也就是1300左右就会发生GC，我初步怀疑是哪里内存泄漏了，导致这里占了几百MB内存不释放，这个还有待查询。准备将这个泄漏找出来，然后调整一下JVM参数，优化一波。



回答：

非常好，看来案例中碰到的例子，你自己工作里都碰到了，一个是SQL误操作加载过多数据触发的Full GC，一个是内存泄漏导致老年代里一直占用了过多内存。可以dump一个内存快照出来，用MAT分析一下

====================================================

问题：

另外有点疑问，大对象进入老年代，我网上找资料说是默认大对象阈值是0，也就是不会直接进入老年代，这个是真的吗。



我感觉我的问题也是因为很大的String直接进入了老年代才导致几百MB无法释放



回答：

大对象会直接进入老年代的，但是具体要看不同版本的JDK默认参数是什么

====================================================



问题：

老师，你好，我数据平台有一个报表导出，导出的时候因为堆内存不足而失败，但是后面CMS，会一直进行标记清理，老年代基本上是占满的，S1,S2没有任何占用，jstat 看到jvm一直在进行 YGC 和 FGC



但是老年代一直不减少，只有在eden区占满以后执行后的YGC，才会将老年代的占用真正的回收，请问能否解释一下这个是为什么？ 

-XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:NewSize=838860800 -XX:MaxNewSize=838860800 -XX:MetaspaceSize=104857600 -XX:SoftRefLRUPolicyMSPerMB=2000 -XX:SurvivorRatio=2 -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=95 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+TraceClassLoading -XX:+TraceClassUnloading -XX:+PrintGCDetails -XX:+PrintGCDateStamps -verbose:gc -Xloggc:./filebeat/gc.log -XX:ErrorFile=./logs/jvm_error.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./logs/heapdump.hprof 204800.0 204800.0 0.0 0.0 409600.0 313375.4 229376.0 229352.0 � � 252 1.854 467 54.764 56.618 还有就是元数据区是乱码的



回答：

这个本质还是你代码的问题，应该是大量的数据占满了老年代，没处理完就回收不掉

====================================================

问题：

请问一下[Loaded sun.reflect.GeneratedMethodAccessor129 from __JVM_DefineClass__]从这行日志是咋看出来GeneratedMethodAccessor会被加载到MetaSpace的, 这行日志好像没有提供类被加载到哪里的信息



回答：

第一个英文单词，Loaded，就是加载的意思

====================================================



总结： 

cms存在的问题，浮动垃圾因为并发清除，空间碎片因为标记整理算法，并发执行失败也是因为并发清除的设计可能存在预留的老年代空间不足。但是cms对空间碎片进行了优化，提供了内存的整理，这个操作可以通过参数去控制，默认是开启，并且每次fullgc后都去整理内存，但是就需要stw。 



最后，fullgc的发生情况： 

1.老年代可用内存小于新生代全部对象的大小，又没有开启空间担保，就会直接触发fullgc。 

2.如果新生代存活大小大于老年代空间，并且老年代空间小于历次晋升的平均内存大小，也会执行fullgc。 

3.大对象或者动态年龄进入老年代，而老年代空间不足，也会执行fullgc。 

4.如果是cms回收器，那么老年代内存使用到92%之后，就会触发fullgc，因为并发清除阶段需要给用户线程预留内存空间。



回答：

总结的很好

====================================================

问题：

一般公司线上系统是禁用dump内存快线的吗。我们被运维禁了



回答：

是的，线上机器一般来说会禁止执行dump，因为dump的时候可能会导致系统停机几秒钟，或者几百毫秒，可以跟运维沟通，让他们给你dump一个快照出来

====================================================

问题：

打卡。MAT好用，但是功能多需要慢慢摸索



回答：

是的，非常好用，不过文章里介绍的几个常用功能基本够用了，其实一般主要就是看占用内存最多的对象，追踪一下哪个线程，然后看一下线程执行堆栈

====================================================

问题：

老师您好！我最近遇到一个问题：



有一个定时任务，每5秒去读取一张表中的数据，这张表大概有7000多行，每行大概3KB



理论上，加载到内存，最大差不多30MB左右，但我通过jstat发现，到底每5秒钟，加载了大概300MB的数据，我对此很困惑，望老师或者其他同学能够解答一下～



回答：

这个很正常的，因为实际加载到内存里，你有不同的数据结构来存储，还有一些对象本身也会占据内存空间，实际内存消耗往往比你数据本身大小要大很多

====================================================



总结：

1. JVM是什么 答：本质上也是一个程序，负责运行java编译好的字节码文件(.class)。
2. JVM跟我们平时运行在机器上的系统之间是什么关系 答：JVM具有跨平台性，可以在多种系统上执行。
3. 类加载器的概念 答：把编译好的那些".class"字节码文件给加载到JVM中。
4. 字节码执行引擎的概念 答：针对加载进内存的类进行代码的执行。



回答：

总结得很好

====================================================

问题：

现在不是很清楚年轻代的gc root跟踪和老年代的gc root跟踪，是不是都是从gc root去找引用的对象？还是年轻代的直接从gc root遍历，老年代得并发标记，从老年代中的对象去找gc root



回答：

都是从gc roots开始追踪的

====================================================



问题：

老师你好，我在动态年龄判断那块有点疑问，假如survivor内存100m，现在已经占用了45m,那么此时来了一共55m的对象，那么之前所有的对象全部进入老年代，但是这55m还是大于一半，假如都是1岁会怎么处理呢，按对象的创建时间进入到老年代吗？



回答：

对的，也有可能会进入老年代

====================================================



问题：

老师好，关于动态对象年龄判断，我理解的还是不清晰，我现在理解的是判断各个年龄段之和是不是超过了survivor的一半，但是“各个年龄”包含本次gc之后存活的对象吗，如果超过了一半，那么本次gc之后的对象会进入老年代吗



回答：

其实关于这里的实现，不用过于找里面的细节，因为不同JDK版本实现都不同。你只要知道几点



第一，有动态年龄判定规则

第二，有可能因为young gc后存活对象过多导致进入survivor对象太多，触发这个规则

第三，可能因为这个规则导致很多对象进入老年代

====================================================

问题：

学这个专栏，感觉就在上课，不断学习，不断的复习



回答：

是的，一味的讲新内容往前赶进度是不靠谱的，要不断的有新的知识，同时不断带着之前旧的知识反复强化，还要定期复习，最后跟着看完，对核心知识绝对都消化的很彻底，当然自己也得注意复习和理解，还有结合自己的实际工作情况去积累

====================================================



学员思考题回答： 

1.调整s区到能够装下每次minorgc后存活的对象。 

2.调整动态年龄判断，可以考虑减小默认值。 

3.设置大对象进入老年代的判断，可以考虑设置为1m。 

4.设置回收器组合，一般响应优先就使用parnew+cms



回答：总结的很好

====================================================

问题：

系统给了3g堆内存，但是dump出来的文件打开看只有500mb，这个怎么解释



回答：

这个很正常，说明你的内存占用并没有占用满3g，就使用了500mb左右的内存，另外一个dump快照也会做一些二进制存储，不一定跟3g一样

====================================================



总结：

关于老年代的优化，都是建立在新生代已经进行优化的前提下。然后分析什么情况下对象依旧会进去老年代，多久会填满老年代，再根据垃圾回收器的特性，去设置对应的参数。



一般来说老年代的参数保持默认就好了，新生代优化好了，很少甚至几乎不会发生fullgc。



回答：

总结的很好

====================================================

问题：

老师，我发现一次young gc并没有将Eden区清空，而是会有部分保留是怎么回事呢？是我弄的不对还是有什么说道的？



回答：

不是的，实际上你说的那种是他刚ygc完，然后就有对象进入了eden，所以你就看到那样子了

====================================================



总结：

g1是以垃圾回收优先的回收器，主要是通过将内存区域划分成region然后维护一个回收价值列表，建立一个可预测的时间停顿模型。内部保留了年代，但是仅仅是逻辑上进行了保留，新生代和老年代会根据需要进行变化。



回答：

总结的很好

====================================================



总结: 

rabbitmq丢失数据的情况： 

1、生产者端。消息因为网络问题丢失或者发送到rabbitmq时出错了。 



2、rabbitmq服务端。未做持久化。 



3、消费者端。打开了autoAck，在未完成消费之前就自动回复了。 



rabbitmq丢失数据的解决： 

1、生产者端。

通过confirm模式异步确认消息发送成功，在失败后的回调函数中处理失败的逻辑。 



2、服务端。

打开持久化机制。这里涉及到两个参数，一个是建立queue的时候，持久化那个queue。



另外一个是生产者发送消息的时候，把deliveryMode设置为2，让MQ把这条数据也给持久化。



但是尽管如此，如果在极端情况下，在rabbitmq中内存写成功，但是还没来及持久化时，rabbitmq宕机，这部分在内存里面的数据也会丢失，不过几率很小。 



3、在消费者端，去掉autoAck，在自己完成逻辑后手动提交ack。



回答：总结的很好

====================================================



总结： 

kafka出现数据丢失的情况： 

1、生产者端：和rabbitmq类似，如果没能确认写成功，也没有重发那么也会丢失。 



2、服务端：如果未来得及和从节点同步数据就宕机了，那么这部分数据就会丢失。 



3、消费者端：和rabbitmq类似，如果自动提交offset依旧会出现丢失。 



kafka出现数据丢失的解决： 

1、生产者端：设置参数，要求每个从节点都写成功后才任务成功，另外如果发送失败，重试次数设置一个很大的值。 



2、服务端：设置参数，要求从节点起码大于1，且至少有一个能被感知到。 



3、消费者端：取消掉自动回复。 不过，强一致的保证消息不丢失，必然会影响到吞吐量。



回答：

总结的很好

====================================================

问题：

打卡，jvm性能优化怎么做？用jstat呀，哈哈，神器在手，再来个mat工具，还找不到问题？妖怪吧。



回答：

是的，基本gc日志+jstat+MAT就足够了

====================================================



6.JVM在什么情况下会加载一个类 



答: 

a.JVM进程启动之后，代码中包含"main()"方法的主类一定会被加载到内存。 



b.执行"main()"方法代码的过程中，遇到别的类也会从对应的".class"字节码文件加载 对应的类到内存里面。 



7.一个类从加载到使用，一般会经历哪些过程 



答：加载->验证->准备->解析->初始化->使用->卸载 



a.加载:将编译好的".class"字节码文件加载到JVM中 



b.验证:根据JVM规范，校验加载进来的".class"字节码文件 



c.准备:给类和类变量分配一定的内存空间，且给类变量设置默认的初始值(0或者nul) 



d.解析:把符号引用替换为直接引用的过程 



e.初始化:根据类初始化代码给类变量赋值 



注：执行new函数来实例化类对象会触发类加载到初始化的全过程；或者是包含"main()"方 法的主类，必须是立马初始化的。如果初始化一个类的时候，发现他的父类还没初始化， 那么必须先初始化他的父类。 



8.Java里有哪些类加载器 



答: a.启动类加载器: 主要负责加载我们在机器上安装的Java目录(lib目录)下的核心类库 



b.扩展类加载器：主要负责加载Java目录下的"lib/ext"目录中得类 



C.应用程序类加载器：主要负责加载"ClassPath"环境变量所指定的路径中的类，大致 可以理解为加载我们写好的java代码 



d.自定义类加载器：根据自己的需求加载类 



9.什么是双亲委派机制 

答：JVM的类加载器是有亲子层级结构的，启动类加载器最上层，扩展类加载器第二层， 应用程序类加载器第三层，自定义类加载器第四层。



当应用程序类加载器需要加载一个类时， 他会先委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载，但是如果父类 加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器



回答的很好

====================================================



问题：

老师能说说RememberSet吗，我在深入理解JVM这本书上看到了老年代引用新生代对象的时候，是用RememberSet来避免全堆扫描，那进行Old GC的时候，新生代引用老年代，是直接扫描整个新生代吗？我看有的博客有说道CMS的并发预清理跟可中断并发预清理，这又是什么。



回答：

这是一些JVM底层源码级别的原理，我们这个专栏定位是实战型的，基本把日常生产实战的内容都分析过了，而且都是结合案例的。有一些是属于深入底层的技术细节，但是跟平时实战优化关系不大，所以实际上我们没有讲这些内容。也许未来会出那种JVM源码级别的深入的课程，会说到你说的那些内容。

====================================================

问题：

你的总结正是我心中想总结的，预料之中。jvm运行原理、什么时候yong gc、什么时候进入老年代、什么时候full gc、为什么会频繁full gc、分析制定jvm模板



回答：

是的，定期复习和总结非常的重要

====================================================

问题：

之前也看过jvm的书，看了一些视频，但怎么优化还是一头雾水。很幸运遇到了老师的专栏，现在不管对实战还是面试都充满信心。



每天都要花3-4个小时学习总结，现在看文章还算轻松，后续要把老师所有的案例总结成自问自答的面试题。也根据所学，基于jstat初步做了个监控小工具，后面继续完善，也算是对专栏最好的总结。谢谢老师！！！！！！



回答：

好的，你真是太棒了，你们学有所成，真正掌握JVM的优化实战，提升国内工程师的技术水平，就是我们希望做的事情

====================================================



问题：

老师好，线上也出现了FUll GC的告警，日志如下: 

2019-09-05T17:26:15.161+0800: 85779.869: [Full GC (Metadata GC Threshold) 2019-09-05T17:26:15.161+0800: 85779.869: [CMS: 472256K->445559K(3022848K), 2.0333919 secs] 1425388K->445559K(4910336K), [Metaspace: 277217K->277217K(1511424K)], 2.0355295 secs] [Times: user=2.01 sys=0.01, real=2.03 secs] 2019-09-05T17:26:17.197+0800: 85781.905: [Full GC (Last ditch collection) 2019-09-05T17:26:17.197+0800: 85781.905: [CMS: 445559K->382990K(3022848K), 1.6770458 secs] 445559K->382990K(4910336K), [Metaspace: 276037K->276037K(1511424K)], 1.6863552 secs] [Times: user=1.63 sys=0.01, real=1.68 secs] 2019-09-05T17:26:18.886+0800: 85783.594: [GC (CMS Initial Mark) [1 CMS-initial-mark: 382990K(3022848K)] 382992K(4910336K), 0.0134842 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 



初步确认是每次发布groovy脚本，classload的时候才会彪高，这种问题基本定位到了，但是需要怎么去优化和解决呢?



回答：

这个很明确了，你的metaspace太小了，所以classload太多的时候会触发full gc，只要给metaspace区域更大空间就可以了

====================================================



问题：

这个课程真的是我学习过的JVM课程和看过的书中最好的,没有之一,其他的课程都感觉是隔靴搔痒,这个课是直击要害,而且每个问题都能得到回复, 非常感谢



回答：

多谢你的支持

====================================================



问题：

现在很渴望去解决线上问题，当别人搞不定的时候我来上，可惜现在系统的量太少，基本上堆内存6G,老年代和年轻代分别3G，就不会产生性能问题。只能假设它的量增加100倍了。



回答：

是的，因为系统量太小，就是Eden区都慢慢才满，满了以后存活对象也很少，几乎很少对象进入老年代的，所以一般量小的系统没有JVM的问题

====================================================



问题：

请问一下如果访问量增加100倍, 比如QPS从100, 猛增到10000, 而我Tomcat的MaxThread设置的是200, 而我每个请求的处理时间加入是100ms, 那理论上系统1S中可以处理的请求数就是2000, 这已经确定了啊, 即使QPS达到10000,多余的请求只会在OS中的Epoll模型中排队吧,



我感觉好像不会轮到JVM的问题暴露, 所以优化jvm参数的时候只要考虑到最大QPS是2000就可以了, 请问我这样理解对不对?



回答：

我给你举个例子怎么思考，比如你现在有一个系统，部署在一台机器上，机器能承载的极限并发量是每秒处理1000个请求，结果你现在系统量很小，每秒才处理10个请求。此时你直接假设你的机器资源被打满，每秒处理1000个请求，同样的内存下，请求量大了1000倍，你的JVM会如何运行？

====================================================

问题：

今天是分析而不讨论。让我们去回顾之前所学的知识，然后结合自己现有系统去准备这方面的面试技巧。



回答：

是的，加油好好复习和准备，多结合自己工作的系统去思考JVM的优化，放大100倍压力思考一下

====================================================



11.什么是JVM内存区域划分 

答：加载进来的类信息，需要放在某个内存区域。方法运行时，方法里面很多变量之类的 东西需要放在某个内存区域。代码里创建的对象，也需要内存空间来存放。所以JVM中必须 划分出来不同的内存区域，为了让我们写好的代码在运行过程中更方便的根据需要来使用。 



12.JVM中有哪些内存区域 答：

a.方法区: 在JDK1.8以后,这块区域的名字改了,叫做"Metaspace"。主要存放我们自己写的 各种类相关的信息。 



b.程序计数器：字节码指令通过字节码执行引擎被一条一条执行，才能实现我们写好的代码 执行的效果。



程序技术器就是用来记录当前执行的字节码指令的位置，也就是记录目前执行到了哪一条字节码指令。



JVM是支持多个线程的，所以就会 有多个线程来并发执行不同的代码指令，因此，每个线程都会有自己的一个 程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令。 



c.Java虚拟机栈：保存每个方法内的局部变量等数据。每个线程都会有自己的Java虚拟机栈。 



如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧(栈帧 里就有这个方法的局部变量表,操作数栈,动态链接,方法出口等)，然后压入 线程的Java虚拟机栈。方法执行完毕之后就从Java虚拟机栈出栈。



因此，每个线程在执行代码时，除了程序计数器以外，还搭配了一个Java虚拟机 内存区域来存放每个方法中得局部变量。 



d.Java堆内存：存放我们在代码中创建的各种对象。对象实例里面会包含一些数据。而Java 虚拟机栈的栈帧局部变量表里面的对象，其实是一个引用类型的局部变量，存放 了对应Java堆内存对象的地址。可以理解为局部变量表里的对象指向了Java



回答：

总结得很好

====================================================

问题：

老师，那以后市面上都用G1清理，那我们是不是在jvm优化上就得靠边站了？



回答：

是的，使用G1的时候，其实能做的事情很少，因为你想，他所有的内存分配和GC时机都是动态变化的，你怎么去调优？实际上他一切都是自动运行的。只要他能保证每次GC的耗时在你指定范围就可以了。但是其实现在G1也未必就已经很稳定了，所以一般还是用CMS+ParNew就可以了，比较可控一些。



# 071、Java程序员的梦魇：线上系统突然挂掉，可怕的OOM内存溢出！

**1、Java程序员的梦魇：线上系统突然挂掉**



大家作为一个Java程序员，平时开发系统，测试系统，上线部署系统，为了公司拼命的加班，任劳任怨的干活，然后。。。平时最害怕的是个什么事情？



想必不用我说，大家自己也知道了，就是出事故！



很多大公司管事故叫做Case，如果系统一旦出一个事故，比如线上核心系统突然宕机不可用，然后导致几个小时内用户无法下订单，进而导致公司损失几百万，甚至几千万。



或者公司的某个单点登录系统突然不可用，所有用户无法登录APP，也导致无法下单。



或者公司的缓存集群突然全面故障，然后导致公司的全部系统一起瘫痪。



或者因为某个明星突然出轨，结果导致流量集中访问某台服务器，直接把数据库搞挂了。



凡此种种，都是重大的Case。一旦有Case，就会有程序员被拉出去祭天，这是网上常见的一个段子，是不是？



其实祭天不至于那么夸张，但是一旦出了事故，总有人得去承担这个责任，去分析这个事故为什么会发生，谁的责任，后续如何改进



所以，自己负责的线上系统，或者负责维护的缓存集群，或者负责维护的数据库集群，突然莫名其妙挂掉，不可用，导致公司核心业务流程彻底中断，这个就是程序员平时最害怕的事情。







**2、Java程序员平时最常遇到的故障：系统OOM**



那么作为咱们Java程序员而言，先不考虑自己系统外部依赖的缓存、消息队列、数据库等等东西挂掉，就我们自己系统本身而言，最常见的挂掉的原因是什么？



其实就是系统OOM，也就是所谓的内存溢出！



大家之前跟着我们的专栏学习，已经对JVM的运行原理都比较了解了，那么现在我们就来想一想，所谓的JVM OOM内存溢出到底是什么？



其实说白了，也非常非常的简单，一句话形容，你的JVM内存就这么点，结果你拼命的往里面塞东西，结果内存塞不下了，不就直接溢出了吗？



看看下面的这个图

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92343300_1567592001.cn/txdocpic/0/bc32f5a83c01c7cc1202d35da20023b6/0)           

至于到底JVM是如何放不下对象导致内存溢出的，这个大家不要着急，情况有很多种，我们后面会一步一图一点点给大家分析的



此外我们还会结合一些案例用代码给大家演示出来发生内存溢出的一些场景，最后还会告诉大家平时对线上系统的内存溢出一般怎么来处理和解决。



一旦你的系统代码不停的往JVM内存里塞入大量的东西，JVM实在是放不下之后，JVM就会告诉你，OutOfMemory，内存溢出了，我实在放不下那么多东西了，我就直接瘫痪不能工作了。



通常而言，内存溢出这个问题可能对你的系统是毁灭性的打击，他代表你的JVM内存不足以支撑你的代码的运行



所以一旦发生这个情况，就会导致你的系统直接停止运转，甚至会导致你的JVM进程直接崩溃掉，进程都没了！



这个时候对于线上看起来的场景就是，用户突然发现很奇怪，为什么点击APP、点击网页，都没反应了呢？



然后大量的投诉和反馈给到客服，客服直接转移投诉给到运营，运营会直接反馈给技术人员。



这个时候技术人员往往得知这个消息会直接目瞪口呆，最害怕的事情发生了，自己负责的线上系统居然挂掉了，今年的年终奖。。。也许是泡汤了，弄不好还得提前出去找工作去了。。。







**3、很多工程师都不知道如何处理OOM**



最可怕的并不是线上系统发生了OOM，最可怕的是很多工程师压根儿就没有这种处理线上系统故障的经验



当发生OOM之后，根本不知道系统到底为什么会突然OOM？系统代码到底产生了多少对象？为什么会产生这么多对象？JVM为什么会放不下这么多对象？到底怎么去排查这个问题？又如何解决呢？



不知道，全都不知道！



因此我们的专栏接下来的几周内容，将全面围绕JVM OOM的问题展开。



我们先用一周时间带着大家一步一图分析各种可能发生OOM的情况，接着用一周的时间带着大家从一些案例入手来通过模拟代码真实感受一下OOM的发生



接着用一周的时间带着大家去学习如何监控、定位、排查、分析和解决JVM OOM的问题，最后用两周的时间带着大家去用各种真实的生产案例去体验不同场景下的OOM问题。



相信经过专栏最后几周的学习之后，每个人都能游刃有余的处理线上系统的JVM OOM问题的，最终成为JVM的实战高手。



# 072、大厂面试题：什么是内存溢出？在哪些区域会发生内存溢出？

**1、前言**



这篇文章，我们来聊一个面试常常被问的问题：JVM里的内存溢出到底是指的什么，哪些区域有可能会发生内存溢出？



要搞明白这个问题，那我们就得从头儿开始来捋一下了，我们这篇文章一步一图，从JVM的核心运行原理出发，然后给大家带出来到底哪些地方可能会发生内存溢出。







**2、运行一个Java系统就是运行一个JVM进程**



首先的话呢，大家得先搞明白一个事情，就是我们平时说启动一个Java系统，其实本质就是启动一个JVM进程。



咱们就用最最基本的情况来给大家演示一下好了，比如说下面的一段代码，是每个Java初学者都会写的一段代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36335300_1568043569.png)



那么大家知道，当你在Eclipse或者Intellij IDEA中写好这个代码，然后通过IDE来运行这个代码的时候，会发生哪些事情吗？



首先，我们专栏最早的几篇文章就给大家说过，我们写好的代码他都是后缀为“.java”的源代码，这个代码是不能运行的。



所以第一步就是这份“.java”源代码文件必须先编译成一个“.class”字节码文件，这个字节码文件才是可以运行的，如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/89496900_1568043569.cn/txdocpic/0/e15355b40e0dc51e03a5b882236e9cd1/0)      接着对于这种编译好的字节码文件，比如HelloWorld.class，如果里面包含了main方法，接下来我们就可以用“java命令”来在命令行执行这个字节码文件了



实际上一旦你执行“java命令”，相当于就会启动一个JVM进程。这个JVM进程就会负责去执行你写好的那些代码，如下图所示。

​      ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/14127800_1568043570.cn/txdocpic/0/ae17953d022ad23217f71a1bda99b67b/0)

所以首先要清楚第一点，运行一个Java系统，本质上就是启动一个JVM进程，这个JVM进程负责来执行你写好的一大堆代码。只要你的Java系统中包含一个main方法，接着JVM进程就会从你指定的这个main方法入手，开始执行你写的代码。





**3、到底执行哪些代码：JVM得加载你写的类**



下一个问题，JVM进程怎么执行你写的那些代码呢？



大家都知道，Java是一个面向对象的语言，所以最最基本的代码组成单元就是一个一个的类，平时我们说写Java代码，不就是写一个一个的类吗？是不是。



然后在一个一个的类里我们会定义各种变量，方法，数据结构，通过if else之类的语法，写出来各种各样的系统业务逻辑，这就是所谓的编程了。



所以JVM既然要执行你写的代码，首先当然得把你写好的类加载到内存里来啊！



所以JVM的内存区域里大家都知道，有一块区域叫做永久代，当然JDK 1.8以后都叫做Metaspace了，我们也用最新的说法好了。



这块内存区域就是用来存放你系统里的各种类的信息的，包括JDK自身内置的一些类的信息，都在这块区域里。



JVM有类加载器和一套类加载的机制，我们在专栏最开始的时候都说过了，这里不再赘述，他会负责把我们写好的类从编译好的“.class”字节码文件里加载到内存里来，如下图。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/31517700_1568043570.cn/txdocpic/0/c231793f708c0f419d80e3f40068cf36/0)             

好，那么既然有这么一块Metaspace区域是用来存放类信息的，**那是不是有可能在这个Metaspace区域里就会发生OOM？**



没错，是有这种可能的。





**4、Java虚拟机栈：让线程执行各种方法**



大家都知道，我们写好的那些Java代码虽然是一个一个的类，但是其实核心的代码逻辑一般都是封装在类里面的各种方法中的



比如JVM已经加载了我们写好的HelloWorld类到内存里了，接着怎么执行他里面的代码呢？



Java语言中的一个通用的规则，就是一个JVM进程总是从main方法开始执行的，所以我们既然在HelloWorld中写了一个main()方法，那么当然得执行这个方法中的代码了。



但是等一等，JVM进程里的谁去执行main()方法的代码？



其实我们所有的方法执行，都必须依赖JVM进程中的某个线程去执行，你可以理解为线程才是执行我们写的代码的核心主体。



JVM进程启动之后默认就会有一个main线程，这个main线程就是专门负责执行main()方法的。



大家如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/50297200_1568043570.cn/txdocpic/0/d6a9ad82a80a9ed7c56da206869a761c/0)      现在又有一个问题了，在main()方法里定义了一个局部变量，“message”，那么大家回忆一下，这些方法里的局部变量可能会有很多，那么这些局部变量是放在哪里的呢？



很简单，每个线程都有一个自己的虚拟机栈，就是所谓的栈内存。



然后这个线程只要执行一个方法，就会为方法创建一个栈桢，将栈桢放入自己的虚拟机栈里去，然后在这个栈桢里放入方法中定义的各种局部变量，如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65495200_1568043570.cn/txdocpic/0/a69acbe3d7c357327951d3a96ee225dd/0)      好，现在问题来了，大家如果还记得之前我们讲过的一个参数，应该都知道，我们是可以设置JVM中每个线程的虚拟机栈的内存大小的，一般是设置为1MB。



那么既然每个线程的虚拟机栈的内存大小是固定的，是否可能会发生虚拟机栈的内存溢出？



没错，所以**第二块可能发生OOM的区域，就是每个线程的虚拟机栈内存。**





**5、堆内存：放我们创建的各种对象**



最后我们知道，我们写好的代码里，特别在一些方法中，可能会频繁的创建各种各样的对象，这些对象都是放在堆内存里的，如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/93680500_1568043570.cn/txdocpic/0/379a9f83efe32446ecea99fe551182d8/0)            

而且我们通过之前的学习，也都知道了一点，通常我们在JVM中分配给堆内存的空间其实一般是固定的



既然如此，我们还不停在堆内存里创建对象，是不是说明，堆内存也有可能会发生内存溢出？



没错，**第三块可能发生内存溢出的区域，就是堆内存空间！**





**6、本文总结**



这篇文章我们从Java代码的运行的角度去分析了一下，我们写好的代码在运行的过程中涉及到了哪几块内存区域，然后这几块内存区域是不是就是有可能发生内存溢出的区域



大家先通过这篇文章的一步一图分析回顾一下，脑子里慢慢形成一些流动的图形，**接下来三天，我们就分别来分析一下Metaspace、Java虚拟机栈和堆内存这几块内存区域到底在什么情况下会发生内存溢出。**



# 073、Metaspace区域是如何因为类太多而发生内存溢出的？

2019-09-11 07:00:00

**1、前文回顾**



上一篇文章我们已经把JVM的运行原理重新回顾了一遍，大家脑子里应该能重新浮现出JVM运行我们写的那些代码的流程图了。



而且结合那个运行流程，我们也点出来了有哪几块区域可能会发生内存溢出，那么今天我们就来着重分析一下Metaspace区域到底为什么会发生内存溢出。





**2、Metaspace区域是如何触发内存溢出的？**



好，我们通过之前的学习都知道，在启动一个JVM时是可以设置很多参数的，其中有一些参数就是专门用来设置Metaspace区域的内存大小的，大家如果有遗忘的回顾一下之前的文章即可。



如下两个参数就是用来设置Metaspace区域大小的：



-XX:MetaspaceSize=512m 

-XX:MaxMetaspaceSize=512m



我们看下图，图中我们就限定了Metaspace区域的内存大小为512m。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8182400_1568128782.cn/txdocpic/0/ebae405b97395f3b45bfc971638d1679/0)             

所以实际上来说，在一个JVM中，Metaspace区域的大小是固定的，比如512MB。



那么一旦JVM不停地加载类，加载了很多很多的类，然后Metaspace区域放满了，此时会如何？大家看下图。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/43496200_1568128782.cn/txdocpic/0/ad484e64ea9c2a8b1c9c8356cd7a49f1/0)             

大家如果还记得之前我们说过的频繁Full GC触发的几个问题，其中之一就是Metaspace区域满就会触发Full GC，Full GC会带着一块进行Old GC就是回收老年代的，也会带着回收年轻代的Young GC。



当然，Full GC的时候，必然会尝试回收Metaspace区域中的类，如下图所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/73875800_1568128782.cn/txdocpic/0/fd5afd50c59eda1fe936a82f9fae01ef/0)            

所以一旦Metaspace区域满了，此时会触发Full GC，连带着回收Metaspace里的类。



那么什么样的类才是可以被回收的呢？



这个条件是相当的苛刻，包括不限于以下一些：比如这个类的类加载器先要被回收，比如这个类的所有对象实例都要被回收，等等。



所以一旦你的Metaspace区域满了，未必能回收掉里面很多的类



那么一旦回收不了多少类，此时你的JVM还在拼命的加载类放到Metaspace里去，你觉得此时会发生什么事情？



显而易见，一旦你尝试回收了Metaspace中的类之后发现还是没能腾出来太多空间，此时还要继续往Metaspace中塞入更多的类，直接就会引发内存溢出的问题。因为此时Metaspace区域的内存空间不够了。



一旦发生了内存溢出就说明JVM已经没办法继续运行下去了，此时可能你的系统就直接崩溃了，这就是Metaspace区域发生内存溢出的一个根本的原理。





**3、到底什么情况下会发生Metaspace内存溢出？**



平心而论，Metaspace这块区域一般很少发生内存溢出，如果发生内存溢出一般都是因为两个原因：



- 第一种原因，很多工程师他不懂JVM的运行原理，在上线系统的时候对Metaspace区域直接用默认的参数，即根本不设置其大小

  

  这会导致默认的Metaspace区域可能才几十MB而已，此时对于一个稍微大型一点的系统，因为他自己有很多类，还依赖了很多外部的jar包有有很多的类，几十MB的Metaspace很容易就不够了



- 第二种原因，就是很多人写系统的时候会用cglib之类的技术动态生成一些类，一旦代码中没有控制好，导致你生成的类过于多的时候，就很容易把Metaspace给塞满，进而引发内存溢出



对于第一种问题，通常来说，有经验的工程师上线系统往往会设置对应的Metaspace大小，推荐的值在512MB那样，一般都是足够的。



对于第二种问题，我们下周就会用模拟代码给大家演示那种不停的生成大量的类的情况，让大家亲眼看到这种情况下是如何触发Metaspace内存溢出的。





**4、本文总结**



今天的文章给大家分析了一下Metaspace区域发生内存溢出的原理，同时给出了大家两种常见的触发Metaspace内存溢出的场景



大家以后只要记得，合理分配Metaspace区域，同时避免无限制的动态生成类，一般这块区域其实都是比较安全的，不至于会触发内存溢出的。



# 074、无限制的调用方法是如何让线程的栈内存溢出的？

2019-09-12 07:00:00

**1、前文回顾**



上一篇文章我们已经分析了Metaspace区域内存溢出的原理和两种情况，这篇文章我们就顺着JVM的运行原理继续分析一下，线程的栈内存是如何内存溢出的。



因为在JVM加载了我们写的类到内存里之后，下一步就是去通过线程执行方法，此时就会有方法的入栈出栈相关的操作，那么我们来分析一下线程的栈内存到底是因为什么原因会导致溢出呢？







**2、一个线程调用多个方法的入栈和出栈**



大家先回顾一下之前我们画好的图，那个图是一个相对较为完整的JVM运行原理图，如下所示。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33617700_1568197770.cn/txdocpic/0/185b58568f2dd548384149ab971913cf/0)            



现在我们来看下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/38993200_1568197997.png)



按照我们之前所说的，JVM启动之后，HelloWorld类被加载到了内存里来，然后就会通过main线程执行main()方法



此时在main线程的虚拟机栈里，就会压入main()方法对应的栈桢，里面就会放入main()方法中的局部变量。



大家看看上面的图，在图里是不是有main线程的虚拟机栈和main()方法的栈桢的概念？



而且我们还知道一个概念，就是我们是可以手动设置每个线程的虚拟机栈的内存大小的，一般来说现在默认都是给设置1MB



所以看下图，main线程的虚拟机栈内存大小一般也是固定的。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65633700_1568197770.cn/txdocpic/0/e8f62c3949a55c139a00266f96ecfbf6/0)             

现在回过头思考一下上面的代码，代码中是不是在main()方法中又继续调用了一个sayHello()方法？



而且sayHello()方法中也会自己的局部变量，所以此时会继续将sayHello()方法的栈桢压入到main线程的虚拟机栈中去，如下图。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8094300_1568197771.cn/txdocpic/0/50dcf95cde3e9794d94cefc343565285/0)            

接着sayHello()方法如果运行完毕之后，就不需要为这个方法在内存中保存他的一些局部变量之类的东西了，此时就会将sayHello()方法对应的栈桢从main线程的虚拟机栈里出栈，如下图。

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21521700_1568197771.cn/txdocpic/0/6aa85ce80092ce7cb6f9e38d46cad179/0)            

再接着，一旦main()方法自己本身也运行完毕，自然会将main()方法对应的栈桢也从main线程的虚拟机栈里出栈，这里我们就不在图里表示出来了。





**3、一个重要的概念：每次方法调用的栈桢都是要占用内存的**



在这里，要给大家明确一个重要的概念，那就是每个线程的虚拟机栈的大小是固定的，比如可能就是1MB，然后每次这个线程调用一个方法，都会将本次方法调用的栈桢压入虚拟机栈里，这个栈桢里是有方法的局部变量的。



虽然说一些变量和其他的一些数据占用不了太大的内存，但是大家要记得，每次方法调用的栈桢实际上也是会占用内存的！



这是非常关键的一点，哪怕一个方法调用的栈桢就占用几百个字节的内存，那也是内存占用！





**4、到底什么情况下会导致JVM中的栈内存溢出？**



既然明确了上述前提之后，那么大家思考一下，到底什么情况下JVM中的栈内存会溢出呢？



其实非常简单，既然一个线程的虚拟机栈内存大小是有限的，比如1MB，那么假设你不停的让这个线程去调用各种方法，然后不停的把方法调用的栈桢压入栈中，是不是就会不断的占用这个线程1MB的栈内存？



如下图所示

​           ![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/44118500_1568197771.cn/txdocpic/0/69eae644832e9b3719a9bb0c69bd0e0d/0)             

那么如果不停的让线程调用方法，不停的往栈里放入栈桢，此时终有一个时刻，大量的栈桢会消耗完毕这个1MB的线程栈内存，最终就会导致出现栈内存溢出的情况。





**5、一般什么情况下会发生栈内存溢出？**



那么一般什么情况下会发生栈内存溢出呢？



通常而言，哪怕你的线程的虚拟机栈内存就128KB，或者256KB，通常都是足够进行一定深度的方法调用的。



但是如果说你要是走一个递归方法调用，那就不一定了，看下面的代码。



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/25581100_1568197997.png)



一旦出现上述代码，一个线程就会不停的调用同一个方法，即使是同一个方法，每一次方法调用也会产生一个栈桢压入栈里，比如说对sayHello()进行100次调用，那么就会有100个栈桢压入中。



所以如果疯狂的运行上述代码，就会不停的将sayHello()方法的栈桢压入栈里，最终一定会消耗掉线程的栈内存，引发内存溢出。



所以一般来说，其实引发栈内存溢出，往往都是代码里写了一些bug才会导致的，正常情况下发生的比较少。





**6、今日文章总结**



今天我们分析了栈内存溢出的根本原理和可能触发的一个场景，就是方法递归调用



但是一般来说，其实只要注意一下代码的编写，避免出现无限制的方法递归，就一般可以避免栈内存的溢出。