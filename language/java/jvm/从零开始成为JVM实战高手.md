# 从零开始成为JVM实战高手

https://pc-shop.xiaoe-tech.com/apppuKyPtrl1086/columnist_detail?id=p_5d0ef9900e896_MyDfcJi8

# 001、开篇词：JVM优化实战，广大Java工程师心中永远的痛！

2019-06-23 12:15:22

**开篇词：**

**JVM优化实战，广大Java工程师心中永远的痛！**



平时很多朋友跑来找我问以下一些类似的问题：

1. 线上用Dubbo开发的一个系统突然卡死了，JVM FullGC太频繁，求救！

   

   

2. 生产环境部署的一个系统隔几天就莫名其妙的进程崩溃，看了眼异常信息，说是OOM内存溢出，如何解决？在线等，急！

3. 出去面试，光是说一些JVM的内存模型、垃圾回收算法，不够啊！

   面试官怎么老是盯着我问生产环境遇到的JVM问题，各种参数的优化之类的，完全没经历过



类似的问题听的多了，我发现目前国内大多数Java工程师都面临一个共同的问题。



即对JVM的了解仅停留于书本和理论知识，而对JVM生产环境中的实战优化几乎一无所知。



有的朋友是一直开发那种几十个人使用的内部系统，所以没机会接触和经历。有的朋友是突然遇到线上JVM生产事故，毫无头绪。



为什么会造成这类现状呢？



答案其实也很简单，目前国内JVM相关的学习资料主要是两类：

- 一种是一些JVM大牛作者写的书籍
- 一种是网上大量凌乱繁杂的JVM实践博客。



对于JVM大牛写的一些书籍，其实都是很好的一些资料。但是书的本意并不是提供给你实战经验。



书的作用是站在理论知识总结和梳理的角度，把一个完整的理论知识体系呈现给你。



因此，从书上学到的也主要是体系化的理论知识。



而且虽然很多书籍的作者技术功底极为深厚，但是书里的内容非常的深奥晦涩，难以理解。



导致很多人即使是这种JVM的理论知识，也仅仅是吸收了里面可能就10%的精华，其他的也没法消化理解。



更重要的，从书本中，也更不可能获得JVM生产故障的实践经验和解决方案。



然后就是网上大量凌乱繁杂的JVM相关博客，很多作者其实确实是在记录自己遇到的一些JVM的生产故障的解决过程。



但是问题在于，博客往往是作者自己记录的经历，面向的是自己，一切站在自己的角度出发。



而对于这个项目的背景、线上多大用户量、多少数据量、多大并发量、核心业务流程，在什么生产场景下发生的问题？**啥都没有！**



此外，对解决问题过程中涉及到的一些JVM底层原理，很多作者也不会说明白。



这就导致很多读者看博客，根本看不懂，搞不明白为什么会发生这个问题，搞不明白解决这个JVM生产故障背后的原理是什么！



**一句话总结**：放眼望去，目前国内并没有一个真正系统化讲解**JVM生产实战**的技术资料！



正是这个原因，导致了大量的Java工程师内心中对“**JVM实战**”这块内容有很大的痛点。



造成的直接后果就是遇到JVM生产事故不知道怎么处理和解决，出去面试被人问JVM生产实践毫无头绪！



因此我针对这些痛点，推出了**《**从零开始带你成为JVM实战高手**》**专栏。



这个专栏将作为一座桥梁，我将通过它，将我十余年线上处理JVM生产事故的经验，浓缩精华，传授给你。



考虑到目前国内大部分java程序员的JVM学习现状，这个专栏从设计时，就完全从两个角度出发：

- JVM理论知识从0起步，基于大量手绘图，保证让小白都能看懂

  

- 全程专注于JVM生产实践，主要解决JVM生产环境的参数优化，JVM GC问题和JVM OOM问题的处理



下面详细说一下上述两点：

1. 对于JVM必不可少的内存模型、类加载、垃圾回收等核心理论知识，我会采用几乎一步一图的方式进行讲解。

   另外配合上通俗易懂的大白话描述，带着大家彻底搞明白JVM底层的一些原理性知识

   JVM理论知识**讲解标准**：哪怕是对JVM完全不了解的小白同学，也一定能看得懂、学得会！

2. 然后重点，则完全放在“**实战**”二字。整个专栏一共有30多个真实的生产案例，都是我多年带团队负责的各种系统中出现和遇到的JVM生产问题，比如：

3. - 每日百万交易的支付系统的JVM生产参数优化
   - 每日上亿请求量的电商系统的GC参数优化
   - 百万级用户的在线教育平台的G1垃圾回收优化
   - 更不用说每秒10万并发的BI系统、每日百亿数据量的处理系统、视频系统、大促系统等各类系统中的JVM GC问题和JVM OOM问题的生产优化



更重要的一点，每个案例绝对**站在一个读者的角度**出发，也就是从业务背景出发。



案例中会包含这个系统的用户量、并发量、数据量以及核心业务流程，进而给出发生生产故障的真实场景



然后是一步一步如何分析、排查和定位每个问题的，包括解决问题的过程中涉及到的底层JVM原理的剖析。



我的思路，就是用大量的生产案例贯穿整个专栏，进而教给大家遇到JVM生产事故时一个常规性的定位排查、分析解决问题的思路和方法



同时通过大量真实案例的演练，让大家直接积累起丰富的生产故障排查经验



此外，在专栏中还有大量的动手实验的环节，会设计很多的实验，大家只要照着做，就可以体验到各种JVM生产问题的现场。



然后再自己一步步去进行监控、分析日志，这样可以很好的锻炼大家的动手实践能力。



而且在每周我都会留下很多作业，作业会引导你去思考你手头负责的系统。



假设你的并发量、数据量扩大100倍，你会不会遇到JVM问题？如果在你的系统中遇到问题，你该怎么来处理和解决？



通过这类作业，目的就是引导大家思考如何将学习到的各种实战技能进行落地，让自己真正掌握。



通过这样的一个JVM实战专栏的学习，我相信每个认真跟着学习下来的Java工程师，都能够拥有如下的能力：

- 对自己负责的线上系统，可以进行生产环境的JVM参数优化
- 线上遇到生产故障，自己绝对有思路去进行分析、排查和定位
- 你会清楚怎么去动手实践，明白背后的JVM的底层原理
- 此外，你通过课程积累好的几十个案例的经验，也将支撑你去对各种不同的生产故障进行解决和处理



另外专栏还会贯穿大量的**大厂JVM面试题剖析**，因此在学习完专栏过后，大家出去面试，无论是JVM的原理，还是JVM的生产实践，国内没有公司面得倒你。



最后，从这篇文章开始，咱们即将一起走过15周的学习旅程。希望15周之后，这里的每个同学都能从0开始，成为一个JVM实战高手！



**End**



# 002、一探究竟：我们写的Java代码到底是如何运行起来的？

2019-06-23 14:08:45

**一探究竟：**

**我们的Java代码到底是如何运行起来的？**

本文是我们正式开始讲解JVM的第一篇文章。

第一周我们不会讲解太多过于深奥的原理知识，那样会让很多原本对JVM不太了解的同学难以平滑的入门。

第一周的内容主要是高屋建瓴的把JVM运行机制的整体脉络梳理清楚，而很多原本对JVM就有一定了解的同学，可以耐下心来，就当做是复习梳理一下。

要研究JVM技术，先得搞明白一个问题：

- **我们平时写的Java代码，到底是怎么运行起来的？**

针对这个问题，我们来一步一步的分析。

首先假设咱们写好了一份Java代码，那这份Java代码中，是不是会包含很多的“.java”为后缀的代码文件？

比如User.java，OrderService.java，CustomerManager.java

其实咱们Java程序员平时在Eclipse、Intellij IDEA等开发工具中，就有很多类似这样的Java源代码文件。

那么大家现在思考一下，当我们写好这些“.java”后缀的代码文件之后，接下来你要部署到线上的机器上去运行，你会怎么做？

一般来说，都是把代码给打成“.jar”后缀的jar包，或者是“.war”后缀的war包，是不是？

然后呢，就是把你打包好的jar包或者是war包给放到线上机器去部署。

这个部署就有很多种途径了，但是最基本的一种方式，就是通过Tomcat这类容器来部署代码，也可以是你自己手动通过“java”命令来运行一个jar包中的代码。

咱们先用下面这张图，回忆一下这个顺序。

![01_打包.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60992200_1561998556.png)



但是实际上这里有一个非常关键的步骤，那就是“**编译**”

也就是说，在我们写好的“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件，比如“User.class”，“Hello.class”，”Customer.class“。

然后这个“.class”后缀的字节码文件，他才是可以被运行起来的！

所以首先，无论大家对JVM机制是否熟悉，咱们都先来回顾一下这个编译的过程，以及“.class”字节码文件的概念。

来看看下图，一起来感受一下：

![02_编译.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85310300_1561998556.png)

接着我们可能就要思考下一个问题：

对于编译好的这些“.class”字节码，是怎么让他们运行起来的呢？

这个时候就需要使用诸如“java -jar”之类的命令来运行我们写好的代码了。

此时一旦你采用“java”命令，实际上此时就会启动一个JVM进程。

这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

所以平时我们写好的某个系统在一台机器上部署的时候，你一旦启动这个系统，其实就是启动了一个JVM，由它来负责运行这台机器上运行的这个系统。

对这个概念，大家一定要先搞清楚。

我们还是用一张图来展示一下，相信大家图文结合，会理解的更好。

![03_jvm.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3266600_1561998557.png)



接着下一步，JVM要运行这些“.class”字节码文件中的代码，那是不是首先得把这些“.class”文件中包含的各种类给加载进来？

这些“.class”文件不就是我们写好的一个一个的类吗？对不对？

此时就会有一个“**类加载器**”的概念。

此时会采用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

我们再看下图。

![04_类加载.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13473300_1561998557.png)



接着，最后一步，JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了

比如你的代码中有一个“main()”方法，那么JVM就会从这个“main()”方法开始执行里面的代码。

他需要哪个类的时候，就会使用类加载器来加载对应的类，反正对应的类就在“.class”文件中。

大家最后看看下面的图。

![05_执行代码.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24399300_1561998557.png)

好，最后我们来对本文小结一下：

无论是对JVM了解或者是不了解的同学，我们都希望通过第一周的基本原理知识讲解，降低学习后面JVM优化实战技术的门槛。

对于了解JVM的同学权当复习梳理，而且鼓励大家在底部评论发言，说说自己的理解和看法。

对于不太了解JVM的小白同学，也可以抄底门槛迅速入门，无缝衔接后续的知识学习。

所以本文从我们平时写“.java”后缀的源代码开始，一步一步梳理了以下的流程：

- 写好的代码编译成“.class”后缀的字节码文件
- JVM是个什么东西
- JVM跟我们平时运行在机器上的系统之间是什么关系
- 类加载器的概念
- 针对加载进内存的类进行代码的执行

这就是本文讲解的内容总结，希望大家对这部分内容高屋建瓴的先有一个认识。

另外，最后我给大家留一个思考题：既然“.java”文件可以编译成“.class”文件再运行，那么也肯定可以将“.class”文件反编译成“.java”文件。

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

大家可以思考思考，踊跃提问和发言，明天的文章里，在末尾我会跟大家探讨一下这个问题。

**End**



# 003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？

2019-06-23 14:31:28

**面试官对于JVM类加载机制的猛烈炮火，****你能顶住吗？**



**目录：**

1. 前文回顾
2. JVM在什么情况下会加载一个类？
3. 从实用角度出发，来看看验证、准备和初始化的过程
4. 核心阶段：初始化
5. 类加载器和双亲委派机制
6. 昨日思考题的解答





**1、前文回顾**

咱们今天先来回顾一下昨天讲到的JVM整体的一个运行原理。

我们首先从“.java”代码文件，编译成“.class”字节码文件

然后类加载器把“.class”字节码文件中的类给加载到JVM中

接着是JVM来执行我们写好的那些类中的代码，整体是这么个顺序。

再看看下图，感受一下这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67189100_1562062006.cn/txdocpic/0/85881164faa1fa93a71120127057d4c3/0)

那么今天，我们就来仔细看看上图中的“**类加载**”这个过程，看看JVM的类加载机制到底是怎么样的？

搞清楚这个过程了，那么以后在面试时，对面试官常问的JVM类加载机制，就能把一些核心概念说清楚了。



**2、JVM在什么情况下会加载一个类？**

其实类加载过程非常的琐碎复杂，但是对于我们平时从工作中实用的角度来说，主要是把握他的核心工作原理就可以。

一个类从加载到使用，一般会经历下面的这个过程：

**加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载**

所以首先要搞明白的第一个问题，就是JVM在执行我们写好的代码的过程中，一般在什么情况下会去加载一个类呢？

也就是说，啥时候会从“.class”字节码文件中加载这个类到JVM内存里来。

其实答案非常简单，就是在**你的代码中用到这个类的时候**。

举个简单的例子，比如下面你有一个类（Kafka.class），里面有一个“main()”方法作为主入口。

那么一旦你的JVM进程启动之后，它一定会先把你的这个类（Kafka.cass）加载到内存里，然后从“main()”方法的入口代码开始执行。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/81370700_1562062006.png)



我们还是坚持一步一图，大家先看看下图，感受一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99941000_1562062006.cn/txdocpic/0/20b99ce2902c58d0a246861f046cc402/0)

接着假设上面的代码中，出现了如下的这么一行代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/16673900_1562062007.png)



这时可能大家就想了，你的代码中明显需要使用“ReplicaManager”这个类去实例化一个对象，此时必须得把“ReplicaManager.class”字节码文件中的这个类加载到内存里来啊！是不是？

所以这个时候就会触发JVM通过类加载器，从“ReplicaManager.class”字节码文件中加载对应的类到内存里来使用，这样代码才能跑起来。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/34835300_1562062007.cn/txdocpic/0/8a2acdae659f69979687cafb5470e80a/0)

上面就是给大家举的一个例子，相信非常的通俗易懂。

简单概括一下：首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。



**3、从实用角度出发，来看看验证、准备和初始化的过程**

其实上面的类加载时机的问题，对于很多有经验的同学来说不是什么问题。

但是对于很多初学者来说，是一个非常重要的需要捋清的概念。

接下来就来简单带着大家，从实用的角度出发，过一下另外三个概念：

**验证、准备、初始化**

其实对于这三个概念，没太大的必要去深究里面的细节，这里的细节很多很繁琐，对于大部分同学而言，只要脑子里有下面的几个概念就可以了：

**（1）验证阶段**

简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。

这个相信很好理解，假如说，你的“.class”文件被人篡改了，里面的字节码压根儿不符合规范，那么JVM是没法去执行这个字节码的！

所以把“.class”加载到内存里之后，必须先验证一下，校验他必须完全符合JVM规范，后续才能交给JVM来运行。

下面用一张图，展示了这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47365600_1562062007.cn/txdocpic/0/9b5b706b0486cce3c20e53cc2d13cd07/0)

**（2）准备阶段**

这个阶段其实也很好理解，咱们都知道，我们写好的那些类，其实都有一些类变量

比如下面的这个“ReplicaManager”类：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/71602900_1562062007.png)

假设你有这么一个“ReplicaManager”类，他的“ReplicaManager.class”文件内容刚刚被加载到内存之后，会进行验证，确认这个字节码文件的内容是规范的

接着就会进行准备工作。

这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间

然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值

比如上面的示例里，就会给“flushInterval”这个类变量分配内容空间，给一个“0”这个初始值。

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83060200_1562062007.cn/txdocpic/0/c9f43e3b1451aa91cfbfb8a7b6abad30/0)



**（3）解析阶段**

这个阶段干的事儿，实际上是把**符号引用替换为直接引用**的过程，其实这个部分的内容很复杂，涉及到JVM的底层

但是注意，同学们，就我本意而言，希望第一周的文章，绝对是浅显易懂的，循序渐进，要保证每个同学都能绝对看懂。

所以针对这个阶段，现在不打算做过深的解读，因为从实用角度而言，对很多同学在工作中实践JVM技术其实也用不到，所以这里大家就暂时知道有这么一个阶段就可以了。

同样，我还是给大家画图展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96343600_1562062007.cn/txdocpic/0/34ebc43cda680141456638ca4963e770/0)

**（4）三个阶段的小结**

其实这三个阶段里，最核心的大家务必关注的，就是**“准备阶段”**

因为这个阶段是给加载进来的类分配好了内存空间，类变量也分配好了内存空间，并且给了默认的初始值，这个概念，大家心里一定要有。



**4、核心阶段：初始化**

之前说过，在准备阶段时，就会把我们的“ReplicaManager”类给分配好内存空间

另外他的一个类变量“flushInterval”也会给一个默认的初始值“0”，那么接下来，在初始化阶段，就会正式执行我们的类初始化的代码了。

那么什么是类初始化的代码呢？我们来看看下面这段代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8399800_1562062008.png)

大家可以看到，对于“flushInterval”这个类变量，我们是打算通过Configuration.getInt("replica.flush.interval")这段代码来获取一个值，并且赋值给他的

但是在准备阶段会执行这个赋值逻辑吗？

**NO！**在准备阶段，仅仅是给“flushInterval”类变量开辟一个内存空间，然后给个初始值“0”罢了。

那么这段赋值的代码什么时候执行呢？答案是在**“初始化”**阶段来执行。

在这个阶段，就会执行类的初始化代码，比如上面的  Configuration.getInt("replica.flush.interval")  代码就会在这里执行，完成一个配置项的读取，然后赋值给这个类变量“flushInterval”。

另外比如下图的static静态代码块，也会在这个阶段来执行。

类似下面的代码语义，可以理解为类初始化的时候，调用“loadReplicaFromDish()”方法从磁盘中加载数据副本，并且放在静态变量“replicas”中：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24615100_1562062008.png)

那么搞明白了类的初始化是什么，就得来看看类的初始化的规则了。

**什么时候会初始化一个类？**

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41037200_1562062008.png)

如果你要“new ReplicaManager()”初始化这个类的实例，那么会加载这个类，然后初始化这个类

但是初始化这个类之前，发现AbstractDataManager作为父类还没加载和初始化，那么必须先加载这个父类，并且初始化这个父类。

这个规则，大家必须得牢记，再来一张图，借助图片来进行理解：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53805800_1562062008.cn/txdocpic/0/605fa929375991cb7645c28f8f815b0f/0)



**5、类加载器和双亲委派机制**

现在相信大家都搞明白了整个类加载从触发时机到初始化的过程了，接着给大家说一下类加载器的概念

因为实现上述过程，那必须是依靠类加载器来实现的

那么Java里有哪些类加载器呢？简单来说有下面几种：

**（1）启动类加载器**

**Bootstrap ClassLoader**，他主要是负责加载我们在机器上安装的Java目录下的核心类的

相信大家都知道，如果你要在一个机器上运行自己写好的Java系统，无论是windows笔记本，还是linux服务器，是不是都得装一下JDK？

那么在你的Java安装目录下，就有一个“**lib**”目录，大家可以自己去找找看，这里就有Java最核心的一些类库，支撑你的Java系统的运行。

所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

**（2）扩展类加载器**

**Extension ClassLoader**，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

那么你的JVM一旦启动，是不是也得从Java安装目录下，加载这个“lib\ext”目录中的类？

**（3）应用程序类加载器**

**Application ClassLoader**，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类

其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

**（4）自定义类加载器**

除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

**（5）双亲委派机制**

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65579400_1562062008.cn/txdocpic/0/932fe13b12b449c8a97fc42e6029b613/0)

然后，基于这个亲子层级结构，就有一个**双亲委派的机制**

什么意思呢？

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

听完了上面一大堆绕口令，是不是很迷茫？别着急，咱们用一个例子来说明一下。

比如你的JVM现在需要加载“ReplicaManager”类，此时应用程序类加载器会问问自己的爸爸，也就是扩展类加载器，你能加载到这个类吗？

然后扩展类加载器直接问自己的爸爸，启动类加载器，你能加载到这个类吗？

启动类加载器心想，我在Java安装目录下，没找到这个类啊，**自己找去**！

然后，就下推加载权利给扩展类加载器这个儿子，结果扩展类加载器找了半天，也没找到自己负责的目录中有这个类。

这时他很生气，说：明明就是你应用程序加载器自己负责的，你自己找去。

然后应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。

这就是所谓的**双亲委派模型：**先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。

最后，给大家来一张图图，感受一下类加载器的双亲委派模型。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79558100_1562062008.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**6、昨日思考题的解答**

好！今天的文章看完了，相信大家就能大致推测出昨日的思考题的答案了。

我昨天的问题是：如何对“.class”文件处理保证不被人拿到以后反编译获取公司源代码？

其实认真看完今天的文章，就很简单了。

首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理

现在有很多第三方公司，都是专门做商业级的字节码文件加密的，所以可以付费购买他们的产品。

然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人窃取。

**7、今日思考题**

今天再给大家留一个思考题，相信每个做Java的同学，都知道现在一般用Java开发的Web系统，除非是基于Java写中间件，一般都是采用Tomcat之类的Web容器来部署的。

那么大家想想，Tomcat本身就是用Java写的，他自己就是一个JVM。

我们写好的那些系统程序，说白了，就是一堆编译好的.class文件放入一个war包，然后在Tomcat中来运行的。

那么，Tomcat的类加载机制应该怎么设计，才能把我们动态部署进去的war包中的类，加载到Tomcat自身运行的JVM中，然后去执行那些我们写好的代码呢？

大家先思考，明天文末会给大家进行梳理并给出答案。

**End**



# 004、大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的？

2019-06-23 14:34:05

**大厂面试题**

**JVM中有哪些内存区域，分别是用来干嘛的？**



目录：

1. 前文回顾
2. 大厂面试背景引入
3. 到底什么是JVM的内存区域划分？
4. 存放类的方法区
5. 执行代码指令用的程序计数器
6. Java虚拟机栈
7. Java堆内存
8. 核心内存区域的全流程串讲
9. 其他内存区域
10. 本文小结
11. 昨日思考题解答
12. 今日思考题



**1、前文回顾**

上一篇文章我们聊了一下JVM类加载这块的机制，先简单回顾一下。

大家需要搞明白的是，在什么情况下会触发类的加载？加载之后的验证、准备和解析分别是干什么的？

尤为重要的是准备阶段和初始化阶段，是如何为类分配内存空间的？然后类加载器的规则是什么？

来看一下上篇文章的图，简单回顾一下。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51671600_1562174045.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**2、大厂面试背景引入**

很多人想要到阿里、美团、京东等互联网大公司去面试，但是现在互联网大厂面试一般都必定会考核JVM相关的知识积累

所以在了解完了JVM的类加载机制之后，先一起来看看JVM的内存区域划分，这个基本上是互联网公司面试必问。



**3、到底什么是JVM的内存区域划分？**

其实这个问题非常简单，JVM在运行我们写好的代码时，他是必须使用多块内存空间的，不同的内存空间用来放不同的数据，然后配合我们写的代码流程，才能让我们的系统运行起来。

举个最简单的例子，比如咱们现在知道了JVM会加载类到内存里来供后续运行，那么我问问大家，这些类加载到内存以后，放到哪儿去了呢？想过这个问题吗？

所以JVM里就必须有一块内存区域，用来存放我们写的那些类。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68335300_1562174045.cn/txdocpic/0/a36d967a636bd6cba968132fe7d5a2fe/0)

继续来看，我们的代码运行起来时，是不是需要执行我们写的一个一个的方法？

那么运行方法的时候，方法里面有很多变量之类的东西，是不是需要放在某个内存区域里？

接着如果我们写的代码里创建一些对象，这些对象是不是也需要内存空间来存放？

同样的，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/87758600_1562174045.cn/txdocpic/0/40ce28b870bb122aedb3d3c9183c9d94/0)

这就是为什么JVM中必须划分出来不同的内存区域，它是为了我们写好的代码在运行过程中根据需要来使用的。

接下来，我们就依次看看JVM中有哪些内存区域。



**4、存放类的方法区**

这个方法区是在JDK 1.8以前的版本里，代表JVM中的一块区域。

主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。

但是在JDK 1.8以后，这块区域的名字改了，叫做“Metaspace”，可以认为是“元数据空间”这样的意思。当然这里主要还是存放我们自己写的各种类相关的信息。

举个例子，还是跟我们之前说的那样，假设我们有一个“Kafka.class”类和“ReplicaManager.class”类，类似下面的代码。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/7691900_1562174046.png)



这两个类加载到JVM后，就会放在这个方法区中，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/30635300_1562174046.cn/txdocpic/0/5ed39984ec95cdb3f63edcf9ff174d6f/0)





**5、执行代码指令用的程序计数器**

继续假设我们的代码是如下所示：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/51858600_1562174046.png)



之前给大家讲过，实际上上面那段代码首先会存在于“.java”后缀的文件里，这个文件就是java源代码文件。

但是这个文件是面向我们程序员的，计算机他是看不懂你写的这段代码的。

所以此时就得通过编译器，把“.java”后缀的源代码文件编译为“.class”后缀的字节码文件。

这个“.class”后缀的字节码文件里，存放的就是对你写出来的代码编译好的字节码了。

字节码才是计算器可以理解的一种语言，而不是我们写出来的那一堆代码。

字节码看起来大概是下面这样的，跟上面的代码无关，就是一个示例而已，给大家感受一下。



```
public java.lang.String getName();     descriptor: ()Ljava/lang/String;     flags: ACC_PUBLIC     Code:         stack=1, locals=1, args_size=1             0: aload_0             1: get_field    #2             4: areturn
```



这段字节码就是让大家知道“.java”翻译成的“.class”是大概什么样子的。

比如“0: aload_0”这样的，就是“字节码指令”，他对应了一条一条的机器指令，计算机只有读到这种机器码指令，才知道具体应该要干什么。

比如字节码指令可能会让计算机从内存里读取某个数据，或者把某个数据写入到内存里去，都有可能，各种各样的指令就会指示计算机去干各种各样的事情。

所以现在大家首先明白一点：**我们写好的Java代码会被翻译成字节码，对应各种字节码指令**

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。

所以当JVM加载类信息到内存之后，实际就会使用自己的**字节码执行引擎**，去执行我们写的代码编译出来的代码指令，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/70899500_1562174046.cn/txdocpic/0/82f3b71cabd27c3abf8e58509ca117f6/0)

那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”

这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。

我们通过一张图来说明：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/95852000_1562174046.cn/txdocpic/0/e735b486fa6a29c189af7d947558e70b/0)

大家都知道JVM是支持多个线程的，所以其实你写好的代码可能会开启多个线程并发执行不同的代码，所以就会有多个线程来并发的执行不同的代码指令

因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了

下图更加清晰的展示出了他们之间的关系。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24349900_1562174047.cn/txdocpic/0/ee845415897bb5b7b8cf888a2a1464d0/0)

**6、Java虚拟机栈**

Java代码在执行的时候，一定是线程来执行某个方法中的代码

哪怕就是下面的代码，也会有一个main线程来执行main()方法里的代码

在main线程执行main()方法的代码指令的时候，就会通过main线程对应的程序计数器记录自己执行的指令位置。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/49375500_1562174047.png)

但是在方法里，我们经常会定义一些方法内的局部变量

比如在上面的main()方法里，其实就有一个“replicaManager”局部变量，他是引用一个ReplicaManager实例对象的，关于这个对象我们先别去管他，先来看方法和局部变量。

因此，JVM必须有一块区域是来保存每个方法内的**局部变量**等数据的，这个区域就是Java虚拟机栈

每个线程都有自己的Java虚拟机栈，比如这里的main线程就会有自己的一个Java虚拟机栈，用来存放自己执行的那些方法的局部变量。

如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧

栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西，这里大家先不用全都理解，我们先关注局部变量。

比如main线程执行了main()方法，那么就会给这个main()方法创建一个栈帧，压入main线程的Java虚拟机栈

同时在main()方法的栈帧里，会存放对应的“replicaManager”局部变量

上述过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67197800_1562174047.cn/txdocpic/0/4197da8f1fcfa8b97b97638b6247e5c3/0)

然后假设main线程继续执行ReplicaManager对象里的方法，比如下面这样，就在“loadReplicasFromDisk”方法里定义了一个局部变量：“hasFinishedLoad”

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92921500_1562174047.png)



那么main线程在执行上面的“loadReplicasFromDisk”方法时，就会为“loadReplicasFromDisk”方法创建一个栈帧压入线程自己的Java虚拟机栈里面去。

然后在栈帧的局部变量表里就会有“hasFinishedLoad”这个局部变量。

整个过程如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10232200_1562174048.cn/txdocpic/0/7192f064bdb42017288b83dafa584709/0)

接着如果“loadReplicasFromDisk”方法调用了另外一个“isLocalDataCorrupt()”方法 ，这个方法里也有自己的局部变量

比如下面这样的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20448000_1562174116.png)



那么这个时候会给“isLocalDataCorrupt”方法又创建一个栈帧，压入线程的Java虚拟机栈里。

而且“isLocalDataCorrupt”方法的栈帧的局部变量表里会有一个“isCorrupt”变量，这是“isLocalDataCorrupt”方法的局部变量

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/33506800_1562174048.cn/txdocpic/0/457d1c2f6d89903e8e36916dda9ea744/0)

接着如果“isLocalDataCorrupt”方法执行完毕了，就会把“isLocalDataCorrupt”方法对应的栈帧从Java虚拟机栈里给出栈

然后如果“loadReplicasFromDisk”方法也执行完毕了，就会把“loadReplicasFromDisk”方法也从Java虚拟机栈里出栈。

上述就是JVM中的“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈

在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。

咱们再来看一个图，了解一下每个线程在执行代码时，除了程序计数器以外，还搭配了一个Java虚拟机栈内存区域来存放每个方法中的局部变量表。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/58381900_1562174048.cn/txdocpic/0/02705de5b5a6d20bf41b2e37e41c2a1d/0)



**7、Java堆内存**

现在大家都知道了，main线程执行main()方法的时候，会有自己的程序计数器。

此外，还会依次把main()方法，loadReplicasFromDisk()方法，isLocalDataCorrupt()方法的栈帧压入Java虚拟机栈，存放每个方法的局部变量。

那么接着我们就得来看JVM中的另外一个非常关键的区域，就是Java堆内存，这里就是存放我们在代码中创建的各种对象的

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/12867100_1562174155.png)



上面的“new ReplicaManager()”这个代码就是创建了一个ReplicaManager类的对象实例，这个对象实例里面会包含一些数据，如下面的代码所示。

这个“ReplicaManager”类里的“replicaCount”就是属于这个对象实例的一个数据。

类似ReplicaManager这样的对象实例，就会存放在Java堆内存里。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40763600_1562174255.png)



Java堆内存区域里会放入类似ReplicaManager的对象，然后我们因为在main方法里创建了ReplicaManager对象的，那么在线程执行main方法代码的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址

相当于你可以认为局部变量表里的“replicaManager”指向了Java堆内存里的ReplicaManager对象

还是给大家来一张图，更加清晰一些：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/84661900_1562174048.cn/txdocpic/0/17d3ff214c6a93034ed5829639dbca23/0)



**8、核心内存区域的全流程串讲**

其实我们把上面的那个图和下面的这个总的大图一起串起来看看，还有配合整体的代码，我们来捋一下整体的流程，大家就会觉得很清晰。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3659300_1562174049.cn/txdocpic/0/a574bfb97766cfa0c041624c117c79ca/0)



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/20435800_1562174255.png)



首先，你的JVM进程会启动，就会先加载你的Kafka类到内存里。然后有一个main线程，开始执行你的Kafka中的main()方法。

main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

大家结合上图中的程序计数器来理解一下。

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

看到这里，大家结合上面的两个图理解一下。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

其实大家理解了这个过程，那么JVM中的各个核心内存区域的功能和对应的我们的Java代码之间的关系，就彻底理解了



**9、其他内存区域**

其实在JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的

如果大家去看他内部的源码，会发现很多地方都不是Java代码了，而是走的native方法去调用本地操作系统里面的一些方法，可能调用的都是c语言写的方法，或者一些底层类库

比如下面这样的：public native int hashCode();

在调用这种native方法的时候，就会有线程对应的本地方法栈，这个里面也是跟Java虚拟机栈类似的，也是存放各种native方法的局部变量表之类的信息。

还有一个区域，是不属于JVM的，通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。

其实很多技术都会用这种方式，因为有一些场景下，堆外内存分配可以提升性能。



**10、本文小结**

本文到这里就结束了，基本上把JVM里的核心内存区域的功能解释清楚了

大家需要重点去关注方法区、程序计数器、Java虚拟机栈和Java堆这些内存区域的作用，和我们配套的图以及代码结合起来去理解。



**11、昨日思考题解答**

昨天让大家去思考一下：Tomcat这种Web容器中的类加载器应该如何设计实现？

这里给大家一个简单的思路给回复。

首先Tomcat的 类加载器体系如下图所示，他是自定义了很多类加载器的。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/23933200_1562174049.cn/txdocpic/0/9c56ad956e2c39a693c88472309c961a/0)

Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。

然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类

至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。

而且大家一定要记得，Tomcat是打破了双亲委派机制的

每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。

如果大家感兴趣，可以自己找资料去学习研究Tomcat的类加载机制。



**12、今日思考题**

今天我们学习了JVM中的各个内存区域，那么先留给大家一个思考题：

我们在Java堆内存中分配的那些对象，到底会占用多少内存？一般怎么来计算和估算我们的系统创建的对象对内存占用的一个压力呢？

# 005、JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？

2019-06-23 14:35:28

**JVM的垃圾回收机制是用来干嘛的？**

**为什么要垃圾回收？**



**目录：**

1. 前文回顾
2. 对象的分配与引用
3. 一个方法执行完毕后会怎样？
4. 我们创建的Java对象其实都是占用内存资源的
5. 不再需要的那些对象应该怎么处理？
6. 本文小结





**1、前文回顾**

上一篇文章给大家分析了JVM中的几块内存区域分别都是干什么的，今天的文章就给大家初步介绍一下垃圾回收的概念。

但是今天的文章对垃圾回收不会切入过深，因为很多学习专栏的朋友都是一些初学者。

因此，咱们还是那句话，尽量用最通俗的语言配合大量手绘图，让大家初步了解垃圾回收到底是什么。

先来看一下昨天的一张图，回顾一下JVM中几块内存区域的作用。

![01_总大图.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/27918700_1562230843.jpg)

大家脑子里一定要有一个会动的图，你的代码在运行的时候，起码有一个main线程会去执行所有的代码，当然也可能是你启动的别的线程。

然后线程执行时必须通过自己的程序计数器来记录执行到哪一个代码指令了

另外线程在执行方法时，为每个方法都得创建一个栈帧放入自己的Java虚拟机栈里去，里面有方法的局部变量。

最后就是代码运行过程中创建的各种对象，都是放在Java堆内存里的。

结合上面的大图看一看，相信大家一定就明白是怎么回事了，大家对JVM的运行原理也应该都有了一个初步的理解和把握。



**2、对象的分配与引用**

现在我们假设有下面一段代码，大概意思你可以理解为通过“loadReplicasFromDisk”方法的执行，去磁盘上加载需要的副本数据

然后通过“ReplicaManager”对象实例完成了这个操作。

代码如下所示：

![代码1.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/42627800_1562230843.png)

结合我们之前理解过的JVM运行原理，一起通过动态的图来拆解一下上述代码的运行流程。

首先一个main线程肯定会来执行main()方法里的代码

main线程自己是有一个Java虚拟机栈的，他会把main()方法的栈帧压入Java虚拟机栈

如下图所示：

![02_压入栈帧.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54079800_1562230843.jpg)

接着main()方法里调用了loadReplicasFromDisk()方法

那么就会创建loadReplicasFromDisk()方法的栈帧，压入main线程的Java虚拟机栈里去

这个过程如下图：

![03_继续压入栈帧.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67192600_1562230843.jpg)

此时发现在loadReplicasFromDisk()方法里，有一个“repliaManager”变量，那么就会在loadReplicasFromDisk()方法对应的栈帧里，放入一个“repliaManager”变量。

继续看下图：

![04_局部变量.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/92889300_1562230843.jpg)

接着发现在代码里创建了一个“ReplicaManager”类的实例对象，此时就会在Java堆内存中分配这个实例对象的内存空间。

同时，让loadReplicasFromDisk()方法的栈帧内的“replicaManager”局部变量去指向那个Java堆内存里的ReplicaManager实例对象，大家看下图：

![05_分配对象.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4461000_1562230844.jpg)

接下来，就会执行通过“replicaManager”局部变量引用的“ReplicaManager”实例对象去执行他的load()方法，去完成我们实现的业务逻辑。

好，到这里为止，其实都是上篇文章讲解过的知识，我们就是重新串联了一遍，相信大家都很好理解。



**3、一个方法执行完毕之后会怎么样？**

接着大家来回顾一下上面的代码。

![代码2.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/15050100_1562230844.png)

其实目前的图我们已经表述到了“replicaManager.load()”这行代码这里

那么现在有个问题，如果这行代码执行结束了，此时会怎么样？

大家还记得之前文章说过，一旦方法里的代码执行完毕，那么方法就执行完毕了，也就是说loadReplicasFromDisk()方法就执行完毕了。

一旦你的loadReplicasFromDisk()方法执行完毕，此时就会把loadReplicasFromDisk()方法对应的栈帧从main线程的Java虚拟机栈里出栈

如下图所示：

![06_出栈.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/29818700_1562230844.jpg)

此时一旦loadReplicasFromDisk()方法的栈帧出栈，那么大家会发现那个栈帧里的局部变量，“replicaManager”，也就没有了。

也就是说，没有任何一个变量指向Java堆内存里的“ReplicaManager”实例对象了。



**4、我们创建的Java对象其实都是占用内存资源的**

核心点来了，此时大家发现了，Java堆内存里的那个“ReplicaManager”实例对象已经没有人引用他了

这个对象实际上已经没用了，该干的事儿都干完了，现在你还让他留在内存里干啥呢？

大家要知道，内存资源是有限的。

一般来说，我们会在一台机器上启动一个Java系统，机器的内存资源是有限的，比如就4个G的内存

然后我们启动的Java系统本质就是一个JVM进程，他负责运行我们的系统的代码，这个之前都解释过了。

那么这个JVM进程本身也是会占用机器上的部分内存资源，比如占用2G的内存资源。

那么我们在JVM的Java堆内存中创建的对象，其实本质也是会占用JVM的内存资源的，比如“ReplicaManager”实例对象，会占用500字节的内存。

所以大家看到这里，心中应该无比明白的一个核心点：我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

大家看下面的图，感受会深一点。

![07_内存占用.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/43162800_1562230844.jpg)



**5、不再需要的那些对象应该怎么处理？**

继续思考上面的图，既然“ReplicaManager”对象实例是不需要使用的，已经没有任何方法的局部变量在引用这个实例对象了，而且他还空占着内存资源，那么我们应该怎么处理呢？

答案呼之欲出：**JVM的垃圾回收机制**

JVM本身是有垃圾回收机制的，他是一个后台自动运行的线程

你只要启动一个JVM进程，他就会自带这么一个垃圾回收的后台线程。

这个线程会在后台不断检查JVM堆内存中的各个实例对象

还是给大家画一张图，来看看这个过程：

![08_垃圾回收线程.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/54743400_1562230844.jpg)

如果某个实例对象没有任何一个方法的局部变量指向他，也没有任何一个类的静态变量，包括常量等地方在指向他。

那么这个垃圾回收线程，就会把这个没人指向的“ReplicaManager”实例对象给回收掉，从内存里清除掉，让他不再占用任何内存资源。

这样的话，这些不再被人指向的对象实例，即JVM中的“**垃圾**”，就会定期的被后台垃圾回收线程清理掉，不断释放内存资源

大家看下图：

![09_垃圾回收.jpg](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/74706600_1562230844.jpg)

到此为止，相信大家跟上文章思路一路看下来，就很清晰明了。到底什么是JVM中的“垃圾”？什么又是JVM的“垃圾回收”！



**6、本文小结**

不知不觉，第一周的文章都更新完毕了，希望大家温故而知新。

既然是付费来学习知识的，一定要对自己负责，坚持把每篇文章多看几遍，把知识吃透。

这周，我们为了照顾很多JVM的小白同学，从0起步，用最通俗易懂的语言和一步一图的方式，把你写好的Java代码如何通过JVM运行起来的核心原理都讲清楚了。

目前为止，大家应该对JVM的核心运行流程、JVM的类加载机制、JVM的内存区域以及垃圾回收机制都有一个初步的了解。

很多对JVM有一定了解的朋友一定会说：这些内容都很简单，有没有深入点的干货？

**有！**但是请不要着急，我们的专栏是兼顾各种基础的朋友，所以需要循序渐进，从浅入深。

比如JVM垃圾回收机制，就会在第三周详细讲解JVM的各种垃圾回收的细节

所以请大家稍安勿躁，一步一步来，如果有一定基础的同学，就当做复习一遍。

马上周末就是第一周的作业和答疑集锦了，大家周末记得完成作业，同时看一下每周最新的精华答疑集锦，从答疑中也能学习到一些知识。

**7、希望大家多帮忙宣传和推广**

专栏刚上线的时候，是拜托我的好朋友在公众号里宣传的，现在他还在一直坚持帮我们宣传，非常的感谢他。

不过当时刚上线，我们一篇文章都没更新，很多朋友对我们的文章质量是没有了解的，所以可能会犹豫不决要不要购买

不过经过一周文章下来，相信很多一路跟下来的朋友，都对这个专栏质量有了自己的了解和认可。

我和即将发布专栏的几位朋友都长年工作于一线大厂，比如阿里、百度、美团，等等，负责过多个大型系统的架构设计。

之所以聚在狸猫技术窝这个平台开设专栏，初衷就是为了帮助国内广大的java工程师，解决大家在面试中、工作中的一些痛点问题。

现在网上很多技术资料，但是鱼龙混杂，底子薄弱的朋友很难辨别其内容优劣，很容易被带跑偏。

所以我们几个朋友才希望通过自己的思路，来做一些高质量的专栏，将我们多年一线工作经验浓缩精华，传授给大家，也是为国内IT界尽一点绵薄之力。

但是由于刚开始做，很多人不了解我们，所以还是希望购买我们专栏的朋友，如果觉得我们的内容不错，帮忙多宣传一下。

大家可以根据下面步骤生成自己的海报，推荐给朋友，分享技术的同时还能获得一点收益。

最后，感谢大家为我们坚持长期推出更多好的专栏做出的支持！



**8、昨日思考题解答**

我们回到文章中，昨天给了一个思考题：我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？

这个其实很简单，一个对象对内存空间的占用，大致分为两块：

- 一个是对象自己本身的一些信息
- 一个是对象的实例变量作为数据占用的空间

比如对象头，如果在64位的linux操作系统上，会占用16字节，然后如果你的实例对象内部有个int类型的实例变量，他会占用4个字节，如果是long类型的实例变量，会占用8个字节。如果是数组、Map之类的，那么就会占用更多的内存了。

另外JVM对这块有很多优化的地方，比如补齐机制、指针压缩机制，这块东西我们不会单独拿出来讲，因为比较复杂，而且暂时对大家还不是很需要。

其实我信奉的一个道理，就是用案例实战来说话，引出很多技术和知识点的讲解，所以很多类似的知识，我会在后期大量的案例中去分析，需要的时候再学，效果最好。

这里就是先科普一下，让大家有一个基本的概念，如果有兴趣可以百度资料自己查阅。



**8、今日思考题**

既然今天提到了Java堆内存里的对象会被回收掉，那么加载到方法区的类会被垃圾回收吗？什么时候被回收？为什么呢？

大家可以思考一下这个问题，下周一的文章里会给出解答。

**End**

# 006、第1周作业：不借助任何资料，画出JVM整体运行原理图！

**作业内容：**

这是我们的专栏第一周的作业，首先我们来简单回顾一下。

这一周，我们从JVM的整体运行原理开始学习，分析了JVM的类加载机制，JVM的内存区域划分以及对应的工作原理，JVM的垃圾回收到底是什么。

所以第一周的定位，就是从最通俗的语言以及一步一图的方式，兼顾到很多JVM小白初学者，绝对跟着看下来可以快速入门JVM的基本工作原理，整体把握他的脉络。

对于已经对JVM有一定了解的朋友来说，就是快速简单梳理和回顾一下。

那么第一周的作业是什么呢？

很简单，希望大家把第一周的文章反复看几遍，完全做到心里有数

接着在不看任何资料的前提下，自己仿照文章那样，写出来一段代码，然后找一个画图工具，动手画图，把那段代码运行的时候，JVM的整个工作原理画出来。比如：

- 执行多个方法的调用时，如何把方法的栈帧压入线程的Java虚拟机栈？
- 栈帧里如何放局部变量？
- 如何在Java堆里创建实例对象？
- 如何让局部变量引用那个实例对象？
- 方法运行完之后如何出栈？
- 垃圾回收是如何运行的？

希望大家不借助资料，直接根据自己心里对JVM原理的理解，把这个图画出来。

再强调一下，我设计这个专栏的思路，就是每周必须有作业，因为光看不复习，光看不练，看了等于白看。

大家必须跟着完成作业，才能真正把学到的东西吸收成自己的东西，一个专栏跟下来，才能真正积累很多硬核技术。

希望大家周末都抽一点时间，完成本周作业。

# 007、第1周答疑：本周问题统一答疑

2019-06-23 14:39:29

**第一周问题统一答疑**



下面是本周大家的问题汇总，所有同学都可以看看，边看边思考！



**问题一：**

方法走完，引用消失，堆内存还未必消失。好多人在做报表导出的时候，就会在for循环里不断的创建对象，很容易造成堆溢出，请问这种大文件导出怎么破？

**答：**建议不要在for里创建对象，可以在外面搞一个对象，for循环里对一个对象修改数据即可

**问题二**

1.Java支持多线程，每个线程有自己的Java虚拟机栈和本地方法栈，是这样吗？ 

2.新建的实例在堆内存，实例变量也是在堆内存? 是这样吗？

**答：**1、2两点均理解正确

**问题三**

您好，我不太看懂入栈和出栈有什么意义，可以给我解释一下吗？谢谢！

**答：**入栈的时候，就是你执行一个方法的时候，为这个方法创建一个栈帧入栈

出栈，就是你的方法执行完毕了，就会出栈，其实这个不用急，明天的文章会有详细的图解，你会看明白的。

**问题四**

如果是父类子类的情况是下面哪种呢? 加载父类->加载子类->初始化父类->初始化子类, 加载父类->初始化父类->加载子类->初始化子类

**答：**不是的，加载父类就是父类，除非用到子类才会加载子类；但是加载子类要初始化之前，必须先加载父类，初始化父类

**问题五**

类加载器有三层，如果在第二层的类加载器可以加载这些类的话，就没有必要往上去找他的父类加载吗？

既然说类只有用到的时候才加载到内存中，那么new对象的时候肯定用到，但是是不是先经历过类的所有过程才将类实例化？

**答：**没错，必须先加载类，再实例化对象

**问题六**

第一课内容比较详细的讲解了java程序的执行过程，但是感觉提出的问题并不能在文章中找到答案，也许是一个课后需要自己找寻答案的提问？还是希望可以有一个比较全面的回答的

**答：**提出的问题是给大家的思考题，第二天会给出简单的解释，但是其实理解了文章的内容，完全可以自己找资料去理解，这是一个小作业，是一个思考的过程

**问题七**

Object Header（4字节） + Class Pointer（4字节）+ Fields（看存放类型），但是jvm内存占用是8的倍数，所以结果要向上取整到8的倍数

**答：**很好，就是这样

**问题八**

如果我有一个静态的成员变量int,那我多线程更改是否会有线程安全问题，为什么？

**答：**静态成员变量，他在内存里，只有一份，就是属于类的。你多个线程并发修改，一定会有并发问题，可能导致数据出错。

**问题九**

类加载是按需加载，可以一次性加载全部的类吗？

**答：**如果是默认的类加载机制，那么是你的代码运行过程中，遇到什么类加载什么类。如果你要自己加载类，那么需要写自己的类加载器

**问题十**

为什么必须要一级一级类加载器的往上找，直接从顶层类加载器开始找不就行了吗？

**答：**其实关于这个问题，不用过于纠结，每一层类加载器对某个类的加载，上推给父类加载器，到顶层类加载器，如果发现自己加载不到，再下推回子类加载器来加载，这样可以保证绝对不会重复加载某个类。

至于为什么不直接从顶层类加载器开始找，那是因为类加载器本身就是做的父子关系模型

你想一下Java代码实现，他最底下的子类加载器，只能通过自己引用的父类加载器去找。如果直接找顶层类加载器，不合适的，那么顶层类加载器不就必须硬编码规定了吗？

这就是一个代码设计思想，保证代码的可扩展性。

**问题十一**

是在执行new replicamanager()这行代码的时候加载replicamanger类吗？还是说加载cafka的时候就同时加载了呢？

**答：**执行new ReplicaManager的时候加载类

**问题十二**

还是没有明白 jvm和平时运行在机器上的系统之间是什么关系呢

**答：**其实很简单，你运行在机器上的系统，其实就是一个JVM进程，JVM进程会执行你系统里写好的那些代码

**问题十三**

1. class文件分配内存是在准备阶段，那类的class对象是在准备阶段创建的吗？ 
2. 如果实例变量有初始值，那实例变量是和类变量一同在初始化阶段赋值的吗？
3. 初始化之后是不是就有实例了

**答：**

1. 类是在准备阶段分配内存空间的
2. 实例变量得在你创建类的实例对象时才会初始化
3. 类的初始化阶段，仅仅是初始化类而已，跟对象无关，用new关键字才会构造一个对象出来



**问题十四**

双亲委派可以解决类重复加载的问题。按照文章中介绍每个类加载器有不同的类加载路径，这些类加载路径是否可能重叠？

**答：**不同类加载器的路径，一般是不会重叠的

**问题十五**

自定义的类加载器本身是由系统加载器加载的，也就是说其本身是没有加密的，那么我拿到该类反编译就可以看到如果解密class文件了，请问老师是这样么？

**答：**是的，所以说对class文件需要做特殊混淆处理，有商用的产品可以用

**问题十六**

作为一个web容器，既要解决跨应用公共共享问题也要解决独立应用独立问题。tomcat必须支持多层级的自定义类加载器

**答：**很好的推测，明天会给出答案

**问题十七**

用户使用类的时候应该是希望类已经准备好了一些数据，我猜想jvm设计者设计先执行static代码块的机制，是希望开发者在这里把使用类之前需要准备的工作在这里准备好 

1. 为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？
2. 启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要

**答：**

1. 没错，必须有初始化过程，准备好类级别的数据
2. 双亲委派，避免重复加载，评论区里多次回复了这个问题，可以看一看

**问题十八**

其实初始化时机就是对类的主动使用：调用静态方法时对类的主动使用的一种场景，main方法本质上是个static方法，没有调用的main方法和没有调用的static方法没区别！

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

**答：**不会的，你启动一个jar包，需要指定某个main主类，优先就是加载他

**问题十九**

tomcat本身是java程序，那么tomcat的实现程序的class是由应用类加载器加载的，用户自己的java程序war包，放入tomcat的程序的classpath中

这样用户的程序和tomcat的程序都是由应用类加载器加载了，也就是处于一个jvm中了（此问题是003文章底下的评论）

**答：**非常好的回复，明天文章会给出答案

**问题二十**

有一个问题，包含main方法的类会优先加载，如果一个项目中有多个类中都有main方法，都会加载么？

**答：**你启动一个jar包的时候，会指定是走哪个main方法所在的类，是唯一的

**问题二十一**

1. 为什么类的初始化需要执行静态代码块，给静态成员变量赋值，是因为这些数据是在方法区吗？
2. 启动类、扩展类和自定义加载器都已经指定了加载路径，所以不应该会有重复加载类的问题吧，所以双亲委派是不是没有必要

**答：**

1. 没错，类在方法区，他在内存里，所以你必须给他初始化，赋值
2. 还是有必要，比如启动类加载器，可以通过一些方式指定加载其他目录的类，那么你必须得走双亲委派，如果对那些特殊区域的类加载，走双亲委派，才能上推到启动类加载器去执行，不会重复加载

**问题二十二**

老师好请问类加载双亲委派机制 为什么要先找父加载 而不是自己找？这种设计的好处是？

**答：**好处就在于，每个层级的类加载器各司其职，而且不会重复加载一个类。

比如你代码里用两个不同层级的类加载器，都去尝试加载了某个类，如果有双亲委派机制，那么都会先找父类加载器去加载，如果加载到了，那么以后就只会是他去加载这个类。

否则如果没有双亲委派机制，那么岂不是两个不同层级的类加载器可以加载同一个类，造成类的重复加载！

**问题二十三**

自定义类加载器如何实现？

**答：**自己写一个类，继承ClassLoader类，重写类加载的方法，然后在代码里面可以用自己的类加载器去针对某个路径下的类加载到内存里来

**问题二十四**

看到一个词:动态部署，那么是否也有对应的静态部署?如何解释呢？ (谢老师回答)

**答：**假设一个背景在Tomcat部署系统的话，那么动态部署，也成为热部署

就是直接系统放入Tomcat对应目录，他自动就重新加载你最新的代码给你热部署了，不需要对Tomcat进行停机再重启；

反之，则是先停止Tomcat，然后部署最新代码到Tomcat对应目录里，然后重启Tomcat

**问题二十五**

-XX:+TraceClassLoading 可以看加载了哪些类，动手实验了一下，jre\lib\rt.jar下的类全部加载了，其他都是用到时候加载。

**答：**没错，明天更新的第三篇文章里，会讲解类加载机制，rt.jar这属于核心类库，属于支撑我们Java系统运行的底层类库，所以他一定会被加载

我们自己写的代码，一般是你代码运行使用到了哪个类，就会去加载哪个类

**问题二十六**

老师，类加载器是把jar包里的所有类一次性全部加载进去吗？

**答：**不是的，首先加载包含main方法的主类，接着是运行你写的代码的时候，遇到你用了什么类，再加载什么类

**问题二十七**

通过代码混淆机制，加大反编译之后的可读性！ 或者是否可以基于二进制加密呢，学生没用过！

**答：**其实现在对于这个一般都是用商业产品的，有很多第三方公司提供加密产品，可以百度一下，class文件加密，就可以看到，直接用他们的产品即可

**问题二十八**

Class源文件的保护，可以采用代码混淆技术，方式有很多，如回答区中老师提到的商用加密软件

**答：**非常好，就是这样

**问题二十九**

看文中内容，是会加载两次字节码吗，第一次加载进jvm，然后程序执行的时候再加载。有点不解！

**答：**你好，不是加载两次，是JVM先把“.class”字节码文件中的类加载到内存里，然后执行的时候，就直接使用加载好的类极客，不会重复加载

**问题三十**

class文件通过工具可以反编译的，请问有没有方法对class文件进行加密又不影响它的执行。windows桌面程序里一般都是打包成dll文件，java中有没有比较好的方式？

**答：**可以的，比如jvmti小工具就可以实现class文件的加密

另外其实为了保护源代码安全，有很多商业公司推出了专业级别的class加密产品，可以付费使用。

解密的话一般可以基于自定义的类加载器来实现，在加载类的时候把class给解密，这样就可以保护自己的源代码安全了。

最后，附上两张Tomcat类加载如果**按委派模型的加载流程和实际实现的流程**（专栏读者所画）

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/45640100_1562430625.png)



![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80064300_1562430625.png)



**End**

# 008、聊聊JVM分代模型：年轻代、老年代、永久代

2019-06-23 14:40:22

**聊聊JVM分代模型：年轻代、老年代、永久代**



**目录：**

1. 背景引入
2. 大部分对象其实存活周期极短
3. 少数对象是长期存活的
4. JVM分代模型：年轻代和老年代
5. 为什么要分成年轻代和老年代？
6. 什么是永久代？
7. 上周思考题解答
8. 今日思考题





**1、背景引入**

今天开始，咱们进入第二周的内容，这一周会重点关注JVM内存划分的一些细节。

我会帮助大家更加深入的去理解JVM内存划分的原理细节，以及我们创建的那些对象在JVM中到底是如何分配，如何流动的，这对于大家理解JVM原理有更深一层的帮助。

首先这篇文章作为本周的一个开篇，我们来给大家介绍一下JVM内存的一个分代模型：年轻代、老年代、永久代。

大家现在应该都知道一点，那就是我们在代码里创建的对象，都会进入到Java堆内存中，比如下面的代码：



![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/61041000_1562517499.png)



这段代码，我们稍微做了点改动，在main()方法里，会周期新的执行loadReplicasFromDisk()方法，加载副本数据。

首先一旦执行main()方法，那么就会把main()方法的栈帧压入main线程的Java虚拟机栈

如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/68813000_1562517499.cn/txdocpic/0/04e1bc7e9b465b7d40b1e46243f08344/0)

然后每次在while循环里，调用loadReplicasFromDisk()方法，就会把loadReplicasFromDisk()方法的栈帧压入自己的Java虚拟机栈

如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/80080800_1562517499.cn/txdocpic/0/e3896c4cea154b2422622ec685e74752/0)

接着在执行loadReplicasFromDisk()方法的时候，会在Java堆内存里会创建一个ReplicaManager对象实例

而且loadReplicasFromDisk()方法的栈帧里会有“replicaManager”局部变量去引用Java堆内存里的ReplicaManager对象实例

如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/5349600_1562517500.cn/txdocpic/0/8d169c754c01f0340e3b1d9f40654709/0)

然后就会执行ReplicaManager对象的load()方法。



**2、大部分对象都是存活周期极短的**

现在有一个问题，在上面代码中，那个ReplicaManager对象，实际上属于短暂存活的这么一个对象

大家可以观察一下，在loadReplicasFromDisk()方法中创建这个对象，然后执行ReplicaManager对象的load()方法，然后执行完毕之后，loadReplicasFromDisk()方法就会结束。

一旦方法结束，那么loadReplicasFromDisk()方法的栈帧就会出栈，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24039100_1562517500.cn/txdocpic/0/d4436bf7fba6fe0bae6ba1e7f81de053/0)

然后接着上篇文章已经说过，此时一旦没人引用这个ReplicaManager对象了，就会被JVM的垃圾回收线程给回收掉，释放内存空间，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/40140000_1562517500.cn/txdocpic/0/5046e4459ba2213095b4699d6f6d38c2/0)

然后在main()方法的while循环里，下一次循环再次执行loadReplicasFromDisk()方法的时候，又会走一遍上面那个过程，把loadReplicasFromDisk()方法的栈帧压入Java虚拟机栈，然后构造一个ReplicaManager实例对象放在Java堆里。

一旦执行完ReplicaManager对象的load()方法之后，loadReplicasFromDisk()方法又会结束，再次出栈，然后垃圾回收释放掉Java堆内存里的ReplicaManager对象。

所以其实这个ReplicaManager对象，在上面的代码中，是一个存活周期极为短暂的对象

可能每次执行loadReplicasFromDisk()方法的时候，被创建出来，然后执行他的load()方法，接着可能1毫秒之后，就被垃圾回收掉了。

所以从这段代码就可以明显看出来，大部分在我们代码里创建的对象，其实都是存活周期很短的。这种对象，其实在我们写的Java代码中，占到绝大部分的比例。



**3、少数对象是长期存活的**

但是我们来看另外一段代码，假如说咱们用下面的这种方式来实现同样的功能：

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/66557000_1562517500.png)



上面那段代码的意思，就是给Kafka这个类定义一个静态变量，也就是“replicaManager”，这个Kafka类是在JVM的方法区里的

然后让“replicaManager”引用了一个在Java堆内存里创建的ReplicaManager实例对象，如下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/82266400_1562517500.cn/txdocpic/0/b54c781435cdcbb11230945ba6d41d32/0)

接着在main()方法中，就会在一个while循环里，不停的调用ReplicaManager对象的load()方法，做成一个周期性运行的模式。

这个时候，我们就要来思考一下，这个ReplicaManager实例对象，他是会一直被Kafka的静态变量引用的，然后会一直驻留在Java堆内存里，是不会被垃圾回收掉的。

因为这个实例对象他需要长期被使用，周期新的被调用load()方法，所以他就成为了一个长时间存在的对象。

那么类似这种被类的静态变量长期引用的对象，他需要长期停留在Java堆内存里，这这种对象就是生存周期很长的对象，他是轻易不会被垃圾回收的，他需要长期存在，不停的去使用他。



**4、JVM分代模型：年轻代和老年代**

接下来就要进入今天的核心主题了，就是JVM的分代模型，年轻代和老年代。

现在大家已经看到，其实根据你写代码方式的不同，采用不同的方式来创建和使用对象，其实对象的生存周期是不同的。

所以JVM将Java堆内存划分为了两个区域，一个是年轻代，一个是老年代。

其中年轻代，顾名思义，就是把第一种代码示例中的那种，创建和使用完之后立马就要回收的对象放在里面

然后老年代呢，就是把第二种代码示例中的那种，创建之后需要一直长期存在的对象放在里面，大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/94531400_1562517500.cn/txdocpic/0/5b65435b96c37267ecbb717150fd21e1/0)

比如下面的代码，我们再次来改造一下，再结合图，大家会看的更加的明确一些。

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/4526200_1562517501.png)



上面那段代码稍微复杂了点，我们解释一下

Kafka的静态变量“fetcher”引用了ReplicaFetcher对象，这是长期需要驻留在内存里使用的

这个对象会在年轻代里停留一会儿，但是最终会进入老年代，大家看下图。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/18143000_1562517501.cn/txdocpic/0/2c949e48487721b4f6018daf6fb91cad/0)

进入main()方法之后，会先调用loadReplicasFromDisk()方法，业务含义是系统启动就从磁盘加载一次副本数据，这个方法的栈帧会入栈

然后在这个方法里面创建了一个ReplicaManager对象，这个对象他是用完就会回收，所以是会放在年轻代里的，由栈帧里的局部变量来引用

此时对应着下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/39173000_1562517501.cn/txdocpic/0/9cddbf1f5698d44fcec30cd48c5e7ca5/0)

然后一旦loadReplicasFromDisk()方法执行完毕了，方法的栈帧就会出栈，对应的年轻代里的ReplicaManager对象也会被回收掉，如下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53703400_1562517501.cn/txdocpic/0/7e4a0ec31f4e69e421c11d7ab874443a/0)

但是接着会执行一段while循环代码，他会周期性的调用ReplicaFetcher的fetch()方法，去从远程加载副本数据。

所以ReplicaFetcher这个对象因为被Kafka类的静态变量fetcher给引用了，所以他会长期存在于老年代里的，持续被使用。



**5、为什么要分成年轻代和老年代？**

相信看完这篇文章，大家就一定看明白了，什么样的对象是短期存活的对象，什么样的对象是长期存在的对象，然后如何分别存在于年轻代和老年代里。

那么为什么需要这么区分呢？

因为这跟垃圾回收有关，对于年轻代里的对象，他们的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法

对于老年代里的对象，他们的特点是需要长期存在，所以需要另外一种垃圾回收算法，所以需要分成两个区域来放不同的对象。

很多人又会问了，你不是说“ReplicaFetcher”这个长期存在的对象，刚开始也在年轻代，后来才会进入老年代么？那他到底什么时候进入老年代？

别急，明天的文章就会分析这块。

然后还有人还会问了，那么年轻代和老年代分别怎么进行垃圾回收呢？

别急，下周的文章会主要分析垃圾回收这块的原理。这周我们主要关注JVM的内存划分的细节，搞明白对象是如何在不同的内存区域里分配的就可以了，学习要循序渐进。



**6、什么是永久代？**

很简单，JVM里的永久代其实就是我们之前说的方法区

上面那个图里的方法区，其实就是所谓的永久代，你可以认为永久代就是放一些类信息的。

这个话题现在不用过多考虑，后续涉及到的时候，我们会讲到的。



**7、上周思考题解答**

上周留了一个思考题，让大家思考**方法区内会不会进行垃圾回收**

其实有同学都回答了，非常的好，在以下几种情况下，方法区里的类会被回收。

- 首先该类的所有实例对象都已经从Java堆内存里被回收
- 其次加载这个类的ClassLoader已经被回收
- 最后，对该类的Class对象没有任何引用

满足上面三个条件就可以回收该类了。



**8、今日思考题**

给大家出一个脑筋急转弯，出题思路有点偏：每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？

# 009、大厂面试题：你的对象在JVM内存中如何分配？如何流转的？

2019-06-23 21:20:27

**大厂面试题：**

**你的对象在JVM内存中如何分配？如何流转的？**



**目录：**

1. 前文回顾
2. 大部分正常对象都优先在新生代分配内存
3. 到底什么情况下会触发新生代的垃圾回收？
4. 长期存活的对象会躲过多次垃圾回收
5. 老年代会垃圾回收吗？
6. 关于新生代和老年代的对象分配，这就完了吗？
7. 昨日思考题解答
8. 今日思考题



**1、前文回顾**

经过昨天的文章铺垫了一些对象分配的基础知识后，想必大家现在都心里非常有数了，咱们平时代码里创建出来的对象，一般就是两种：

- 一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收
- 另外一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用

第一种短期存活的对象，是在Java堆内存的新生代里的。第二种长期存活的对象，是在Java堆内存的老年代里的。这个结论，想必大家都已经理解了

好，那么接下来我们就来聊聊，对象到底什么时候进入新生代？然后什么情况下会进入老年代？

**提示一下：**本文是建立在大家都绝对理解上文的基础上来写的，上文是结合代码示例来阐述的核心原理，包括对象什么情况下短期存活，什么情况下长期存活。

所以本文就直接通过大量图示来给大家分析对象在内存中的分配机制了，大家务必透彻理解上文。

**2、大部分正常对象都优先在新生代分配内存**

首先我们先来看上篇文章中的一段代码，稍微带着大家来理解一个概念：大部分的正常对象，都是优先在新生代分配内存的。

![blob.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/76237100_1562572322.png)



大家还记得上面那段代码吗？虽然我们看代码知道，类静态变量“fetcher”引用的那个“ReplicaFetcher”对象，是会长期存活在内存里的

但是哪怕是这种对象，其实刚开始你通过“new ReplicaFetcher()”代码来实例化一个对象时，他也是分配在新生代里的。

包括在“loadReplicasFromDisk()”方法中创建的“ReplicaManager”实例对象，也都是一样分配在新生代里的

同样，我们以一张图，来展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/10298400_1562572323.cn/txdocpic/0/0e833f156ae7201a3e89d7afb5cd6447/0)



**3、到底什么情况下会触发新生代的垃圾回收？**

现在咱们来假设一个场景，大家应该都知道，一旦“loadReplicasFromDisk()”方法执行完毕之后，这个方法的栈帧出栈，会导致没有任何局部变量引用那个“ReplicaManager”实例对象了。

此时可能会如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/36887600_1562572323.cn/txdocpic/0/408a5832f0db1590fc21d80316d7999c/0)

那么此时就一定会立即发生垃圾回收，去回收掉Java堆内存里那个没人使用的“ReplicaManager”实例对象吗？

**NO！**大家别想的那么简单了，实际上垃圾回收他也得有点触发的条件。

其中一个比较常见的场景可能是这样的，假设我们写的代码中创建了N多对象，然后导致Java堆内存里囤积了大量的对象。

然后这些对象都是之前有人引用，比如各种各样的方法中的局部变量，但是现在也都没人引用了。

如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65138200_1562572323.cn/txdocpic/0/7da071c8655b2eedcefb725a764df5b4/0)

这个时候，如果新生代我们预先分配的内存空间，几乎都被全部对象给占满了！此时假设我们代码继续运行，他需要在新生代里去分配一个对象，怎么办？发现新生代里内存空间都不够了！

这个时候，就会触发一次新生代内存空间的垃圾回收，新生代内存空间的垃圾回收，也称之为“Minor GC”，有的时候我们也叫“Young GC”，他会尝试把新生代里那些没有人引用的垃圾对象，都给回收掉。

比如上图中，那个“ReplicaManager”实例对象，其实就是没有人引用的垃圾对象

此时就会当机立断，把“ReplicaManager”实例对象给回收掉，腾出更多的内存空间，然后放一个新的对象到新生代里去。

包括上图中那大量的实例对象，其实也都没人引用，在这个新生代垃圾回收的过程中，就会把这些垃圾对象也都回收掉。

其实话说回来，大家自己仔细回忆一下，我们在代码中创建的大部分对象，其实都是这种使用之后立马就可以回收掉的生存周期极短的对象，是不是？

可能我们会在新生代里分配大量的对象，但是使用完之后立马就没人引用了，此时新生代差不多满了

然后要分配新的对象的时候，发现新生代内存空间不足，就会触发一次垃圾回收，然后就把所有垃圾对象给干掉，腾出大量的内存空间

如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/97232300_1562572323.cn/txdocpic/0/eee50e7b70be6d23c59ccfb2742c4dd9/0)



**4、长期存活的对象会躲过多次垃圾回收**

接着我们来看下一个问题，上图中大家都注意到了“ReplicaFetcher”实例对象，他是一个长期被“Kafka”类的静态变量“fetcher”引用的长期存活的对象。

所以虽然你的新生代可能随着系统的运行，不停的创建对象，然后让新生代变满，接着垃圾回收一次，大量对象被回收掉

但是你的这个“ReplicaFetcher”对象，他确是一直会存活在新生代里的。

因为他一直被“Kafka”类的静态变量给引用了，所以他不会被回收。那么此时JVM就有一条规定了

如果一个实例对象在新生代中，成功的在15次垃圾回收之后，还是没被回收掉，就说明他已经15岁了。

这是对象的年龄，每垃圾回收一次，如果一个对象没被回收掉，他的年龄就会增加1。

所以如果上图中的那个“ReplicaFetcher”对象在新生代中成功躲过10多次垃圾回收，成为一个“老年人”，那么就会被认为是会长期存活在内存里的对象。

然后他会被转移到Java堆内存的老年代中去，顾名思义，老年代就是放这些年龄很大的对象。

我们再来看一张图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/21115900_1562572324.cn/txdocpic/0/4d4ea63678b59270725c2bf57b7005df/0)



**5、老年代会垃圾回收吗？**

接着下一个问题就是，老年代里的那些对象会被垃圾回收吗？

答案是**肯定的**，因为老年代里的对象也有可能随着代码的运行，不再被任何人引用了，就需要被垃圾回收。

大家可以思考一下，如果随着类似上面的情况，越来越多的对象进入老年代，一旦老年代也满了，是不是就要对老年代垃圾回收了？

没错，这是肯定的，但是暂时我们先不用过多的去考虑这里的细节，因为这将是**下周的主题**，下周我们会进行深入剖析。



**6、关于新生代和老年代的对象分配，这就完了吗？**

还有人会说，关于新生代和老年代的对象分配，这就结束了吗？

当然不是，今天这篇文章，仅仅是相较于之前的文章，更进一步给大家分析了一下对象分配的一些机制。

但是其实在对象分配这块，还有很多其他的复杂机制，比如：

- 新生代垃圾回收之后，因为存活对象太多，导致大量对象直接进入老年代
- 特别大的超大对象直接不经过新生代就进入老年代
- 动态对象年龄判断机制
- 空间担保机制

可能一些JVM书籍会在这里一下把这些复杂的东西都写出来给大家，但是我们的专栏不会是这个思路。

还是那句话，我们的专栏写作思路是循序渐进，从浅入深，通俗易懂，一步一图。

很多底层技术细节，不要在前期铺垫太多，会导致很多同学吃了没法消化

**我会****结合后续大量案例，结合真实生产问题，把JVM各种底层细节带出来。****结合实战食用，效果更佳。**

因此第二周，大家对对象内存分配，了解到这个程度就行了，给大家总结一下：

- 先理解对象优先分配在新生代
- 新生代如果对象满了，会触发Minor GC回收掉没有人引用的垃圾对象
- 如果有对象躲过了十多次垃圾回收，就会放入老年代里
- 如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉

大家通过本文，先理解上面几点即可。



**7、昨日思考题解答**

昨天的思考题，是一个脑筋急转弯，说每个线程执行方法的时候，那些方法对应的栈帧出栈了，那么那里的局部变量需要垃圾回收吗？

其实这是一个偏题，JVM里垃圾回收针对的是新生代，老年代，还有方法区（永久代），不会针对方法的栈帧。

方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉了。



**8、今日思考题**

今天想给大家出一个预习类的思考题：理解了今天的对象内存分配，垃圾回收以及老年代转移的机制之后。

大家能否结合短生存周期的对象的特点，以及长生存周期的对象的特点，思考一下，看看你们手头正在负责的系统，梳理梳理里面短生存周期的对象都有什么，长生存周期的对象都有什么。

可以在评论区踊跃回复，让大家开始从JVM的角度去思考自己手头负责的系统中的代码是怎么运行的。

**End**